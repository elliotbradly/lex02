(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw ((a.code = "MODULE_NOT_FOUND"), a);
        }
        var p = (n[i] = { exports: {} });
        e[i][0].call(
          p.exports,
          function (r) {
            var n = e[i][1][r];
            return o(n || r);
          },
          p,
          p.exports,
          r,
          e,
          n,
          t
        );
      }
      return n[i].exports;
    }
    for (
      var u = "function" == typeof require && require, i = 0;
      i < t.length;
      i++
    )
      o(t[i]);
    return o;
  }
  return r;
})()(
  {
    1: [
      function (require, module, exports) {
        (function (global) {
          global.E = require("../dist/000.main/00.core/constant/EVENT");
          global.SIM = require("../dist/000.main/00.core/0pen");

          var init, test;

          var wake = () => {
            init = require("../dist/000.main/00.init");
            init.event.on(E.COMPLETE, run);
            init.wake(SIM.bee);
          };

          var run = () => {
            test = require("../dist/000.main/00.work.main");
            test.wake(SIM.bee);
          };

          SIM.event.on(E.COMPLETE, wake);
          SIM.wake();
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {
        "../dist/000.main/00.core/0pen": 2,
        "../dist/000.main/00.core/constant/EVENT": 5,
        "../dist/000.main/00.init": 24,
        "../dist/000.main/00.work.main": 25,
      },
    ],
    2: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        require("reflect-metadata");
        const beeing_1 = require("./beeing");
        const line_1 = require("./line");
        const path_form_1 = require("./form/path.form");
        const E = require("./constant/EVENT");
        var EventEmitter = require("events").EventEmitter;
        var self = {
          dev: true,
          wake: null,
          start: null,
          sim: null,
          line: null,
          route: null,
          bee: null,
          event: new EventEmitter(),
        };
        self.wake = () => {
          self.bee = new beeing_1.default();
          self.line = new line_1.default();
          self.event.emit(E.COMPLETE);
          return self.line;
        };
        self.route = (pth, mth) => {
          var path = new path_form_1.default(pth, mth);
          self.line.route(path);
        };
        module.exports = self;
      },
      {
        "./beeing": 3,
        "./constant/EVENT": 5,
        "./form/path.form": 7,
        "./line": 8,
        events: 56,
        "reflect-metadata": 100,
      },
    ],
    3: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const state_1 = require("./state");
        const line_1 = require("./line");
        const TitleHark = require("./title/title.hark");
        const path_process_1 = require("./title/prc/path.process");
        const typescript_ioc_1 = require("typescript-ioc");
        const B = require("./constant/BASIC");
        const queryString = require("query-string");
        const doT = require("dot");
        const S = require("string");
        const path_form_1 = require("./form/path.form");
        const Import = require("../BEE");
        class Beeing {
          constructor() {
            this.power = (val, mth, dat) => {
              if (mth == null) mth = B.CREATE;
              var list = val.split("\n");
              if (dat != null) {
                list.forEach((a, b) => {
                  //a = S(a).replaceAll(",", "*").s;
                  if (a == null) return;
                  this.doTCompiled = doT.template(a);
                  list[b] = this.doTCompiled(dat);
                });
              }
              list.forEach((a) => {
                if (a.length <= 3) return;
                if (S(a).contains("//")) return; //true
                var dom = a.split(":")[0];
                if (dom == null) return;
                dom = S(dom).collapseWhitespace().s;
                var sub = a.split(":")[1];
                if (sub == null) return;
                sub = S(sub).collapseWhitespace().s;
                //console.log("dom " + dom);
                //console.log("sub " + sub);
                var comma = sub.split(",");
                comma.forEach((e, f) => {
                  comma[f] = S(e).collapseWhitespace().s;
                });
                var age = {
                  idx: comma[0],
                };
                //console.log(age.idx + " idx to work " + age.idx.length);
                var type = "";
                comma.forEach((a, b) => {
                  if (b == 0) return;
                  //if (b % 2 == 1) console.log("dom: " + a);
                  if (b % 2 == 1) type = a;
                  //if (b % 2 == 0) console.log("sub: " + a);
                  if (b % 2 == 0) age[type] = a;
                  //if (b % 2 == 0) console.log("midling " + age[type]);
                });
                //console.log("age " + JSON.stringify(age));
                if (age.idx != null)
                  age.idx = S(age.idx).collapseWhitespace().s;
                this.sing(dom, mth, age);
              });
            };
            this.hark = (key, rsp) => {
              return this.state.hark(key).subscribe(rsp);
            };
            this.move = (type, bale) => this.path.move(this.state, type, bale);
            this.sing = (pth, mth, dat, spd) => {
              //console.log('send patth: ' + pth );
              if (pth.includes("/") == false) pth = pth + "/index";
              if (spd != null)
                return this.path.link(this.state, pth, mth, dat, spd);
              if (dat != null) pth += "?" + queryString.stringify(dat);
              return this.line.route(new path_form_1.default(pth, mth));
            };
            this.hike = this.sing;
            this.song = (song) => {
              console.log("show me song " + JSON.stringify(song));
              this.sing(song.pth, song.mth, song.dat, song.spd);
            };
            this.state = new state_1.default();
            this.line = new line_1.default();
            //this.imports.forEach((i) => new i(this.line, this.state));
            for (var k in Import.list)
              new Import.list[k](this.line, this.state);
            this.state
              .hark(TitleHark.PATH)
              .subscribe((val) => this.line.route(val));
            this.value = this.state.value;
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          Beeing.prototype,
          "path",
          void 0
        );
        exports.default = Beeing;
      },
      {
        "../BEE": 47,
        "./constant/BASIC": 4,
        "./form/path.form": 7,
        "./line": 8,
        "./state": 9,
        "./title/prc/path.process": 15,
        "./title/title.hark": 19,
        dot: 54,
        "query-string": 82,
        string: 560,
        "typescript-ioc": 571,
      },
    ],
    4: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.AWAKE = "awake";
        exports.CREATE = "create";
        exports.COPY = "copy";
        exports.CLOSE = "close";
        exports.DELETE = "delete";
        exports.INIT = "init";
        exports.LIST = "list";
        exports.LOAD = "load";
        exports.MAKE = "make";
        exports.QUE = "que";
        exports.OPEN = "open";
        exports.READ = "read";
        exports.REPLACE = "replace";
        exports.REMOVE = "remove";
        exports.RESIZE = "resize";
        exports.UPDATE = "update";
        exports.WRITE = "write";
      },
      {},
    ],
    5: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.PAD_PRESS = "[play action] Pad Press";
        exports.KEY_PRESS = "[play action] Key Press";
        exports.COMPLETE = "[sim action] Complete";
        exports.MESSAGE = "[sim action] Message";
      },
      {},
    ],
    6: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        class Arc {
          constructor(state) {}
          create(dat) {}
          read(dat) {}
          update(dat) {}
          delete(dat) {}
          response(val) {}
        }
        exports.default = Arc;
      },
      {},
    ],
    7: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const B = require("../constant/BASIC");
        class Path {
          constructor(pth, mth = null, dat) {
            this.path = pth;
            this.method = mth;
            this.data = dat;
            if (this.method == null) this.method = B.READ;
          }
        }
        exports.default = Path;
      },
      { "../constant/BASIC": 4 },
    ],
    8: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const queryString = require("query-string");
        const path_form_1 = require("./form/path.form");
        const B = require("./constant/BASIC");
        class Line {
          constructor() {
            this.address = {};
            this.addressList = [];
          }
          route(lnk) {
            if (lnk == null) return;
            if (typeof lnk === "string" || lnk instanceof String) {
              lnk = new path_form_1.default(String(lnk));
            }
            if (lnk.method == null) lnk.method = B.READ;
            //this.log.save(lnk);
            var data;
            var params = lnk.path.split("?");
            if (params.length > 1) {
              data = queryString.parseUrl(lnk.path).query;
              lnk.path = params[0];
            }
            if (lnk.data != null) data = lnk.data;
            var out = { path: "", bale: {} };
            return this.action(lnk.method, lnk.path, data);
          }
          register(dat) {
            var closed = false;
            this.addressList.forEach((a) => {
              if (a.path == dat.path) return (closed = true);
            });
            if (closed) return console.log(dat.path + " ROUTE CLOSED");
            this.address[dat.path] = dat.arc;
            this.addressList.push(dat);
          }
          action(typ, pth, dat, cbk = null) {
            var item = this.address[pth];
            if (item == null) return console.log("item missing pth " + pth);
            if (item[typ] == null)
              return console.log("action not possible for " + typ);
            dat = item[typ](dat);
            if (cbk != null) cbk(dat);
            return dat;
          }
        }
        exports.default = Line;
      },
      { "./constant/BASIC": 4, "./form/path.form": 7, "query-string": 82 },
    ],
    9: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const rxjs_compat_1 = require("rxjs-compat");
        const dispatcher_1 = require("./utility/dispatcher");
        const BEE_1 = require("../BEE");
        const Effect = require("../BEE");
        class State extends rxjs_compat_1.BehaviorSubject {
          constructor(init = new BEE_1.default()) {
            super(init);
            this.dispatcher = new dispatcher_1.Dispatcher();
            this.log = [];
            this.save = () => {
              var stage = this.value.stage;
              this.value.stage = null;
              var past = JSON.stringify(this.value);
              this.log.push(past);
              this.value.stage = stage;
              return past;
              console.log("size log " + this.log.length);
            };
            this.undo = () => {
              //this.log.pop();
              var item = this.log.pop();
              console.log("size log " + this.log.length);
              if (item == null) return;
              return JSON.parse(item);
            };
            this.dispatcher
              //.let(this.preMiddleware)
              .scan((state, action) => this.reducedApp(state, action), init)
              //.let(this.postMiddleware)
              .subscribe((state) => {
                //push the model some where
                super.next(state);
              });
            //var item = this.select("color");
            //this.combineEffect(this.dispatcher, item).subscribe(this.dispatcher);
          }
          hark(key) {
            var list = key.split(".");
            var sig = "";
            list.forEach((a) => (sig += "['" + a + "']"));
            var partA = "this.map(state => state";
            var partC = ").distinctUntilChanged();";
            var end = partA + sig + partC;
            //console.log("you want to select " + end);
            return eval(end);
          }
          reducedApp(nextState, key) {
            for (var k in Effect.reducer)
              Effect.reducer[k](nextState[k], key, this);
            //StateReducer.reducer(nextState, key);
            //this.combineSpin(nextState, key);
            return nextState;
          }
          dispatch(value) {
            this.dispatcher.dispatch(value);
          }
          pat(value) {
            this.dispatch(value);
          }
          next(value) {
            this.dispatcher.dispatch(value);
          }
        }
        exports.default = State;
      },
      { "../BEE": 47, "./utility/dispatcher": 23, "rxjs-compat": 101 },
    ],
    10: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const _01_index_title_arc_1 = require("./01.index.title.arc");
        const _02_menu_title_arc_1 = require("./02.menu.title.arc");
        const _03_game_pad_title_arc_1 = require("./03.game-pad.title.arc");
        exports.root = "title";
        exports.routes = [
          {
            path: "index",
            arcType: _01_index_title_arc_1.default,
            arc: null,
          },
          {
            path: "menu",
            arcType: _02_menu_title_arc_1.default,
            arc: null,
          },
          {
            path: "game-pad",
            arcType: _03_game_pad_title_arc_1.default,
            arc: null,
          },
        ];
        class DisplayRoutingUnit {
          constructor(router, state) {
            exports.routes.forEach((a) => {
              a.path = exports.root + "/" + a.path;
              a.arc = new a.arcType(state);
              router.register(a);
            });
          }
        }
        exports.default = DisplayRoutingUnit;
      },
      {
        "./01.index.title.arc": 11,
        "./02.menu.title.arc": 12,
        "./03.game-pad.title.arc": 13,
      },
    ],
    11: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const arc_form_1 = require("../../form/arc.form");
        const path_process_1 = require("../prc/path.process");
        const typescript_ioc_1 = require("typescript-ioc");
        const Act = require("../title.action");
        const title_process_1 = require("../prc/title.process");
        class IndexTitleArc extends arc_form_1.default {
          constructor(state) {
            super(state);
            this.state = state;
            this.list = (dat) => this.path.move(this.state, Act.COUNT, dat);
            this.create = (dat) =>
              this.path.move(this.state, Act.TITLE_OPEN, dat);
            this.update = (dat) => this.path.move(this.state, Act.RESIZE, dat);
            this.delete = (dat) => {};
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          IndexTitleArc.prototype,
          "path",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", title_process_1.default),
          ],
          IndexTitleArc.prototype,
          "title",
          void 0
        );
        exports.default = IndexTitleArc;
      },
      {
        "../../form/arc.form": 6,
        "../prc/path.process": 15,
        "../prc/title.process": 16,
        "../title.action": 17,
        "typescript-ioc": 571,
      },
    ],
    12: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const arc_form_1 = require("../../form/arc.form");
        const path_process_1 = require("../prc/path.process");
        const typescript_ioc_1 = require("typescript-ioc");
        const title_process_1 = require("../prc/title.process");
        class MenuTitleArc extends arc_form_1.default {
          constructor(state) {
            super(state);
            this.state = state;
            this.read = (dat) => {
              //console.log("do something good");
              // this.title.menu(this.state, index(this.state));
            };
            this.list = (dat) => {};
            this.update = (dat) => {
              //this.path.move(this.state, Act.GRID_MENU_ACTION, dat.value);
            };
            //create = dat => this.path.move(this.state, Act.GRID_MENU, dat);
            this.delete = (dat) => {};
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          MenuTitleArc.prototype,
          "path",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", title_process_1.default),
          ],
          MenuTitleArc.prototype,
          "title",
          void 0
        );
        exports.default = MenuTitleArc;
      },
      {
        "../../form/arc.form": 6,
        "../prc/path.process": 15,
        "../prc/title.process": 16,
        "typescript-ioc": 571,
      },
    ],
    13: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const arc_form_1 = require("../../form/arc.form");
        const Act = require("../title.action");
        const path_process_1 = require("../prc/path.process");
        const typescript_ioc_1 = require("typescript-ioc");
        class GamePadArc extends arc_form_1.default {
          constructor(state) {
            super(state);
            this.state = state;
            this.read = (dat) => {
              //console.log("do something good");
            };
            this.list = (dat) => {};
            this.update = (dat) =>
              this.path.move(this.state, Act.PAD_PRESS, dat);
            this.create = (dat) => {
              //this.state.dispatch({ type: Act.INIT_BEEING });
            };
            this.delete = (dat) => {};
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          GamePadArc.prototype,
          "path",
          void 0
        );
        exports.default = GamePadArc;
      },
      {
        "../../form/arc.form": 6,
        "../prc/path.process": 15,
        "../title.action": 17,
        "typescript-ioc": 571,
      },
    ],
    14: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.resizeTitle = (cpy, bal) => {
          delete cpy.size;
          cpy.size = { width: bal.width, height: bal.height };
        };
        exports.writeCount = (cpy) => {
          cpy.count += 1;
          return cpy;
        };
        exports.updatePath = (cpy, bale) => {
          cpy.path = bale;
          return cpy;
        };
        exports.writeGamePad = (cpy, bale) => {
          cpy.padValue = null;
          cpy.padValue = bale;
          return cpy;
        };
      },
      {},
    ],
    15: [
      function (require, module, exports) {
        (function (process) {
          "use strict";
          var __decorate =
            (this && this.__decorate) ||
            function (decorators, target, key, desc) {
              var c = arguments.length,
                r =
                  c < 3
                    ? target
                    : desc === null
                    ? (desc = Object.getOwnPropertyDescriptor(target, key))
                    : desc,
                d;
              if (
                typeof Reflect === "object" &&
                typeof Reflect.decorate === "function"
              )
                r = Reflect.decorate(decorators, target, key, desc);
              else
                for (var i = decorators.length - 1; i >= 0; i--)
                  if ((d = decorators[i]))
                    r =
                      (c < 3
                        ? d(r)
                        : c > 3
                        ? d(target, key, r)
                        : d(target, key)) || r;
              return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
          var __metadata =
            (this && this.__metadata) ||
            function (k, v) {
              if (
                typeof Reflect === "object" &&
                typeof Reflect.metadata === "function"
              )
                return Reflect.metadata(k, v);
            };
          Object.defineProperty(exports, "__esModule", { value: true });
          const typescript_ioc_1 = require("typescript-ioc");
          const B = require("../../constant/BASIC");
          const Act = require("../title.action");
          const queryString = require("query-string");
          const path_form_1 = require("../../form/path.form");
          let PathProcess = class PathProcess {
            constructor() {
              this.move = (state, type, bale) => {
                state.dispatch({
                  type: type,
                  bale: bale,
                });
              };
              this.link = (ste, pth, mth, dat, spd) => {
                if (mth == null) mth = B.READ;
                if (spd == null) spd = 1;
                //remember you can not handle nested objects
                if (dat != null) pth += "?" + queryString.stringify(dat);
                if (spd == null) spd = 0;
                if (spd == 0) {
                  ste.dispatch({
                    type: Act.UPDATE_PATH,
                    bale: new path_form_1.default(pth, mth),
                  });
                  return;
                }
                if (spd == 1) {
                  process.nextTick(() => {
                    ste.dispatch({
                      type: Act.UPDATE_PATH,
                      bale: new path_form_1.default(pth, mth),
                    });
                  });
                } else {
                  setTimeout(() => {
                    ste.dispatch({
                      type: Act.UPDATE_PATH,
                      bale: new path_form_1.default(pth, mth),
                    });
                  }, spd);
                }
              };
            }
          };
          PathProcess = __decorate(
            [typescript_ioc_1.Singleton, __metadata("design:paramtypes", [])],
            PathProcess
          );
          exports.default = PathProcess;
        }.call(this, require("_process")));
      },
      {
        "../../constant/BASIC": 4,
        "../../form/path.form": 7,
        "../title.action": 17,
        _process: 80,
        "query-string": 82,
        "typescript-ioc": 571,
      },
    ],
    16: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const typescript_ioc_1 = require("typescript-ioc");
        //captain beefheart and his magic band
        let TitleProcess = class TitleProcess {
          constructor() {
            this.menu = (state, bale) => {
              //console.log("dispatch the grid menu " + JSON.stringify(bale));
            };
          }
        };
        TitleProcess = __decorate(
          [typescript_ioc_1.Singleton, __metadata("design:paramtypes", [])],
          TitleProcess
        );
        exports.default = TitleProcess;
      },
      { "typescript-ioc": 571 },
    ],
    17: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.COUNT = "[title action] Count";
        class Count {
          constructor() {
            this.type = exports.COUNT;
          }
        }
        exports.Count = Count;
        exports.RESIZE = "[stage action] Resize";
        class Resize {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.RESIZE;
          }
        }
        exports.Resize = Resize;
        exports.PAD_PRESS = "[play action] Pad Press";
        class PadPress {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.PAD_PRESS;
          }
        }
        exports.PadPress = PadPress;
        exports.UPDATE_PATH = "[play action] Update Path";
        class UpdatePath {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.UPDATE_PATH;
          }
        }
        exports.UpdatePath = UpdatePath;
        exports.TITLE_OPEN = "[wakeTitle action] Waking Title";
        class OpenTitle {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.TITLE_OPEN;
          }
        }
        exports.OpenTitle = OpenTitle;
      },
      {},
    ],
    18: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var title_buzz_1 = require("./buz/title.buzz");
        exports.writeCount = title_buzz_1.writeCount;
        var title_buzz_2 = require("./buz/title.buzz");
        exports.updatePath = title_buzz_2.updatePath;
        var title_buzz_3 = require("./buz/title.buzz");
        exports.resizeTitle = title_buzz_3.resizeTitle;
        var title_buzz_4 = require("./buz/title.buzz");
        exports.writeGamePad = title_buzz_4.writeGamePad;
      },
      { "./buz/title.buzz": 14 },
    ],
    19: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.PAD_VALUE = "title.padValue";
        exports.PATH = "title.path";
        exports.COMMAND = "title.command";
      },
      {},
    ],
    20: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        class TitleModel {
          constructor() {
            this.idx = "title";
            this.titleBit = { idx: "titleBit" };
            this.size = { width: 0, height: 0 };
            this.padValue = { idx: "", act: "" };
            this.path = null;
            this.count = 0; // utility for testing things
          }
        }
        exports.TitleModel = TitleModel;
      },
      {},
    ],
    21: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const clone = require("clone-deep");
        const Act = require("./title.action");
        const title_model_1 = require("./title.model");
        const Buzz = require("./title.buzzer");
        function reducer(model = new title_model_1.TitleModel(), act, state) {
          switch (act.type) {
            case Act.PAD_PRESS:
              return Buzz.writeGamePad(clone(model), act.bale);
            case Act.COUNT:
              return Buzz.writeCount(clone(model));
            case Act.UPDATE_PATH:
              return Buzz.updatePath(clone(model), act.bale);
            case Act.RESIZE:
              return Buzz.resizeTitle(clone(model), act.bale);
            default:
              return model;
          }
        }
        exports.reducer = reducer;
      },
      {
        "./title.action": 17,
        "./title.buzzer": 18,
        "./title.model": 20,
        "clone-deep": 51,
      },
    ],
    22: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const typescript_ioc_1 = require("typescript-ioc");
        const _00_routing_title_1 = require("./arc/00.routing.title");
        const line_1 = require("../line");
        const state_1 = require("../state");
        let TitleUnit = class TitleUnit {
          constructor(router, state) {
            this.routing = new _00_routing_title_1.default(router, state);
          }
        };
        TitleUnit = __decorate(
          [
            typescript_ioc_1.Singleton,
            __metadata("design:paramtypes", [line_1.default, state_1.default]),
          ],
          TitleUnit
        );
        exports.default = TitleUnit;
      },
      {
        "../line": 8,
        "../state": 9,
        "./arc/00.routing.title": 10,
        "typescript-ioc": 571,
      },
    ],
    23: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const rxjs_1 = require("rxjs");
        class Dispatcher extends rxjs_1.Subject {
          constructor() {
            super();
          }
          dispatch(value) {
            this.next(value);
          }
        }
        exports.Dispatcher = Dispatcher;
      },
      { rxjs: 333 },
    ],
    24: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const E = require("./00.core/constant/EVENT");
        var EventEmitter = require("events").EventEmitter;
        var sim = {
          wake: null,
          bee: null,
          event: new EventEmitter(),
          action: null,
        };
        sim.wake = (bee) => {
          //console.log("wake control " + bee);
          sim.event.emit(E.COMPLETE);
        };
        sim.action = (val) => {};
        module.exports = sim;
      },
      { "./00.core/constant/EVENT": 5, events: 56 },
    ],
    25: [
      function (require, module, exports) {
        (function (process) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          const B = require("./00.core/constant/BASIC");
          const HarkS = require("./01.effect.unit/effect.hark");
          const HikeS = require("./01.effect.unit/effect.hike");
          const electron_1 = require("electron");
          const FS = require("fs-extra");
          var sim = {
            wake: null,
            open: null,
            bee: null,
            process: null,
            response: null,
            project: null,
            iframe: null,
            terminal: null,
          };
          var sender;
          sim.wake = (bee) => {
            sim.bee = bee;
            if (electron_1.ipcMain != null)
              electron_1.ipcMain.on(B.UPDATE, sim.process);
            if (electron_1.ipcMain != null)
              electron_1.ipcMain.on(B.OPEN, sim.open);
            bee.hark(HarkS.IFRAME, sim.iframe);
            bee.hark(HarkS.PROJECT, sim.project);
            bee.hark(HarkS.TERMINAL, sim.terminal);
            if (FS.existsSync("./index/dat/song.json")) {
              var song = FS.readJSONSync("./index/dat/song.json");
              console.log("song " + JSON.stringify(song));
              if (song.pth != "" || song.mth != "") bee.song(song);
            } else {
              console.log("the song does not exist");
            }
          };
          sim.terminal = (val) => {
            if (val == null)
              return sim.bee.sing(HikeS.PROJECT, B.QUE, {
                idx: process.env.TERMINAL,
              });
            if (electron_1.BrowserWindow == null) return;
            electron_1.BrowserWindow.getAllWindows().forEach((a) => {
              if (val == "true") {
                console.log("ready for the terminal " + process.env.IFRAME);
                a.webContents.loadFile("./index/001.terminal.html");
                //setTimeout(() => {
                //  sim.iframe(process.env.IFRAME);
                //}, 333);
                //sim.bee.sing(HikeS.PROJECT, B.OPEN, { idx: process.env.IFRAME });
                if (process.env.DEBUG == "true") a.webContents.openDevTools();
                else a.removeMenu();
              } else {
                console.log("load me a project " + process.env.IFRAME);
                a.webContents.loadFile(
                  "./index/" + process.env.IFRAME + ".html"
                );
                if (process.env.DEBUG == "true") a.webContents.openDevTools();
                else a.removeMenu();
              }
            });
          };
          sim.iframe = (val) => {
            if (val == null) return;
            if (electron_1.BrowserWindow == null) return;
            var lst = electron_1.BrowserWindow.getAllWindows();
            lst.forEach((a) => a.webContents.send(B.OPEN, val));
          };
          sim.open = (event) => {
            console.log(B.OPEN + " === " + process.env.IFRAME);
            //  event.sender.send(B.OPEN);
          };
          //sim.project = (val: ProjectBit) => {
          //  console.log("project has been updated");
          //  if (val == null) return;
          //  sim.bee.sing(HikeS.INDEX, B.LIST, val);
          //};
          sim.response = (val) => {
            console.log("response from terminal " + JSON.stringify(val));
            if (val == null) return;
            var state = sim.bee.state;
            var sMod = state.value.effect;
            if (sMod.sender == null) throw new Error("no sender for response");
            //var sender = sMod.sender.src;
            //var pack = JSON.stringify(val);
            //console.log("sending response " + pack);
            //sender.send(B.UPDATE, pack);
            //ipcMain.send('hello','a string', 10);
          };
          sim.process = (event, args) => {
            if (args == null) return;
            var command = JSON.parse(args);
            console.log("command from terminal " + JSON.stringify(command));
            //sim.bee.sing(HikeS.COMMAND, B.UPDATE, { src: event.sender.send });
            sim.bee.sing(HikeS.COMMAND, B.WRITE, command);
            var dat = sim.bee.sing(command.act, command.vrb, command.dat);
            //this is for the upper terminal display to show a result
            var reply = JSON.stringify(dat);
            event.returnValue = reply;
            event.sender.send(B.UPDATE, reply);
          };
          //sim.command = (val: CommandBit) => {
          //  if (val != null) sim.bee.sing(val.act, val.vrb);
          //};
          module.exports = sim;
        }.call(this, require("_process")));
      },
      {
        "./00.core/constant/BASIC": 4,
        "./01.effect.unit/effect.hark": 36,
        "./01.effect.unit/effect.hike": 37,
        _process: 80,
        electron: undefined,
        "fs-extra": undefined,
      },
    ],
    26: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const _01_index_effect_arc_1 = require("./01.index.effect.arc");
        const _02_command_effect_arc_1 = require("./02.command.effect.arc");
        const _04_cohesion_effect_arc_1 = require("./04.cohesion.effect.arc");
        const _99_you_tube_effect_arc_1 = require("./99.you-tube.effect.arc");
        const _03_project_effect_arc_1 = require("./03.project.effect.arc");
        exports.root = "effect";
        exports.routes = [
          {
            path: "index",
            arcType: _01_index_effect_arc_1.default,
            arc: null,
          },
          {
            path: "project",
            arcType: _03_project_effect_arc_1.default,
            arc: null,
          },
          {
            path: "command",
            arcType: _02_command_effect_arc_1.default,
            arc: null,
          },
          {
            path: "cohesion",
            arcType: _04_cohesion_effect_arc_1.default,
            arc: null,
          },
          {
            path: "tube",
            arcType: _99_you_tube_effect_arc_1.default,
            arc: null,
          },
        ];
        class DisplayRoutingUnit {
          constructor(router, state) {
            exports.routes.forEach((a) => {
              a.path = exports.root + "/" + a.path;
              a.arc = new a.arcType(state);
              router.register(a);
            });
          }
        }
        exports.default = DisplayRoutingUnit;
      },
      {
        "./01.index.effect.arc": 27,
        "./02.command.effect.arc": 28,
        "./03.project.effect.arc": 29,
        "./04.cohesion.effect.arc": 30,
        "./99.you-tube.effect.arc": 31,
      },
    ],
    27: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const arc_form_1 = require("../../00.core/form/arc.form");
        const path_process_1 = require("../../00.core/title/prc/path.process");
        const typescript_ioc_1 = require("typescript-ioc");
        const Act = require("../effect.action");
        const line_count_process_1 = require("../prc/line-count.process");
        const word_count_process_1 = require("../prc/word-count.process");
        const unit_process_1 = require("../prc/unit.process");
        const bee_process_1 = require("../prc/bee.process");
        class IndexSupportArc extends arc_form_1.default {
          constructor(state) {
            super(state);
            this.state = state;
            this.read = () => {
              return this.lineCount.read();
            };
            this.list = (dat) => {
              dat = this.wordCount.count(dat);
            };
            this.write = (dat) => {
              dat = this.lineCount.count(dat);
              this.path.move(this.state, Act.WRITE_LINE_COUNT, dat);
              return dat;
            };
            this.create = (dat) => this.unit.create(dat.idx);
            this.copy = (dat) => this.unit.copy();
            this.update = (dat) => this.bee.update(dat.idx);
            this.replace = (dat) => this.unit.replace();
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          IndexSupportArc.prototype,
          "path",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", line_count_process_1.default),
          ],
          IndexSupportArc.prototype,
          "lineCount",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", word_count_process_1.default),
          ],
          IndexSupportArc.prototype,
          "wordCount",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", bee_process_1.default),
          ],
          IndexSupportArc.prototype,
          "bee",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", unit_process_1.default),
          ],
          IndexSupportArc.prototype,
          "unit",
          void 0
        );
        exports.default = IndexSupportArc;
      },
      {
        "../../00.core/form/arc.form": 6,
        "../../00.core/title/prc/path.process": 15,
        "../effect.action": 34,
        "../prc/bee.process": 41,
        "../prc/line-count.process": 43,
        "../prc/unit.process": 44,
        "../prc/word-count.process": 45,
        "typescript-ioc": 571,
      },
    ],
    28: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const arc_form_1 = require("../../00.core/form/arc.form");
        const path_process_1 = require("../../00.core/title/prc/path.process");
        const typescript_ioc_1 = require("typescript-ioc");
        const Act = require("../effect.action");
        const line_count_process_1 = require("../prc/line-count.process");
        class IndexSupportArc extends arc_form_1.default {
          constructor(state) {
            super(state);
            this.state = state;
            this.write = (dat) =>
              this.path.move(this.state, Act.WRITE_COMMAND, dat);
            this.update = (dat) =>
              this.path.move(this.state, Act.WRITE_SENDER, dat);
            this.delete = (dat) => {};
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          IndexSupportArc.prototype,
          "path",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", line_count_process_1.default),
          ],
          IndexSupportArc.prototype,
          "lineCount",
          void 0
        );
        exports.default = IndexSupportArc;
      },
      {
        "../../00.core/form/arc.form": 6,
        "../../00.core/title/prc/path.process": 15,
        "../effect.action": 34,
        "../prc/line-count.process": 43,
        "typescript-ioc": 571,
      },
    ],
    29: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const arc_form_1 = require("../../00.core/form/arc.form");
        const path_process_1 = require("../../00.core/title/prc/path.process");
        const typescript_ioc_1 = require("typescript-ioc");
        class ProjectSupportArc extends arc_form_1.default {
          constructor(state) {
            super(state);
            this.state = state;
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          ProjectSupportArc.prototype,
          "path",
          void 0
        );
        exports.default = ProjectSupportArc;
      },
      {
        "../../00.core/form/arc.form": 6,
        "../../00.core/title/prc/path.process": 15,
        "typescript-ioc": 571,
      },
    ],
    30: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const arc_form_1 = require("../../00.core/form/arc.form");
        const path_process_1 = require("../../00.core/title/prc/path.process");
        const cohesion_process_1 = require("../prc/cohesion.process");
        const typescript_ioc_1 = require("typescript-ioc");
        class CohesionArc extends arc_form_1.default {
          constructor(state) {
            super(state);
            this.state = state;
            this.write = (dat) => this.cohesion.publish(dat.idx);
            this.update = (dat) => this.cohesion.update(dat.idx);
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          CohesionArc.prototype,
          "path",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", cohesion_process_1.default),
          ],
          CohesionArc.prototype,
          "cohesion",
          void 0
        );
        exports.default = CohesionArc;
      },
      {
        "../../00.core/form/arc.form": 6,
        "../../00.core/title/prc/path.process": 15,
        "../prc/cohesion.process": 42,
        "typescript-ioc": 571,
      },
    ],
    31: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const arc_form_1 = require("../../00.core/form/arc.form");
        const path_process_1 = require("../../00.core/title/prc/path.process");
        const typescript_ioc_1 = require("typescript-ioc");
        const you_tube_process_1 = require("../prc/you-tube.process");
        class YoutubeSupportArc extends arc_form_1.default {
          constructor(state) {
            super(state);
            this.state = state;
            this.write = (dat) => this.tube.create("../../");
            this.delete = (dat) => {};
          }
        }
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", path_process_1.default),
          ],
          YoutubeSupportArc.prototype,
          "path",
          void 0
        );
        __decorate(
          [
            typescript_ioc_1.Inject,
            __metadata("design:type", you_tube_process_1.default),
          ],
          YoutubeSupportArc.prototype,
          "tube",
          void 0
        );
        exports.default = YoutubeSupportArc;
      },
      {
        "../../00.core/form/arc.form": 6,
        "../../00.core/title/prc/path.process": 15,
        "../prc/you-tube.process": 46,
        "typescript-ioc": 571,
      },
    ],
    32: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const Act = require("../effect.action");
        const Moment = require("moment");
        exports.writeSender = (cpy, bal) => {
          delete cpy.sender;
          cpy.sender = bal;
          cpy.sender.idx = Moment().valueOf();
          return cpy;
        };
        exports.writeCommand = (cpy, bal) => {
          delete cpy.command;
          cpy.command = bal;
          cpy.command.idx = Moment().valueOf();
          return cpy;
        };
        exports.writeResponse = (cpy, bal) => {
          delete cpy.response;
          cpy.response = bal;
          cpy.response.idx = Moment().valueOf();
          return cpy;
        };
        exports.writeLineCount = (cpy, bal, ste) => {
          cpy.lineCount = bal;
          console.log("sending out a  response " + JSON.stringify(cpy));
          ste.dispatch({
            type: Act.WRITE_RESPONSE,
            bale: { dat: cpy.lineCount },
          });
          return cpy;
        };
        exports.writeSupport = (cpy, bal, ste) => {
          return cpy;
        };
      },
      { "../effect.action": 34, moment: 77 },
    ],
    33: [
      function (require, module, exports) {
        (function (process) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          const writeFileAtomic = require("write-file-atomic");
          const electron_1 = require("electron");
          exports.openProject = (cpy, bal) => {
            cpy.iframe = bal.idx;
            return cpy;
          };
          exports.queTerminal = (cpy, bal) => {
            if (bal.idx == cpy.terminal) return;
            if (cpy.terminal == null) {
              cpy.terminal = bal.idx;
              console.log("you are updating term " + cpy.terminal);
              return cpy;
            }
            console.log("pweeze show me the terminal " + cpy.terminal);
            var value = cpy.terminal;
            if (value == "false") value = "true";
            else if (value == "true") value = "false";
            var config = require("dotenv").config();
            var file = "";
            for (var key in config.parsed) {
              var line;
              if (key == "TERMINAL") line = key + "=" + value;
              else line = key + "=" + config.parsed[key]; //super important
              file += line + "\n";
            }
            //writeFileAtomic.sync("./.env", file);
            cpy.terminal = value;
            return cpy;
          };
          exports.updateProject = (cpy, bal) => {
            var config = require("dotenv").config();
            var file = "";
            for (var key in config.parsed) {
              var line;
              if (key == "IFRAME") {
                line = key + "=" + bal.idx;
              } else line = key + "=" + config.parsed[key]; //super important
              file += line + "\n";
            }
            writeFileAtomic.sync("./.env", file);
            cpy.iframe = bal.idx;
            return cpy;
            //delete cpy.project;
            //cpy.project = bal;
            //process.nextTick(() => {
            // app.exit();
            //});
          };
          exports.writeProject = (cpy, bal) => {
            var config = require("dotenv").config();
            var file = "";
            for (var key in config.parsed) {
              var line;
              if (key == "COMPILE") {
                line = key + "=" + bal.idx;
              } else line = key + "=" + config.parsed[key]; //super important
              file += line + "\n";
            }
            writeFileAtomic.sync("./.env", file);
            delete cpy.project;
            cpy.project = bal;
            process.nextTick(() => {
              electron_1.app.exit();
            });
          };
        }.call(this, require("_process")));
      },
      {
        _process: 80,
        dotenv: 55,
        electron: undefined,
        "write-file-atomic": undefined,
      },
    ],
    34: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.QUE_TERMINAL = "[title action] Delete Terminal";
        class QueTerminal {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.QUE_TERMINAL;
          }
        }
        exports.QueTerminal = QueTerminal;
        exports.OPEN_PROJECT = "[title action] Open Project";
        class OpenProject {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.OPEN_PROJECT;
          }
        }
        exports.OpenProject = OpenProject;
        exports.UPDATE_PROJECT = "[title action] Update Project";
        class UpdateProject {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.UPDATE_PROJECT;
          }
        }
        exports.UpdateProject = UpdateProject;
        exports.WRITE_PROJECT = "[title action] Write Project";
        class WriteProject {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.WRITE_PROJECT;
          }
        }
        exports.WriteProject = WriteProject;
        exports.WRITE_SENDER = "[title action] Write Sender";
        class WriteSender {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.WRITE_SENDER;
          }
        }
        exports.WriteSender = WriteSender;
        exports.WRITE_RESPONSE = "[title action] Write Response";
        class WriteResponse {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.WRITE_RESPONSE;
          }
        }
        exports.WriteResponse = WriteResponse;
        exports.WRITE_COMMAND = "[title action] Write Command";
        class WriteCommand {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.WRITE_COMMAND;
          }
        }
        exports.WriteCommand = WriteCommand;
        exports.WRITE_LINE_COUNT = "[Effect action] Write Line Count";
        class WriteLineCount {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.WRITE_LINE_COUNT;
          }
        }
        exports.WriteLineCount = WriteLineCount;
        exports.SUPPORT_OPEN = "[Effect action] Waking Effect";
        class Effect {
          constructor(bale) {
            this.bale = bale;
            this.type = exports.SUPPORT_OPEN;
          }
        }
        exports.Effect = Effect;
      },
      {},
    ],
    35: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var effect_buzz_1 = require("./buz/effect.buzz");
        exports.writeSupport = effect_buzz_1.writeSupport;
        var effect_buzz_2 = require("./buz/effect.buzz");
        exports.writeLineCount = effect_buzz_2.writeLineCount;
        var effect_buzz_3 = require("./buz/effect.buzz");
        exports.writeCommand = effect_buzz_3.writeCommand;
        var effect_buzz_4 = require("./buz/effect.buzz");
        exports.writeResponse = effect_buzz_4.writeResponse;
        var effect_buzz_5 = require("./buz/effect.buzz");
        exports.writeSender = effect_buzz_5.writeSender;
        var project_buzz_1 = require("./buz/project.buzz");
        exports.writeProject = project_buzz_1.writeProject;
        var project_buzz_2 = require("./buz/project.buzz");
        exports.updateProject = project_buzz_2.updateProject;
        var project_buzz_3 = require("./buz/project.buzz");
        exports.openProject = project_buzz_3.openProject;
        var project_buzz_4 = require("./buz/project.buzz");
        exports.queTerminal = project_buzz_4.queTerminal;
      },
      { "./buz/effect.buzz": 32, "./buz/project.buzz": 33 },
    ],
    36: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.LINE_COUNT = "effect.lineCount";
        exports.RESPONSE = "effect.response";
        exports.PROJECT = "effect.project";
        exports.IFRAME = "effect.iframe";
        exports.TERMINAL = "effect.terminal";
      },
      {},
    ],
    37: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.INDEX = "effect/index";
        exports.COMMAND = "effect/command";
        exports.PROJECT = "effect/project";
      },
      {},
    ],
    38: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        class EffectModel {
          constructor() {
            this.iframe = "";
          }
        }
        exports.EffectModel = EffectModel;
      },
      {},
    ],
    39: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const clone = require("clone-deep");
        const Act = require("./effect.action");
        const effect_model_1 = require("./effect.model");
        const Buzz = require("./effect.buzzer");
        function reducer(model = new effect_model_1.EffectModel(), act, state) {
          switch (act.type) {
            case Act.WRITE_LINE_COUNT:
              return Buzz.writeLineCount(clone(model), act.bale, state);
            case Act.SUPPORT_OPEN:
              return Buzz.writeSupport(clone(model), act.bale, state);
            case Act.WRITE_COMMAND:
              return Buzz.writeCommand(clone(model), act.bale);
            case Act.WRITE_RESPONSE:
              return Buzz.writeResponse(clone(model), act.bale);
            case Act.WRITE_SENDER:
              return Buzz.writeSender(clone(model), act.bale);
            case Act.WRITE_PROJECT:
              return Buzz.writeProject(clone(model), act.bale);
            case Act.OPEN_PROJECT:
              return Buzz.openProject(clone(model), act.bale);
            case Act.UPDATE_PROJECT:
              return Buzz.updateProject(clone(model), act.bale);
            case Act.QUE_TERMINAL:
              return Buzz.queTerminal(clone(model), act.bale);
            default:
              return model;
          }
        }
        exports.reducer = reducer;
      },
      {
        "./effect.action": 34,
        "./effect.buzzer": 35,
        "./effect.model": 38,
        "clone-deep": 51,
      },
    ],
    40: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const typescript_ioc_1 = require("typescript-ioc");
        const _00_routing_effect_1 = require("./arc/00.routing.effect");
        const line_1 = require("../00.core/line");
        const state_1 = require("../00.core/state");
        let SupportUnit = class SupportUnit {
          constructor(router, state) {
            //console.log("construnct sim unit " + this.router);
            this.routing = new _00_routing_effect_1.default(router, state);
          }
        };
        SupportUnit = __decorate(
          [
            typescript_ioc_1.Singleton,
            __metadata("design:paramtypes", [line_1.default, state_1.default]),
          ],
          SupportUnit
        );
        exports.default = SupportUnit;
      },
      {
        "../00.core/line": 8,
        "../00.core/state": 9,
        "./arc/00.routing.effect": 26,
        "typescript-ioc": 571,
      },
    ],
    41: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const typescript_ioc_1 = require("typescript-ioc");
        const FS = require("fs-extra");
        const doT = require("dot");
        const S = require("string");
        let BeeProcess = class BeeProcess {
          constructor() {
            this.file = "./data/redux/BEE.txt";
            this.fileFin = "./data/redux/BEE.ts";
            this.update = (title) => {
              console.log("please fire the update " + title);
              function capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
              }
              var list = FS.readdirSync("./" + title);
              var lineList = FS.readFileSync(this.file).toString().split("\n");
              var out = [];
              var dirList = [];
              var itemList = [];
              list.forEach((a, b) => {
                list[b] = "./" + title + "/" + a;
                if (FS.lstatSync(list[b]).isDirectory()) {
                  if (S(list[b]).contains("unit") == false) return;
                  var directory = list[b] + "/";
                  var element = a.split(".")[1];
                  console.log("updating " + element);
                  var unitName = capitalizeFirstLetter(element);
                  var unitImportSrc = "./" + a + "/" + element + ".unit";
                  var unitImportSte =
                    "import " + unitName + 'Unit from "' + unitImportSrc + '";';
                  var faceImportSrc =
                    "./" + a + "/fce/" + element + ".interface";
                  var faceImportSte =
                    "import " + unitName + ' from "' + faceImportSrc + '";';
                  var modlImportSrc = "./" + a + "/" + element + ".model";
                  var modlImportSte =
                    "import { " +
                    unitName +
                    'Model } from "' +
                    modlImportSrc +
                    '";';
                  var redcImportSrc = "./" + a + "/" + element + ".reduce";
                  var redcImportSte =
                    "import * as reduceFrom" +
                    unitName +
                    ' from "' +
                    redcImportSrc +
                    '";';
                  var reduced =
                    element + " : reduceFrom" + unitName + ".reducer";
                  var model =
                    element +
                    " : " +
                    unitName +
                    " = new " +
                    unitName +
                    "Model();";
                  var item = {
                    model,
                    reduced,
                    redcI: redcImportSte,
                    modlI: modlImportSte,
                    facI: faceImportSte,
                    untI: unitImportSte,
                    unitName,
                    element,
                  };
                  itemList.push(item);
                }
              });
              var unitImports = "";
              itemList.forEach((a) => {
                unitImports += a.untI + "\n";
              });
              var faceImports = "";
              itemList.forEach((a) => {
                faceImports += a.facI + "\n";
                faceImports += a.modlI + "\n";
              });
              var unitListNom = ["TitleUnit"];
              itemList.forEach((a) => {
                unitListNom.push(a.unitName + "Unit");
              });
              var unitList = JSON.stringify(unitListNom) + ";";
              unitList = S(unitList).replaceAll('"', "");
              var reduceImports = "";
              itemList.forEach((a) => {
                reduceImports += a.redcI + "\n";
              });
              var reduceList = "";
              itemList.forEach((a, b) => {
                //if (b == reduceList.length - 1) return;
                reduceList += a.reduced + ", \n";
              });
              //reduceList += itemList[itemList.length - 1].reduced + "\n";
              var modelList = "";
              itemList.forEach((a, b) => {
                modelList += a.model + "\n";
              });
              var gel = {
                unitImports,
                faceImports,
                unitList,
                reduceImports,
                reduceList,
                modelList,
              };
              var writeLine = [];
              lineList.forEach((a, b) => {
                console.log("line " + a);
                if (S(a).contains("//")) return;
                var doTCompiled = doT.template(a);
                var outLine = doTCompiled(gel);
                writeLine.push(outLine);
              });
              writeLine.forEach((a) => {
                console.log("line : " + a);
              });
              var finFile = writeLine.join("\n");
              FS.ensureFileSync(this.fileFin);
              FS.writeFileSync(this.fileFin, finFile);
              console.log("writing " + this.fileFin);
            };
          }
        };
        BeeProcess = __decorate(
          [typescript_ioc_1.Singleton, __metadata("design:paramtypes", [])],
          BeeProcess
        );
        exports.default = BeeProcess;
      },
      { dot: 54, "fs-extra": undefined, string: 560, "typescript-ioc": 571 },
    ],
    42: [
      function (require, module, exports) {
        (function (__dirname) {
          "use strict";
          var __decorate =
            (this && this.__decorate) ||
            function (decorators, target, key, desc) {
              var c = arguments.length,
                r =
                  c < 3
                    ? target
                    : desc === null
                    ? (desc = Object.getOwnPropertyDescriptor(target, key))
                    : desc,
                d;
              if (
                typeof Reflect === "object" &&
                typeof Reflect.decorate === "function"
              )
                r = Reflect.decorate(decorators, target, key, desc);
              else
                for (var i = decorators.length - 1; i >= 0; i--)
                  if ((d = decorators[i]))
                    r =
                      (c < 3
                        ? d(r)
                        : c > 3
                        ? d(target, key, r)
                        : d(target, key)) || r;
              return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
          var __metadata =
            (this && this.__metadata) ||
            function (k, v) {
              if (
                typeof Reflect === "object" &&
                typeof Reflect.metadata === "function"
              )
                return Reflect.metadata(k, v);
            };
          Object.defineProperty(exports, "__esModule", { value: true });
          const typescript_ioc_1 = require("typescript-ioc");
          const FS = require("fs-extra");
          const doT = require("dot");
          const S = require("string");
          let IntentionProcess = class IntentionProcess {
            constructor() {
              this.file = "./data/redux/BEE.txt";
              this.fileFin = "./data/redux/BEE.ts";
              this.pubRoot = "../pub/";
              this.update = (dir) => {
                if (dir == null)
                  return console.log("no directory for update " + dir);
                var lst = FS.readFileSync(
                  "./000.main/01.effect.unit/dat/vrt.dpy.bat"
                )
                  .toString()
                  .split("\n");
                lst.forEach((a, b) => {
                  var temp = doT.template(a);
                  var line = temp({ cohesion: dir });
                  lst[b] = line;
                });
                FS.ensureFileSync(__dirname + "/batch/vrt.dpy.bat");
                FS.writeFileSync(
                  __dirname + "/batch/vrt.dpy.bat",
                  lst.join("\n")
                );
                var child_process = require("child_process");
                child_process.exec(__dirname + "/batch/vrt.dpy.bat", function (
                  error,
                  stdout,
                  stderr
                ) {
                  console.log(error);
                  console.log(stdout);
                  console.log(stderr);
                });
              };
              this.publish = (dir) => {
                console.log("publish cohesion " + dir);
                if (dir == null) return;
                var copyList = [];
                var root = "../" + dir;
                if (FS.existsSync(root) == false) return;
                var intentList = FS.readdirSync(root + "/index");
                intentList.forEach((a, b) => {
                  var datItem = {
                    src: root + "/index/" + a,
                    fin: this.pubRoot + dir + "/" + a,
                  };
                  intentList[b] = datItem;
                });
                intentList.forEach((a) => {
                  //console.log("check " + a);
                  if (FS.lstatSync(a.src).isDirectory() == true) return;
                  if (S(a.src).contains(".js") == false) return;
                  copyList.push(a);
                  //console.log("copy " + a);
                });
                copyList.forEach((a) => {
                  console.log("copy me " + a.src);
                  console.log("fin me " + a.fin);
                  FS.ensureFileSync(a.fin);
                  FS.copy(a.src, a.fin, () => {
                    console.log("copy complete " + a.fin);
                  });
                });
              };
            }
          };
          IntentionProcess = __decorate(
            [typescript_ioc_1.Singleton, __metadata("design:paramtypes", [])],
            IntentionProcess
          );
          exports.default = IntentionProcess;
        }.call(this, "/dist/000.main/01.effect.unit/prc"));
      },
      {
        child_process: undefined,
        dot: 54,
        "fs-extra": undefined,
        string: 560,
        "typescript-ioc": 571,
      },
    ],
    43: [
      function (require, module, exports) {
        (function (process) {
          "use strict";
          var __decorate =
            (this && this.__decorate) ||
            function (decorators, target, key, desc) {
              var c = arguments.length,
                r =
                  c < 3
                    ? target
                    : desc === null
                    ? (desc = Object.getOwnPropertyDescriptor(target, key))
                    : desc,
                d;
              if (
                typeof Reflect === "object" &&
                typeof Reflect.decorate === "function"
              )
                r = Reflect.decorate(decorators, target, key, desc);
              else
                for (var i = decorators.length - 1; i >= 0; i--)
                  if ((d = decorators[i]))
                    r =
                      (c < 3
                        ? d(r)
                        : c > 3
                        ? d(target, key, r)
                        : d(target, key)) || r;
              return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
          var __metadata =
            (this && this.__metadata) ||
            function (k, v) {
              if (
                typeof Reflect === "object" &&
                typeof Reflect.metadata === "function"
              )
                return Reflect.metadata(k, v);
            };
          Object.defineProperty(exports, "__esModule", { value: true });
          const typescript_ioc_1 = require("typescript-ioc");
          const FS = require("fs-extra");
          const glob = require("fast-glob");
          const underscore_string_1 = require("underscore.string");
          const Moment = require("moment");
          const doT = require("dot");
          const Twitter = require("twitter");
          const open = require("open");
          const S = require("string");
          let LineCountProcess = class LineCountProcess {
            constructor() {
              this.loc = "./data/";
              this.srcLoc = "";
              this.src0 = "./000.main/**/*.ts";
              this.src1 = "./000.terminal/**/*.ts";
              this.src2 = "./001.polygon/**/*.ts";
              this.extra = ["./main.js", "./comp.js", "terminal.js"];
              this.read = () => {
                this.srcLoc = this.loc + "/log/line-count.txt";
                var text = FS.readFileSync(this.srcLoc).toString().split("\n");
                var dat = { lst: text.splice(0, 3) };
                return dat;
              };
              this.count = (dat) => {
                require("dotenv").config();
                var msg = dat.msg;
                this.srcLoc = this.loc + "/log/line-count.txt";
                var cohesion = [];
                var masterList = FS.readdirSync("../");
                masterList.forEach((z) => {
                  if (z.split(".").length != 2) return;
                  var dom = z.split(".")[0];
                  if (dom.length > 3) return;
                  cohesion.push(z);
                });
                var allList = [];
                cohesion.forEach((x) => {
                  var dirList = FS.readdirSync("../" + x);
                  var recList = dirList.filter((i) => {
                    var item = i.split(".");
                    if (item.length == 2 && item[0].length == 3) {
                      return i;
                    }
                  });
                  var itemList = [];
                  recList.forEach((c) => {
                    var item = { cohesion: x, intent: c };
                    itemList.push(item);
                  });
                  allList = allList.concat(itemList);
                });
                var intents = {};
                var finList = [];
                allList.forEach((a) => {
                  if (intents[a.intent] != null) return;
                  intents[a.intent] = 0;
                  finList.push(a);
                  console.log("check: " + JSON.stringify(a));
                });
                var unitList = [];
                var extraList = [];
                finList.forEach((a) => {
                  var itemList = FS.readdirSync(
                    "../" + a.cohesion + "/" + a.intent
                  );
                  itemList.forEach((b) => {
                    if (underscore_string_1.include(b, ".json")) return;
                    var point = "../" + a.cohesion + "/" + a.intent + "/" + b;
                    var gather = point + "/**/*.ts";
                    if (FS.lstatSync(point).isDirectory() == true)
                      unitList.push(gather);
                    else extraList.push(point);
                  });
                });
                this.extra = this.extra.concat(extraList);
                var coreUnit;
                unitList = unitList.filter((i) => {
                  if (S(i).contains("00.core") == false) return i;
                  coreUnit = i;
                });
                //allList.forEach((a, b) => {
                //  allList[b] = "./" + a + "/**/*.ts";
                //});
                //unitList.forEach((a) => {
                //  console.log("variation " + a);
                //});
                unitList.push(coreUnit);
                console.log("core unit " + coreUnit);
                var list = glob.sync(unitList, { dot: true });
                list.forEach((a, b) => (list[b] = "./" + a));
                this.extra.forEach((a) => list.push(a));
                var lines = [];
                var end = [];
                list.forEach((a, b) => {
                  console.log("file:: " + a);
                  var file = FS.readFileSync(a).toString().split("\n");
                  lines = lines.concat(file);
                });
                console.log("file count:: " + list.length);
                console.log("line count:: " + lines.length);
                lines.forEach((a, b) => {
                  if (underscore_string_1.include(a, "//")) return;
                  lines[b] = "";
                });
                lines.forEach(
                  (a, b) => (lines[b] = underscore_string_1.slugify(a))
                );
                lines.forEach((a, b) => {
                  if (underscore_string_1.isBlank(a)) return;
                  end.push(a);
                  // console.log(b + " ::: " + a);
                });
                var wordList = [];
                lines.forEach((a) => {
                  var dash = a.split("-");
                  wordList = wordList.concat(dash);
                });
                var words = {};
                wordList.forEach((a) => {
                  if (words[a] != null) words[a] += 1;
                  words[a] = 0;
                });
                var snowflake = [];
                for (var key in words) {
                  snowflake.push({ key: key, count: words[key] });
                }
                FS.ensureDirSync(this.loc + "/log/");
                FS.ensureFileSync(this.loc + "/log/line-count.txt");
                var text = FS.readFileSync(this.srcLoc).toString().split("\n");
                var saves = text.length - 1;
                var wordStr = String(wordList.length).padStart(5, "0");
                var lineStr = String(lines.length).padStart(5, "0");
                var snowflakeStr = String(snowflake.length).padStart(4, "0");
                var fileStr = String(list.length).padStart(4, "0");
                var logID = String(saves).padStart(4, "0");
                var log =
                  lineStr + ":" + wordStr + ":" + snowflakeStr + ":" + fileStr;
                var timeA = Moment().format("h:mm:ss");
                var padTime = timeA.split(":");
                var timeB = Moment().format("MMMM Do dddd a YYYY");
                var time = String(padTime[0]).padStart(2, "0") + ":";
                time += String(padTime[1]).padStart(2, "0") + ":";
                time += String(padTime[2]).padStart(2, "0");
                time += " " + timeB;
                var element = log + "_" + time;
                var compare = text[0].split("_")[1];
                var final = logID + "_" + element;
                if (msg != null) final += " : " + msg;
                if (msg != null) {
                  var commitMessage =
                    'git add -A && git commit -m "{{=it.cmtMsg}}"';
                  var temp = doT.template(commitMessage);
                  var line = temp({ cmtMsg: msg });
                  const exec = require("child_process").exec;
                  exec(line, (error, stdout, stderr) => {
                    if (error) {
                      console.error(`exec error: ${error}`);
                      return;
                    }
                    // console.log(`stdout: ${stdout}`);
                    // console.log(`stderr: ${stderr}`);
                    // console.log("------ ");
                    //console.log("now " + final);
                    // console.log("----- ");
                  });
                }
                text.unshift(final);
                if (compare != log) {
                  var out = text.join("\n");
                  FS.writeFileSync(this.srcLoc, out);
                  //console.log("writing " + this.srcLoc);
                  const screenshot = require("screenshot-desktop");
                  var cnt = FS.readdirSync("./data/screenshot").length;
                  var screenCount = String(cnt).padStart(5, "0");
                  var screenNom = "./data/screenshot/" + screenCount + ".png";
                  screenshot({ filename: screenNom }).then((imgPath) => {
                    var data = FS.readFileSync(screenNom);
                    //console.log("wrote the screenshot " + screenNom);
                    //console.log("now tweet the screenshot !!!");
                    var client = new Twitter({
                      consumer_key: process.env.TWITTER_CONSUMER_KEY,
                      consumer_secret: process.env.TWITTER_CONSUMER_SECRET,
                      access_token_key: process.env.TWITTER_ACCESS_TOKEN_KEY,
                      access_token_secret:
                        process.env.TWITTER_ACCESS_TOKEN_SECRET,
                    });
                    final += " #IndieWorldOrder";
                    client.post("media/upload", { media: data }, function (
                      error,
                      media,
                      response
                    ) {
                      if (!error) {
                        // If successful, a media object will be returned.
                        //console.log(media);
                        client
                          .post("statuses/update", {
                            status: final,
                            media_ids: media.media_id_string,
                          })
                          .then(function (tweet) {
                            console.log("tweet successful " + lineStr);
                            open("https://twitter.com/perfectbeeing");
                            //console.log(tweet);
                          })
                          .catch(function (error) {
                            console.log("tweet error " + JSON.stringify(error));
                            throw error;
                          });
                      } else {
                        console.log("twitter error " + JSON.stringify(error));
                      }
                    });
                  });
                }
                dat.lst = text.splice(0, 3);
                return dat;
              };
            }
          };
          LineCountProcess = __decorate(
            [typescript_ioc_1.Singleton, __metadata("design:paramtypes", [])],
            LineCountProcess
          );
          exports.default = LineCountProcess;
        }.call(this, require("_process")));
      },
      {
        _process: 80,
        child_process: undefined,
        dot: 54,
        dotenv: 55,
        "fast-glob": undefined,
        "fs-extra": undefined,
        moment: 77,
        open: undefined,
        "screenshot-desktop": undefined,
        string: 560,
        twitter: undefined,
        "typescript-ioc": 571,
        "underscore.string": 596,
      },
    ],
    44: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const typescript_ioc_1 = require("typescript-ioc");
        const FS = require("fs-extra");
        const doT = require("dot");
        const S = require("string");
        let UnitProcess = class UnitProcess {
          constructor() {
            this.loc = "./data/redux/00.sim.unit/";
            this.replace = () => {
              var srcDir = "./000.main";
              var srcComp = "./comp.js";
              var srcTerminal = "./terminal.js";
              var list = FS.readdirSync("../");
              var outList = [];
              list.forEach((a, b) => {
                //if (b == 0) return;
                if (FS.lstatSync("../" + a).isDirectory() == false) return;
                if (S(a).contains(".") == false) return;
                var items = a.split(".");
                if (items[0].length != 3) return;
                outList.push(a);
                console.log("dirs " + a);
              });
              var path = require("path");
              var now = path.basename(path.dirname(require.main.filename));
              //var rePath = now.replace(/.+\//, "");
              outList.forEach((a) => {
                if (a == now) return;
                var fin = "../" + a + "/000.main";
                var compFin = "../" + a + "/comp.js";
                var terminalFin = "../" + a + "/terminal.js";
                FS.copySync(srcComp, compFin);
                FS.copySync(srcTerminal, terminalFin);
                FS.copy(srcDir, fin, () => {
                  console.log("replaced " + compFin);
                  console.log("replaced " + terminalFin);
                  console.log("replaced with 000.main " + fin);
                });
              });
              console.log("now " + now);
            };
            this.copy = () => {
              var dirList = FS.readdirSync("./");
              var recList = dirList.filter((i) => {
                var item = i.split(".");
                if (item.length == 2 && item[0].length == 3) {
                  return i;
                }
              });
              var src = "./" + recList.shift() + "/00.core";
              recList.forEach((a) => {
                var end = "./" + a + "/00.core";
                FS.copy(src, end, () => console.log("copy complete " + end));
              });
            };
            this.create = (title) => {
              if (title.split(".").length != 2) title = "00." + title;
              var num = title.split(".")[0];
              var nom = title.split(".")[1];
              console.log("nom " + nom);
              var file = this.loc;
              var list = FS.readdirSync(file);
              var out = [];
              list.forEach((a, b) => {
                list[b] = file + "/" + a;
                if (FS.lstatSync(list[b]).isDirectory()) {
                  var directory = list[b];
                  var listB = FS.readdirSync(directory);
                  listB.forEach((c) => out.push(directory + "/" + c));
                } else {
                  out.push(list[b]);
                }
              });
              if (nom == null) nom = "beeing";
              function capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
              }
              var gel = {
                idx: "together000",
                title: capitalizeFirstLetter(nom),
                nom: nom,
                wakeActionKey: nom.toUpperCase() + "_OPEN",
                wakeActionFunction: capitalizeFirstLetter(nom),
                bitNom: nom + "Bit",
                bitTitle: capitalizeFirstLetter(nom) + "Bit",
                actionLabel: capitalizeFirstLetter(nom),
                actionTitle: "Waking " + capitalizeFirstLetter(nom),
              };
              out.forEach((a) => {
                var neo = a.replace("sim", gel.nom);
                neo = neo.replace(".sim", "." + gel.nom);
                console.log("neo " + neo);
                var lineList = FS.readFileSync(a).toString().split("\n");
                lineList.forEach((a, b) => {
                  console.log("line " + a);
                  var doTCompiled = doT.template(a);
                  var outLine = doTCompiled(gel);
                  lineList[b] = outLine;
                });
                lineList.forEach((a) => {
                  console.log("line : " + a);
                });
                var finFin = neo.replace("sim", gel.nom);
                console.log("what you got for a fin fin " + finFin);
                finFin = finFin.replace(
                  "../data/redux/",
                  "../data/redux/unit/"
                );
                finFin = finFin.replace("00", num);
                finFin = finFin.replace(".txt", ".ts");
                var finFile = lineList.join("\n");
                FS.ensureFileSync(finFin);
                FS.writeFileSync(finFin, finFile);
                console.log("writing " + finFin);
              });
              console.log("how many files " + list.length);
              console.log("you are in ..  " + list.length);
            };
          }
        };
        UnitProcess = __decorate(
          [typescript_ioc_1.Singleton, __metadata("design:paramtypes", [])],
          UnitProcess
        );
        exports.default = UnitProcess;
      },
      {
        dot: 54,
        "fs-extra": undefined,
        path: 78,
        string: 560,
        "typescript-ioc": 571,
      },
    ],
    45: [
      function (require, module, exports) {
        "use strict";
        var __decorate =
          (this && this.__decorate) ||
          function (decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d;
            if (
              typeof Reflect === "object" &&
              typeof Reflect.decorate === "function"
            )
              r = Reflect.decorate(decorators, target, key, desc);
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          };
        var __metadata =
          (this && this.__metadata) ||
          function (k, v) {
            if (
              typeof Reflect === "object" &&
              typeof Reflect.metadata === "function"
            )
              return Reflect.metadata(k, v);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const typescript_ioc_1 = require("typescript-ioc");
        const FS = require("fs-extra");
        const glob = require("fast-glob");
        const underscore_string_1 = require("underscore.string");
        const Moment = require("moment");
        let LineCountProcess = class LineCountProcess {
          constructor() {
            this.loc = "./data/";
            this.srcLoc = "";
            this.src0 = "./000.main/**/*.ts";
            this.src1 = "./000.terminal/**/*.ts";
            this.src2 = "./001.polygon/**/*.ts";
            this.extra = ["./main.js", "./preload.js", "./comp.js"];
            this.read = () => {
              this.srcLoc = this.loc + "/log/word-count.txt";
              var text = FS.readFileSync(this.srcLoc).toString().split("\n");
              var dat = { lst: text.splice(0, 3) };
              return dat;
            };
            this.count = (dat) => {
              var msg = dat.msg;
              this.srcLoc = this.loc + "/log/word-count.txt";
              var recList = ["./data/literature/"];
              recList.forEach((a, b) => {
                recList[b] = "./" + a + "/**/*.ts";
              });
              var list = glob.sync(recList, { dot: true });
              list.forEach((a, b) => (list[b] = "./" + a));
              this.extra.forEach((a) => list.push(a));
              var lines = [];
              var end = [];
              list.forEach((a, b) => {
                var file = FS.readFileSync(a).toString().split("\n");
                lines = lines.concat(file);
              });
              lines.forEach((a, b) => {
                if (underscore_string_1.include(a, "//")) return;
                lines[b] = "";
              });
              lines.forEach(
                (a, b) => (lines[b] = underscore_string_1.slugify(a))
              );
              lines.forEach((a, b) => {
                if (underscore_string_1.isBlank(a)) return;
                end.push(a);
                // console.log(b + " ::: " + a);
              });
              var wordList = [];
              lines.forEach((a) => {
                var dash = a.split("-");
                wordList = wordList.concat(dash);
              });
              var words = {};
              wordList.forEach((a) => {
                if (words[a] != null) words[a] += 1;
                words[a] = 0;
              });
              var snowflake = [];
              for (var key in words) {
                snowflake.push({ key: key, count: words[key] });
              }
              FS.ensureDirSync(this.loc + "/log/");
              FS.ensureFileSync(this.loc + "/log/word-count.txt");
              var text = FS.readFileSync(this.srcLoc).toString().split("\n");
              var saves = text.length - 1;
              var wordStr = String(wordList.length).padStart(7, "0");
              var lineStr = String(lines.length).padStart(7, "0");
              var snowflakeStr = String(snowflake.length).padStart(5, "0");
              var logID = String(saves).padStart(4, "0");
              var log = lineStr + ":" + wordStr + ":" + snowflakeStr;
              var timeA = Moment().format("h:mm:ss");
              var padTime = timeA.split(":");
              var timeB = Moment().format("MMMM Do dddd a YYYY");
              var time = String(padTime[0]).padStart(2, "0") + ":";
              time += String(padTime[1]).padStart(2, "0") + ":";
              time += String(padTime[2]).padStart(2, "0");
              time += " " + timeB;
              var element = log + "_" + time;
              var compare = text[0].split("_")[1];
              var final = logID + "_" + element;
              if (msg != null) final += " : " + msg;
              text.unshift(final);
              if (compare != log) {
                var out = text.join("\n");
                FS.writeFileSync(this.srcLoc, out);
                console.log("writing " + this.srcLoc);
              }
              dat.lst = text.splice(0, 3);
              return dat;
            };
          }
        };
        LineCountProcess = __decorate(
          [typescript_ioc_1.Singleton, __metadata("design:paramtypes", [])],
          LineCountProcess
        );
        exports.default = LineCountProcess;
      },
      {
        "fast-glob": undefined,
        "fs-extra": undefined,
        moment: 77,
        "typescript-ioc": 571,
        "underscore.string": 596,
      },
    ],
    46: [
      function (require, module, exports) {
        (function (process) {
          "use strict";
          var __decorate =
            (this && this.__decorate) ||
            function (decorators, target, key, desc) {
              var c = arguments.length,
                r =
                  c < 3
                    ? target
                    : desc === null
                    ? (desc = Object.getOwnPropertyDescriptor(target, key))
                    : desc,
                d;
              if (
                typeof Reflect === "object" &&
                typeof Reflect.decorate === "function"
              )
                r = Reflect.decorate(decorators, target, key, desc);
              else
                for (var i = decorators.length - 1; i >= 0; i--)
                  if ((d = decorators[i]))
                    r =
                      (c < 3
                        ? d(r)
                        : c > 3
                        ? d(target, key, r)
                        : d(target, key)) || r;
              return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
          var __metadata =
            (this && this.__metadata) ||
            function (k, v) {
              if (
                typeof Reflect === "object" &&
                typeof Reflect.metadata === "function"
              )
                return Reflect.metadata(k, v);
            };
          Object.defineProperty(exports, "__esModule", { value: true });
          const typescript_ioc_1 = require("typescript-ioc");
          const FS = require("fs-extra");
          const clipboardy = require("clipboardy");
          const ytdl = require("ytdl-core");
          const underscore = require("underscore.string");
          const readline = require("readline");
          let YouTubeProcess = class YouTubeProcess {
            constructor() {
              this.loc = "./data/redux/00.sim.unit/";
              this.create = (sav) => {
                var url = clipboardy.readSync();
                console.log("url " + url);
                if (url.includes("youtube") == false)
                  return console.log("nope not youtube");
                var endLoc = sav + "/vid/";
                FS.ensureDirSync(endLoc);
                var here = "here";
                var count = FS.readdirSync(endLoc).length;
                var countPad = String(count).padStart(3, "0");
                ytdl.getBasicInfo(url, null, (err, info) => {
                  var fin = sav + "/utl/youtube.json";
                  FS.writeJSON(fin, info, () => {
                    var author = "";
                    if (info.author != null) {
                      if (info.author.user != null)
                        author = underscore.slugify(info.author.user);
                      if (info.author.name != null)
                        author = underscore.slugify(info.author.name);
                    }
                    var title = underscore.slugify(info.title);
                    here = title;
                    var fileName = "";
                    if (author != "")
                      fileName =
                        endLoc + countPad + "." + author + "." + title + ".mp4";
                    else fileName = endLoc + title + ".mp4";
                    ytdl(url, {
                      filter: (format) => format.container === "mp4",
                    })
                      .on("error", console.error)
                      .on("progress", (chunkLength, downloaded, total) => {
                        const percent = downloaded / total;
                        readline.cursorTo(process.stdout, 0);
                        process.stdout.write(
                          `${(percent * 100).toFixed(2)}% downloaded `
                        );
                        process.stdout.write(
                          `(${(downloaded / 1024 / 1024).toFixed(2)}MB of ${(
                            total /
                            1024 /
                            1024
                          ).toFixed(2)}MB)`
                        );
                      })
                      .pipe(FS.createWriteStream(fileName))
                      .on("finish", () => {
                        console.log("finished:: " + here);
                      });
                  });
                });
              };
            }
          };
          YouTubeProcess = __decorate(
            [typescript_ioc_1.Singleton, __metadata("design:paramtypes", [])],
            YouTubeProcess
          );
          exports.default = YouTubeProcess;
        }.call(this, require("_process")));
      },
      {
        _process: 80,
        clipboardy: undefined,
        "fs-extra": undefined,
        readline: undefined,
        "typescript-ioc": 571,
        "underscore.string": 596,
        "ytdl-core": 647,
      },
    ],
    47: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const title_unit_1 = require("./00.core/title/title.unit");
        const effect_unit_1 = require("./01.effect.unit/effect.unit");
        const title_model_1 = require("./00.core/title/title.model");
        const effect_model_1 = require("./01.effect.unit/effect.model");
        exports.list = [title_unit_1.default, effect_unit_1.default];
        const reduceFromTitle = require("./00.core/title/title.reduce");
        const reduceFromSupport = require("./01.effect.unit/effect.reduce");
        exports.reducer = {
          title: reduceFromTitle.reducer,
          effect: reduceFromSupport.reducer,
        };
        class UnitData {
          constructor() {
            this.auto = 0;
            this.rootData = "../data";
            this.localData = "./data";
            this.title = new title_model_1.TitleModel();
            this.effect = new effect_model_1.EffectModel();
          }
        }
        exports.default = UnitData;
      },
      {
        "./00.core/title/title.model": 20,
        "./00.core/title/title.reduce": 21,
        "./00.core/title/title.unit": 22,
        "./01.effect.unit/effect.model": 38,
        "./01.effect.unit/effect.reduce": 39,
        "./01.effect.unit/effect.unit": 40,
      },
    ],
    48: [
      function (require, module, exports) {
        "use strict";

        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;

        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;

        var code =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }

        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;

        function getLens(b64) {
          var len = b64.length;

          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }

          // Trim off extra bytes after placeholder bytes are found
          // See: https://github.com/beatgammit/base64-js/issues/42
          var validLen = b64.indexOf("=");
          if (validLen === -1) validLen = len;

          var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);

          return [validLen, placeHoldersLen];
        }

        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];

          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

          var curByte = 0;

          // if there are placeholders, only get up to the last complete 4 chars
          var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

          var i;
          for (i = 0; i < len; i += 4) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)];
            arr[curByte++] = (tmp >> 16) & 0xff;
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }

          if (placeHoldersLen === 2) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 2) |
              (revLookup[b64.charCodeAt(i + 1)] >> 4);
            arr[curByte++] = tmp & 0xff;
          }

          if (placeHoldersLen === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2);
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }

          return arr;
        }

        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 0x3f] +
            lookup[(num >> 12) & 0x3f] +
            lookup[(num >> 6) & 0x3f] +
            lookup[num & 0x3f]
          );
        }

        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp =
              ((uint8[i] << 16) & 0xff0000) +
              ((uint8[i + 1] << 8) & 0xff00) +
              (uint8[i + 2] & 0xff);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }

        function fromByteArray(uint8) {
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
          var parts = [];
          var maxChunkLength = 16383; // must be multiple of 3

          // go through the array every three bytes, we'll deal with trailing stuff later
          for (
            var i = 0, len2 = len - extraBytes;
            i < len2;
            i += maxChunkLength
          ) {
            parts.push(
              encodeChunk(
                uint8,
                i,
                i + maxChunkLength > len2 ? len2 : i + maxChunkLength
              )
            );
          }

          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            parts.push(
              lookup[tmp >> 10] +
                lookup[(tmp >> 4) & 0x3f] +
                lookup[(tmp << 2) & 0x3f] +
                "="
            );
          }

          return parts.join("");
        }
      },
      {},
    ],
    49: [function (require, module, exports) {}, {}],
    50: [
      function (require, module, exports) {
        (function (Buffer) {
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <https://feross.org>
           * @license  MIT
           */
          /* eslint-disable no-proto */

          "use strict";

          var base64 = require("base64-js");
          var ieee754 = require("ieee754");
          var customInspectSymbol =
            typeof Symbol === "function" && typeof Symbol.for === "function"
              ? Symbol.for("nodejs.util.inspect.custom")
              : null;

          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;

          var K_MAX_LENGTH = 0x7fffffff;
          exports.kMaxLength = K_MAX_LENGTH;

          /**
           * If `Buffer.TYPED_ARRAY_SUPPORT`:
           *   === true    Use Uint8Array implementation (fastest)
           *   === false   Print warning and recommend using `buffer` v4.x which has an Object
           *               implementation (most compatible, even IE6)
           *
           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
           * Opera 11.6+, iOS 4.2+.
           *
           * We report that the browser does not support typed arrays if the are not subclassable
           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
           * for __proto__ and has a buggy typed array implementation.
           */
          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

          if (
            !Buffer.TYPED_ARRAY_SUPPORT &&
            typeof console !== "undefined" &&
            typeof console.error === "function"
          ) {
            console.error(
              "This browser lacks typed array (Uint8Array) support which is required by " +
                "`buffer` v5.x. Use `buffer` v4.x if you require old browser support."
            );
          }

          function typedArraySupport() {
            // Can typed array instances can be augmented?
            try {
              var arr = new Uint8Array(1);
              var proto = {
                foo: function () {
                  return 42;
                },
              };
              Object.setPrototypeOf(proto, Uint8Array.prototype);
              Object.setPrototypeOf(arr, proto);
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }

          Object.defineProperty(Buffer.prototype, "parent", {
            enumerable: true,
            get: function () {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.buffer;
            },
          });

          Object.defineProperty(Buffer.prototype, "offset", {
            enumerable: true,
            get: function () {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.byteOffset;
            },
          });

          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError(
                'The value "' + length + '" is invalid for option "size"'
              );
            }
            // Return an augmented `Uint8Array` instance
            var buf = new Uint8Array(length);
            Object.setPrototypeOf(buf, Buffer.prototype);
            return buf;
          }

          /**
           * The Buffer constructor returns instances of `Uint8Array` that have their
           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
           * and the `Uint8Array` methods. Square bracket notation works as expected -- it
           * returns a single octet.
           *
           * The `Uint8Array` prototype remains unmodified.
           */

          function Buffer(arg, encodingOrOffset, length) {
            // Common case.
            if (typeof arg === "number") {
              if (typeof encodingOrOffset === "string") {
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }

          Buffer.poolSize = 8192; // not used by this implementation

          function from(value, encodingOrOffset, length) {
            if (typeof value === "string") {
              return fromString(value, encodingOrOffset);
            }

            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }

            if (value == null) {
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, " +
                  "or Array-like Object. Received type " +
                  typeof value
              );
            }

            if (
              isInstance(value, ArrayBuffer) ||
              (value && isInstance(value.buffer, ArrayBuffer))
            ) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }

            if (
              typeof SharedArrayBuffer !== "undefined" &&
              (isInstance(value, SharedArrayBuffer) ||
                (value && isInstance(value.buffer, SharedArrayBuffer)))
            ) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }

            if (typeof value === "number") {
              throw new TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            }

            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer.from(valueOf, encodingOrOffset, length);
            }

            var b = fromObject(value);
            if (b) return b;

            if (
              typeof Symbol !== "undefined" &&
              Symbol.toPrimitive != null &&
              typeof value[Symbol.toPrimitive] === "function"
            ) {
              return Buffer.from(
                value[Symbol.toPrimitive]("string"),
                encodingOrOffset,
                length
              );
            }

            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, " +
                "or Array-like Object. Received type " +
                typeof value
            );
          }

          /**
           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
           * if value is a number.
           * Buffer.from(str[, encoding])
           * Buffer.from(array)
           * Buffer.from(buffer)
           * Buffer.from(arrayBuffer[, byteOffset[, length]])
           **/
          Buffer.from = function (value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };

          // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
          // https://github.com/feross/buffer/pull/148
          Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
          Object.setPrototypeOf(Buffer, Uint8Array);

          function assertSize(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError(
                'The value "' + size + '" is invalid for option "size"'
              );
            }
          }

          function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === "string"
                ? createBuffer(size).fill(fill, encoding)
                : createBuffer(size).fill(fill);
            }
            return createBuffer(size);
          }

          /**
           * Creates a new filled Buffer instance.
           * alloc(size[, fill[, encoding]])
           **/
          Buffer.alloc = function (size, fill, encoding) {
            return alloc(size, fill, encoding);
          };

          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }

          /**
           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
           * */
          Buffer.allocUnsafe = function (size) {
            return allocUnsafe(size);
          };
          /**
           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
           */
          Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(size);
          };

          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8";
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }

            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);

            var actual = buf.write(string, encoding);

            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              buf = buf.slice(0, actual);
            }

            return buf;
          }

          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }

          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }

            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }

            var buf;
            if (byteOffset === undefined && length === undefined) {
              buf = new Uint8Array(array);
            } else if (length === undefined) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }

            // Return an augmented `Uint8Array` instance
            Object.setPrototypeOf(buf, Buffer.prototype);

            return buf;
          }

          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);

              if (buf.length === 0) {
                return buf;
              }

              obj.copy(buf, 0, 0, len);
              return buf;
            }

            if (obj.length !== undefined) {
              if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }

            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }

          function checked(length) {
            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= K_MAX_LENGTH) {
              throw new RangeError(
                "Attempt to allocate Buffer larger than maximum " +
                  "size: 0x" +
                  K_MAX_LENGTH.toString(16) +
                  " bytes"
              );
            }
            return length | 0;
          }

          function SlowBuffer(length) {
            if (+length != length) {
              // eslint-disable-line eqeqeq
              length = 0;
            }
            return Buffer.alloc(+length);
          }

          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
          };

          Buffer.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array))
              a = Buffer.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array))
              b = Buffer.from(b, b.offset, b.byteLength);
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              );
            }

            if (a === b) return 0;

            var x = a.length;
            var y = b.length;

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };

          Buffer.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            }

            if (list.length === 0) {
              return Buffer.alloc(0);
            }

            var i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }

            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer.from(buf);
              }
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                );
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };

          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== "string") {
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                  "Received type " +
                  typeof string
              );
            }

            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0;

            // Use a for loop to avoid recursion
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case "ascii":
                case "latin1":
                case "binary":
                  return len;
                case "utf8":
                case "utf-8":
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                  }
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;

          function slowToString(encoding, start, end) {
            var loweredCase = false;

            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.

            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
            if (start === undefined || start < 0) {
              start = 0;
            }
            // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.
            if (start > this.length) {
              return "";
            }

            if (end === undefined || end > this.length) {
              end = this.length;
            }

            if (end <= 0) {
              return "";
            }

            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
            end >>>= 0;
            start >>>= 0;

            if (end <= start) {
              return "";
            }

            if (!encoding) encoding = "utf8";

            while (true) {
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);

                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);

                case "ascii":
                  return asciiSlice(this, start, end);

                case "latin1":
                case "binary":
                  return latin1Slice(this, start, end);

                case "base64":
                  return base64Slice(this, start, end);

                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);

                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase();
                  loweredCase = true;
              }
            }
          }

          // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
          // reliably in a browserify context because there could be multiple different
          // copies of the 'buffer' package in use. This method works even for Buffer
          // instances that were created from another copy of the `buffer` package.
          // See: https://github.com/feross/buffer/issues/154
          Buffer.prototype._isBuffer = true;

          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }

          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };

          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };

          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };

          Buffer.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0) return "";
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };

          Buffer.prototype.toLocaleString = Buffer.prototype.toString;

          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
          };

          Buffer.prototype.inspect = function inspect() {
            var str = "";
            var max = exports.INSPECT_MAX_BYTES;
            str = this.toString("hex", 0, max)
              .replace(/(.{2})/g, "$1 ")
              .trim();
            if (this.length > max) str += " ... ";
            return "<Buffer " + str + ">";
          };
          if (customInspectSymbol) {
            Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
          }

          Buffer.prototype.compare = function compare(
            target,
            start,
            end,
            thisStart,
            thisEnd
          ) {
            if (isInstance(target, Uint8Array)) {
              target = Buffer.from(target, target.offset, target.byteLength);
            }
            if (!Buffer.isBuffer(target)) {
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. ' +
                  "Received type " +
                  typeof target
              );
            }

            if (start === undefined) {
              start = 0;
            }
            if (end === undefined) {
              end = target ? target.length : 0;
            }
            if (thisStart === undefined) {
              thisStart = 0;
            }
            if (thisEnd === undefined) {
              thisEnd = this.length;
            }

            if (
              start < 0 ||
              end > target.length ||
              thisStart < 0 ||
              thisEnd > this.length
            ) {
              throw new RangeError("out of range index");
            }

            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }

            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;

            if (this === target) return 0;

            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);

            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);

            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
          //
          // Arguments:
          // - buffer - a Buffer to search
          // - val - a string, Buffer, or number
          // - byteOffset - an index into `buffer`; will be clamped to an int32
          // - encoding - an optional encoding, relevant is val is a string
          // - dir - true for indexOf, false for lastIndexOf
          function bidirectionalIndexOf(
            buffer,
            val,
            byteOffset,
            encoding,
            dir
          ) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1;

            // Normalize byteOffset
            if (typeof byteOffset === "string") {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff;
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000;
            }
            byteOffset = +byteOffset; // Coerce to Number.
            if (numberIsNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : buffer.length - 1;
            }

            // Normalize byteOffset: negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir) return -1;
              else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0;
              else return -1;
            }

            // Normalize val
            if (typeof val === "string") {
              val = Buffer.from(val, encoding);
            }

            // Finally, search either indexOf (if dir is true) or lastIndexOf
            if (Buffer.isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
              val = val & 0xff; // Search for a byte value [0-255]
              if (typeof Uint8Array.prototype.indexOf === "function") {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(
                    buffer,
                    val,
                    byteOffset
                  );
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(
                    buffer,
                    val,
                    byteOffset
                  );
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }

            throw new TypeError("val must be string, number or Buffer");
          }

          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;

            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase();
              if (
                encoding === "ucs2" ||
                encoding === "ucs-2" ||
                encoding === "utf16le" ||
                encoding === "utf-16le"
              ) {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }

            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i];
              } else {
                return buf.readUInt16BE(i * indexSize);
              }
            }

            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (
                  read(arr, i) ===
                  read(val, foundIndex === -1 ? 0 : i - foundIndex)
                ) {
                  if (foundIndex === -1) foundIndex = i;
                  if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength)
                byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found) return i;
              }
            }

            return -1;
          }

          Buffer.prototype.includes = function includes(
            val,
            byteOffset,
            encoding
          ) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };

          Buffer.prototype.indexOf = function indexOf(
            val,
            byteOffset,
            encoding
          ) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };

          Buffer.prototype.lastIndexOf = function lastIndexOf(
            val,
            byteOffset,
            encoding
          ) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };

          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }

            var strLen = string.length;

            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }
            return i;
          }

          function utf8Write(buf, string, offset, length) {
            return blitBuffer(
              utf8ToBytes(string, buf.length - offset),
              buf,
              offset,
              length
            );
          }

          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }

          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }

          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }

          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(
              utf16leToBytes(string, buf.length - offset),
              buf,
              offset,
              length
            );
          }

          Buffer.prototype.write = function write(
            string,
            offset,
            length,
            encoding
          ) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = "utf8";
              length = this.length;
              offset = 0;
              // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === "string") {
              encoding = offset;
              length = this.length;
              offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === undefined) encoding = "utf8";
              } else {
                encoding = length;
                length = undefined;
              }
            } else {
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            }

            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;

            if (
              (string.length > 0 && (length < 0 || offset < 0)) ||
              offset > this.length
            ) {
              throw new RangeError("Attempt to write outside buffer bounds");
            }

            if (!encoding) encoding = "utf8";

            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);

                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);

                case "ascii":
                  return asciiWrite(this, string, offset, length);

                case "latin1":
                case "binary":
                  return latin1Write(this, string, offset, length);

                case "base64":
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length);

                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);

                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };

          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0),
            };
          };

          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }

          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];

            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence =
                firstByte > 0xef
                  ? 4
                  : firstByte > 0xdf
                  ? 3
                  : firstByte > 0xbf
                  ? 2
                  : 1;

              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;

                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xc0) === 0x80) {
                      tempCodePoint =
                        ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                      if (tempCodePoint > 0x7f) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if (
                      (secondByte & 0xc0) === 0x80 &&
                      (thirdByte & 0xc0) === 0x80
                    ) {
                      tempCodePoint =
                        ((firstByte & 0xf) << 0xc) |
                        ((secondByte & 0x3f) << 0x6) |
                        (thirdByte & 0x3f);
                      if (
                        tempCodePoint > 0x7ff &&
                        (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                      ) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if (
                      (secondByte & 0xc0) === 0x80 &&
                      (thirdByte & 0xc0) === 0x80 &&
                      (fourthByte & 0xc0) === 0x80
                    ) {
                      tempCodePoint =
                        ((firstByte & 0xf) << 0x12) |
                        ((secondByte & 0x3f) << 0xc) |
                        ((thirdByte & 0x3f) << 0x6) |
                        (fourthByte & 0x3f);
                      if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }

              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xfffd;
                bytesPerSequence = 1;
              } else if (codePoint > 0xffff) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000;
                res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
                codePoint = 0xdc00 | (codePoint & 0x3ff);
              }

              res.push(codePoint);
              i += bytesPerSequence;
            }

            return decodeCodePointsArray(res);
          }

          // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 0x1000;

          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = "";
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(
                String,
                codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
              );
            }
            return res;
          }

          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7f);
            }
            return ret;
          }

          function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }

          function hexSlice(buf, start, end) {
            var len = buf.length;

            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;

            var out = "";
            for (var i = start; i < end; ++i) {
              out += hexSliceLookupTable[buf[i]];
            }
            return out;
          }

          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }

          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;

            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }

            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }

            if (end < start) end = start;

            var newBuf = this.subarray(start, end);
            // Return an augmented `Uint8Array` instance
            Object.setPrototypeOf(newBuf, Buffer.prototype);

            return newBuf;
          };

          /*
           * Need to make sure that buffer isn't trying to write out of bounds.
           */
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }

          Buffer.prototype.readUIntLE = function readUIntLE(
            offset,
            byteLength,
            noAssert
          ) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }

            return val;
          };

          Buffer.prototype.readUIntBE = function readUIntBE(
            offset,
            byteLength,
            noAssert
          ) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }

            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul;
            }

            return val;
          };

          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };

          Buffer.prototype.readUInt16LE = function readUInt16LE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | (this[offset + 1] << 8);
          };

          Buffer.prototype.readUInt16BE = function readUInt16BE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return (this[offset] << 8) | this[offset + 1];
          };

          Buffer.prototype.readUInt32LE = function readUInt32LE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return (
              (this[offset] |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16)) +
              this[offset + 3] * 0x1000000
            );
          };

          Buffer.prototype.readUInt32BE = function readUInt32BE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return (
              this[offset] * 0x1000000 +
              ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
            );
          };

          Buffer.prototype.readIntLE = function readIntLE(
            offset,
            byteLength,
            noAssert
          ) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            mul *= 0x80;

            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

            return val;
          };

          Buffer.prototype.readIntBE = function readIntBE(
            offset,
            byteLength,
            noAssert
          ) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul;
            }
            mul *= 0x80;

            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

            return val;
          };

          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80)) return this[offset];
            return (0xff - this[offset] + 1) * -1;
          };

          Buffer.prototype.readInt16LE = function readInt16LE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | (this[offset + 1] << 8);
            return val & 0x8000 ? val | 0xffff0000 : val;
          };

          Buffer.prototype.readInt16BE = function readInt16BE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | (this[offset] << 8);
            return val & 0x8000 ? val | 0xffff0000 : val;
          };

          Buffer.prototype.readInt32LE = function readInt32LE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return (
              this[offset] |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16) |
              (this[offset + 3] << 24)
            );
          };

          Buffer.prototype.readInt32BE = function readInt32BE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return (
              (this[offset] << 24) |
              (this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3]
            );
          };

          Buffer.prototype.readFloatLE = function readFloatLE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };

          Buffer.prototype.readFloatBE = function readFloatBE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };

          Buffer.prototype.readDoubleLE = function readDoubleLE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };

          Buffer.prototype.readDoubleBE = function readDoubleBE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };

          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError(
                '"buffer" argument must be a Buffer instance'
              );
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
          }

          Buffer.prototype.writeUIntLE = function writeUIntLE(
            value,
            offset,
            byteLength,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var mul = 1;
            var i = 0;
            this[offset] = value & 0xff;
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = (value / mul) & 0xff;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUIntBE = function writeUIntBE(
            value,
            offset,
            byteLength,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 0xff;
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = (value / mul) & 0xff;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUInt8 = function writeUInt8(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeUInt16LE = function writeUInt16LE(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };

          Buffer.prototype.writeUInt16BE = function writeUInt16BE(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };

          Buffer.prototype.writeUInt32LE = function writeUInt32LE(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
            return offset + 4;
          };

          Buffer.prototype.writeUInt32BE = function writeUInt32BE(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };

          Buffer.prototype.writeIntLE = function writeIntLE(
            value,
            offset,
            byteLength,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);

              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 0xff;
            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeIntBE = function writeIntBE(
            value,
            offset,
            byteLength,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);

              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 0xff;
            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeInt8 = function writeInt8(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
            if (value < 0) value = 0xff + value + 1;
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeInt16LE = function writeInt16LE(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };

          Buffer.prototype.writeInt16BE = function writeInt16BE(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };

          Buffer.prototype.writeInt32LE = function writeInt32LE(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };

          Buffer.prototype.writeInt32BE = function writeInt32BE(
            value,
            offset,
            noAssert
          ) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0) value = 0xffffffff + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };

          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
            if (offset < 0) throw new RangeError("Index out of range");
          }

          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(
                buf,
                value,
                offset,
                4,
                3.4028234663852886e38,
                -3.4028234663852886e38
              );
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }

          Buffer.prototype.writeFloatLE = function writeFloatLE(
            value,
            offset,
            noAssert
          ) {
            return writeFloat(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeFloatBE = function writeFloatBE(
            value,
            offset,
            noAssert
          ) {
            return writeFloat(this, value, offset, false, noAssert);
          };

          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(
                buf,
                value,
                offset,
                8,
                1.7976931348623157e308,
                -1.7976931348623157e308
              );
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }

          Buffer.prototype.writeDoubleLE = function writeDoubleLE(
            value,
            offset,
            noAssert
          ) {
            return writeDouble(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeDoubleBE = function writeDoubleBE(
            value,
            offset,
            noAssert
          ) {
            return writeDouble(this, value, offset, false, noAssert);
          };

          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy(
            target,
            targetStart,
            start,
            end
          ) {
            if (!Buffer.isBuffer(target))
              throw new TypeError("argument should be a Buffer");
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;

            // Copy 0 bytes; we're done
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;

            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length)
              throw new RangeError("Index out of range");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");

            // Are we oob?
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }

            var len = end - start;

            if (
              this === target &&
              typeof Uint8Array.prototype.copyWithin === "function"
            ) {
              // Use built-in when available, missing from IE11
              this.copyWithin(targetStart, start, end);
            } else if (
              this === target &&
              start < targetStart &&
              targetStart < end
            ) {
              // descending copy from end
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(
                target,
                this.subarray(start, end),
                targetStart
              );
            }

            return len;
          };

          // Usage:
          //    buffer.fill(number[, offset[, end]])
          //    buffer.fill(buffer[, offset[, end]])
          //    buffer.fill(string[, offset[, end]][, encoding])
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === "string") {
                encoding = end;
                end = this.length;
              }
              if (encoding !== undefined && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string");
              }
              if (
                typeof encoding === "string" &&
                !Buffer.isEncoding(encoding)
              ) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (
                  (encoding === "utf8" && code < 128) ||
                  encoding === "latin1"
                ) {
                  // Fast path: If `val` fits into a single byte, use that numeric value.
                  val = code;
                }
              }
            } else if (typeof val === "number") {
              val = val & 255;
            } else if (typeof val === "boolean") {
              val = Number(val);
            }

            // Invalid ranges are not set to a default, so can range check early.
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError("Out of range index");
            }

            if (end <= start) {
              return this;
            }

            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;

            if (!val) val = 0;

            var i;
            if (typeof val === "number") {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val)
                ? val
                : Buffer.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError(
                  'The value "' + val + '" is invalid for argument "value"'
                );
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }

            return this;
          };

          // HELPER FUNCTIONS
          // ================

          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

          function base64clean(str) {
            // Node takes equal signs as end of the Base64 encoding
            str = str.split("=")[0];
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = str.trim().replace(INVALID_BASE64_RE, "");
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return "";
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + "=";
            }
            return str;
          }

          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];

            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);

              // is surrogate component
              if (codePoint > 0xd7ff && codePoint < 0xe000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xdbff) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                    continue;
                  }

                  // valid lead
                  leadSurrogate = codePoint;

                  continue;
                }

                // 2 leads in a row
                if (codePoint < 0xdc00) {
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  leadSurrogate = codePoint;
                  continue;
                }

                // valid surrogate pair
                codePoint =
                  (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                  0x10000;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
              }

              leadSurrogate = null;

              // encode utf8
              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break;
                bytes.push(
                  (codePoint >> 0x6) | 0xc0,
                  (codePoint & 0x3f) | 0x80
                );
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break;
                bytes.push(
                  (codePoint >> 0xc) | 0xe0,
                  ((codePoint >> 0x6) & 0x3f) | 0x80,
                  (codePoint & 0x3f) | 0x80
                );
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break;
                bytes.push(
                  (codePoint >> 0x12) | 0xf0,
                  ((codePoint >> 0xc) & 0x3f) | 0x80,
                  ((codePoint >> 0x6) & 0x3f) | 0x80,
                  (codePoint & 0x3f) | 0x80
                );
              } else {
                throw new Error("Invalid code point");
              }
            }

            return bytes;
          }

          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xff);
            }
            return byteArray;
          }

          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break;

              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }

            return byteArray;
          }

          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }

          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }
            return i;
          }

          // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
          // the `instanceof` check but they should be treated as of that type.
          // See: https://github.com/feross/buffer/issues/166
          function isInstance(obj, type) {
            return (
              obj instanceof type ||
              (obj != null &&
                obj.constructor != null &&
                obj.constructor.name != null &&
                obj.constructor.name === type.name)
            );
          }
          function numberIsNaN(obj) {
            // For IE11 support
            return obj !== obj; // eslint-disable-line no-self-compare
          }

          // Create lookup table for `toString('hex')`
          // See: https://github.com/feross/buffer/issues/219
          var hexSliceLookupTable = (function () {
            var alphabet = "0123456789abcdef";
            var table = new Array(256);
            for (var i = 0; i < 16; ++i) {
              var i16 = i * 16;
              for (var j = 0; j < 16; ++j) {
                table[i16 + j] = alphabet[i] + alphabet[j];
              }
            }
            return table;
          })();
        }.call(this, require("buffer").Buffer));
      },
      { "base64-js": 48, buffer: 50, ieee754: 62 },
    ],
    51: [
      function (require, module, exports) {
        "use strict";

        /**
         * Module dependenices
         */

        const clone = require("shallow-clone");
        const typeOf = require("kind-of");
        const isPlainObject = require("is-plain-object");

        function cloneDeep(val, instanceClone) {
          switch (typeOf(val)) {
            case "object":
              return cloneObjectDeep(val, instanceClone);
            case "array":
              return cloneArrayDeep(val, instanceClone);
            default: {
              return clone(val);
            }
          }
        }

        function cloneObjectDeep(val, instanceClone) {
          if (typeof instanceClone === "function") {
            return instanceClone(val);
          }
          if (instanceClone || isPlainObject(val)) {
            const res = new val.constructor();
            for (let key in val) {
              res[key] = cloneDeep(val[key], instanceClone);
            }
            return res;
          }
          return val;
        }

        function cloneArrayDeep(val, instanceClone) {
          const res = new val.constructor(val.length);
          for (let i = 0; i < val.length; i++) {
            res[i] = cloneDeep(val[i], instanceClone);
          }
          return res;
        }

        /**
         * Expose `cloneDeep`
         */

        module.exports = cloneDeep;
      },
      { "is-plain-object": 65, "kind-of": 68, "shallow-clone": 552 },
    ],
    52: [
      function (require, module, exports) {
        (function (Buffer) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.

          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg);
            }
            return objectToString(arg) === "[object Array]";
          }
          exports.isArray = isArray;

          function isBoolean(arg) {
            return typeof arg === "boolean";
          }
          exports.isBoolean = isBoolean;

          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;

          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;

          function isNumber(arg) {
            return typeof arg === "number";
          }
          exports.isNumber = isNumber;

          function isString(arg) {
            return typeof arg === "string";
          }
          exports.isString = isString;

          function isSymbol(arg) {
            return typeof arg === "symbol";
          }
          exports.isSymbol = isSymbol;

          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;

          function isRegExp(re) {
            return objectToString(re) === "[object RegExp]";
          }
          exports.isRegExp = isRegExp;

          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          exports.isObject = isObject;

          function isDate(d) {
            return objectToString(d) === "[object Date]";
          }
          exports.isDate = isDate;

          function isError(e) {
            return objectToString(e) === "[object Error]" || e instanceof Error;
          }
          exports.isError = isError;

          function isFunction(arg) {
            return typeof arg === "function";
          }
          exports.isFunction = isFunction;

          function isPrimitive(arg) {
            return (
              arg === null ||
              typeof arg === "boolean" ||
              typeof arg === "number" ||
              typeof arg === "string" ||
              typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined"
            );
          }
          exports.isPrimitive = isPrimitive;

          exports.isBuffer = Buffer.isBuffer;

          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
        }.call(this, { isBuffer: require("../../is-buffer/index.js") }));
      },
      { "../../is-buffer/index.js": 64 },
    ],
    53: [
      function (require, module, exports) {
        "use strict";
        var token = "%[a-f0-9]{2}";
        var singleMatcher = new RegExp(token, "gi");
        var multiMatcher = new RegExp("(" + token + ")+", "gi");

        function decodeComponents(components, split) {
          try {
            // Try to decode the entire string first
            return decodeURIComponent(components.join(""));
          } catch (err) {
            // Do nothing
          }

          if (components.length === 1) {
            return components;
          }

          split = split || 1;

          // Split the array in 2 parts
          var left = components.slice(0, split);
          var right = components.slice(split);

          return Array.prototype.concat.call(
            [],
            decodeComponents(left),
            decodeComponents(right)
          );
        }

        function decode(input) {
          try {
            return decodeURIComponent(input);
          } catch (err) {
            var tokens = input.match(singleMatcher);

            for (var i = 1; i < tokens.length; i++) {
              input = decodeComponents(tokens, i).join("");

              tokens = input.match(singleMatcher);
            }

            return input;
          }
        }

        function customDecodeURIComponent(input) {
          // Keep track of all the replacements and prefill the map with the `BOM`
          var replaceMap = {
            "%FE%FF": "\uFFFD\uFFFD",
            "%FF%FE": "\uFFFD\uFFFD",
          };

          var match = multiMatcher.exec(input);
          while (match) {
            try {
              // Decode as big chunks as possible
              replaceMap[match[0]] = decodeURIComponent(match[0]);
            } catch (err) {
              var result = decode(match[0]);

              if (result !== match[0]) {
                replaceMap[match[0]] = result;
              }
            }

            match = multiMatcher.exec(input);
          }

          // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
          replaceMap["%C2"] = "\uFFFD";

          var entries = Object.keys(replaceMap);

          for (var i = 0; i < entries.length; i++) {
            // Replace all decoded components
            var key = entries[i];
            input = input.replace(new RegExp(key, "g"), replaceMap[key]);
          }

          return input;
        }

        module.exports = function (encodedURI) {
          if (typeof encodedURI !== "string") {
            throw new TypeError(
              "Expected `encodedURI` to be of type `string`, got `" +
                typeof encodedURI +
                "`"
            );
          }

          try {
            encodedURI = encodedURI.replace(/\+/g, " ");

            // Try the built in decoder first
            return decodeURIComponent(encodedURI);
          } catch (err) {
            // Fallback to a more advanced decoder
            return customDecodeURIComponent(encodedURI);
          }
        };
      },
      {},
    ],
    54: [
      function (require, module, exports) {
        // doT.js
        // 2011-2014, Laura Doktorova, https://github.com/olado/doT
        // Licensed under the MIT license.

        (function () {
          "use strict";

          var doT = {
              name: "doT",
              version: "1.1.1",
              templateSettings: {
                evaluate: /\{\{([\s\S]+?(\}?)+)\}\}/g,
                interpolate: /\{\{=([\s\S]+?)\}\}/g,
                encode: /\{\{!([\s\S]+?)\}\}/g,
                use: /\{\{#([\s\S]+?)\}\}/g,
                useParams: /(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
                define: /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
                defineParams: /^\s*([\w$]+):([\s\S]+)/,
                conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
                iterate: /\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
                varname: "it",
                strip: true,
                append: true,
                selfcontained: false,
                doNotSkipEncoded: false,
              },
              template: undefined, //fn, compile template
              compile: undefined, //fn, for express
              log: true,
            },
            _globals;

          doT.encodeHTMLSource = function (doNotSkipEncoded) {
            var encodeHTMLRules = {
                "&": "&#38;",
                "<": "&#60;",
                ">": "&#62;",
                '"': "&#34;",
                "'": "&#39;",
                "/": "&#47;",
              },
              matchHTML = doNotSkipEncoded
                ? /[&<>"'\/]/g
                : /&(?!#?\w+;)|<|>|"|'|\//g;
            return function (code) {
              return code
                ? code.toString().replace(matchHTML, function (m) {
                    return encodeHTMLRules[m] || m;
                  })
                : "";
            };
          };

          _globals = (function () {
            return this || (0, eval)("this");
          })();

          /* istanbul ignore else */
          if (typeof module !== "undefined" && module.exports) {
            module.exports = doT;
          } else if (typeof define === "function" && define.amd) {
            define(function () {
              return doT;
            });
          } else {
            _globals.doT = doT;
          }

          var startend = {
              append: {
                start: "'+(",
                end: ")+'",
                startencode: "'+encodeHTML(",
              },
              split: {
                start: "';out+=(",
                end: ");out+='",
                startencode: "';out+=encodeHTML(",
              },
            },
            skip = /$^/;

          function resolveDefs(c, block, def) {
            return (typeof block === "string" ? block : block.toString())
              .replace(c.define || skip, function (m, code, assign, value) {
                if (code.indexOf("def.") === 0) {
                  code = code.substring(4);
                }
                if (!(code in def)) {
                  if (assign === ":") {
                    if (c.defineParams)
                      value.replace(c.defineParams, function (m, param, v) {
                        def[code] = { arg: param, text: v };
                      });
                    if (!(code in def)) def[code] = value;
                  } else {
                    new Function("def", "def['" + code + "']=" + value)(def);
                  }
                }
                return "";
              })
              .replace(c.use || skip, function (m, code) {
                if (c.useParams)
                  code = code.replace(c.useParams, function (m, s, d, param) {
                    if (def[d] && def[d].arg && param) {
                      var rw = (d + ":" + param).replace(/'|\\/g, "_");
                      def.__exp = def.__exp || {};
                      def.__exp[rw] = def[d].text.replace(
                        new RegExp(
                          "(^|[^\\w$])" + def[d].arg + "([^\\w$])",
                          "g"
                        ),
                        "$1" + param + "$2"
                      );
                      return s + "def.__exp['" + rw + "']";
                    }
                  });
                var v = new Function("def", "return " + code)(def);
                return v ? resolveDefs(c, v, def) : v;
              });
          }

          function unescape(code) {
            return code.replace(/\\('|\\)/g, "$1").replace(/[\r\t\n]/g, " ");
          }

          doT.template = function (tmpl, c, def) {
            c = c || doT.templateSettings;
            var cse = c.append ? startend.append : startend.split,
              needhtmlencode,
              sid = 0,
              indv,
              str = c.use || c.define ? resolveDefs(c, tmpl, def || {}) : tmpl;

            str = (
              "var out='" +
              (c.strip
                ? str
                    .replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g, " ")
                    .replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g, "")
                : str
              )
                .replace(/'|\\/g, "\\$&")
                .replace(c.interpolate || skip, function (m, code) {
                  return cse.start + unescape(code) + cse.end;
                })
                .replace(c.encode || skip, function (m, code) {
                  needhtmlencode = true;
                  return cse.startencode + unescape(code) + cse.end;
                })
                .replace(c.conditional || skip, function (m, elsecase, code) {
                  return elsecase
                    ? code
                      ? "';}else if(" + unescape(code) + "){out+='"
                      : "';}else{out+='"
                    : code
                    ? "';if(" + unescape(code) + "){out+='"
                    : "';}out+='";
                })
                .replace(c.iterate || skip, function (
                  m,
                  iterate,
                  vname,
                  iname
                ) {
                  if (!iterate) return "';} } out+='";
                  sid += 1;
                  indv = iname || "i" + sid;
                  iterate = unescape(iterate);
                  return (
                    "';var arr" +
                    sid +
                    "=" +
                    iterate +
                    ";if(arr" +
                    sid +
                    "){var " +
                    vname +
                    "," +
                    indv +
                    "=-1,l" +
                    sid +
                    "=arr" +
                    sid +
                    ".length-1;while(" +
                    indv +
                    "<l" +
                    sid +
                    "){" +
                    vname +
                    "=arr" +
                    sid +
                    "[" +
                    indv +
                    "+=1];out+='"
                  );
                })
                .replace(c.evaluate || skip, function (m, code) {
                  return "';" + unescape(code) + "out+='";
                }) +
              "';return out;"
            )
              .replace(/\n/g, "\\n")
              .replace(/\t/g, "\\t")
              .replace(/\r/g, "\\r")
              .replace(/(\s|;|\}|^|\{)out\+='';/g, "$1")
              .replace(/\+''/g, "");
            //.replace(/(\s|;|\}|^|\{)out\+=''\+/g,'$1out+=');

            if (needhtmlencode) {
              if (!c.selfcontained && _globals && !_globals._encodeHTML)
                _globals._encodeHTML = doT.encodeHTMLSource(c.doNotSkipEncoded);
              str =
                "var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : (" +
                doT.encodeHTMLSource.toString() +
                "(" +
                (c.doNotSkipEncoded || "") +
                "));" +
                str;
            }
            try {
              return new Function(c.varname, str);
            } catch (e) {
              /* istanbul ignore else */
              if (typeof console !== "undefined")
                console.log("Could not create a template function: " + str);
              throw e;
            }
          };

          doT.compile = function (tmpl, def) {
            return doT.template(tmpl, null, def);
          };
        })();
      },
      {},
    ],
    55: [
      function (require, module, exports) {
        (function (process) {
          /* @flow */
          /*::

type DotenvParseOptions = {
  debug?: boolean
}

// keys and values from src
type DotenvParseOutput = { [string]: string }

type DotenvConfigOptions = {
  path?: string, // path to .env file
  encoding?: string, // encoding of .env file
  debug?: string // turn on logging for debugging purposes
}

type DotenvConfigOutput = {
  parsed?: DotenvParseOutput,
  error?: Error
}

*/

          const fs = require("fs");
          const path = require("path");

          function log(message /*: string */) {
            console.log(`[dotenv][DEBUG] ${message}`);
          }

          const NEWLINE = "\n";
          const RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
          const RE_NEWLINES = /\\n/g;
          const NEWLINES_MATCH = /\n|\r|\r\n/;

          // Parses src into an Object
          function parse(
            src /*: string | Buffer */,
            options /*: ?DotenvParseOptions */
          ) /*: DotenvParseOutput */ {
            const debug = Boolean(options && options.debug);
            const obj = {};

            // convert Buffers before splitting into lines and processing
            src
              .toString()
              .split(NEWLINES_MATCH)
              .forEach(function (line, idx) {
                // matching "KEY' and 'VAL' in 'KEY=VAL'
                const keyValueArr = line.match(RE_INI_KEY_VAL);
                // matched?
                if (keyValueArr != null) {
                  const key = keyValueArr[1];
                  // default undefined or missing values to empty string
                  let val = keyValueArr[2] || "";
                  const end = val.length - 1;
                  const isDoubleQuoted = val[0] === '"' && val[end] === '"';
                  const isSingleQuoted = val[0] === "'" && val[end] === "'";

                  // if single or double quoted, remove quotes
                  if (isSingleQuoted || isDoubleQuoted) {
                    val = val.substring(1, end);

                    // if double quoted, expand newlines
                    if (isDoubleQuoted) {
                      val = val.replace(RE_NEWLINES, NEWLINE);
                    }
                  } else {
                    // remove surrounding whitespace
                    val = val.trim();
                  }

                  obj[key] = val;
                } else if (debug) {
                  log(
                    `did not match key and value when parsing line ${
                      idx + 1
                    }: ${line}`
                  );
                }
              });

            return obj;
          }

          // Populates process.env from .env file
          function config(
            options /*: ?DotenvConfigOptions */
          ) /*: DotenvConfigOutput */ {
            let dotenvPath = path.resolve(process.cwd(), ".env");
            let encoding /*: string */ = "utf8";
            let debug = false;

            if (options) {
              if (options.path != null) {
                dotenvPath = options.path;
              }
              if (options.encoding != null) {
                encoding = options.encoding;
              }
              if (options.debug != null) {
                debug = true;
              }
            }

            try {
              // specifying an encoding returns a string instead of a buffer
              const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), {
                debug,
              });

              Object.keys(parsed).forEach(function (key) {
                if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
                  process.env[key] = parsed[key];
                } else if (debug) {
                  log(
                    `"${key}" is already defined in \`process.env\` and will not be overwritten`
                  );
                }
              });

              return { parsed };
            } catch (e) {
              return { error: e };
            }
          }

          module.exports.config = config;
          module.exports.parse = parse;
        }.call(this, require("_process")));
      },
      { _process: 80, fs: undefined, path: 78 },
    ],
    56: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var objectCreate = Object.create || objectCreatePolyfill;
        var objectKeys = Object.keys || objectKeysPolyfill;
        var bind = Function.prototype.bind || functionBindPolyfill;

        function EventEmitter() {
          if (
            !this._events ||
            !Object.prototype.hasOwnProperty.call(this, "_events")
          ) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          }

          this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;

        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10;

        var hasDefineProperty;
        try {
          var o = {};
          if (Object.defineProperty)
            Object.defineProperty(o, "x", { value: 0 });
          hasDefineProperty = o.x === 0;
        } catch (err) {
          hasDefineProperty = false;
        }
        if (hasDefineProperty) {
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function () {
              return defaultMaxListeners;
            },
            set: function (arg) {
              // check whether the input is a positive number (whose value is zero or
              // greater and not a NaN).
              if (typeof arg !== "number" || arg < 0 || arg !== arg)
                throw new TypeError(
                  '"defaultMaxListeners" must be a positive number'
                );
              defaultMaxListeners = arg;
            },
          });
        } else {
          EventEmitter.defaultMaxListeners = defaultMaxListeners;
        }

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || isNaN(n))
            throw new TypeError('"n" argument must be a positive number');
          this._maxListeners = n;
          return this;
        };

        function $getMaxListeners(that) {
          if (that._maxListeners === undefined)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this);
        };

        // These standalone emit* functions are used to optimize calling of event
        // handlers for fast cases because emit() itself often has a variable number of
        // arguments and can be deoptimized because of that. These functions always have
        // the same number of arguments and thus do not get deoptimized, so the code
        // inside them can execute faster.
        function emitNone(handler, isFn, self) {
          if (isFn) handler.call(self);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].call(self);
          }
        }
        function emitOne(handler, isFn, self, arg1) {
          if (isFn) handler.call(self, arg1);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
          }
        }
        function emitTwo(handler, isFn, self, arg1, arg2) {
          if (isFn) handler.call(self, arg1, arg2);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
          }
        }
        function emitThree(handler, isFn, self, arg1, arg2, arg3) {
          if (isFn) handler.call(self, arg1, arg2, arg3);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self, arg1, arg2, arg3);
          }
        }

        function emitMany(handler, isFn, self, args) {
          if (isFn) handler.apply(self, args);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
          }
        }

        EventEmitter.prototype.emit = function emit(type) {
          var er, handler, len, args, i, events;
          var doError = type === "error";

          events = this._events;
          if (events) doError = doError && events.error == null;
          else if (!doError) return false;

          // If there is no 'error' event listener then throw.
          if (doError) {
            if (arguments.length > 1) er = arguments[1];
            if (er instanceof Error) {
              throw er; // Unhandled 'error' event
            } else {
              // At least give some kind of context to the user
              var err = new Error('Unhandled "error" event. (' + er + ")");
              err.context = er;
              throw err;
            }
            return false;
          }

          handler = events[type];

          if (!handler) return false;

          var isFn = typeof handler === "function";
          len = arguments.length;
          switch (len) {
            // fast cases
            case 1:
              emitNone(handler, isFn, this);
              break;
            case 2:
              emitOne(handler, isFn, this, arguments[1]);
              break;
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2]);
              break;
            case 4:
              emitThree(
                handler,
                isFn,
                this,
                arguments[1],
                arguments[2],
                arguments[3]
              );
              break;
            // slower
            default:
              args = new Array(len - 1);
              for (i = 1; i < len; i++) args[i - 1] = arguments[i];
              emitMany(handler, isFn, this, args);
          }

          return true;
        };

        function _addListener(target, type, listener, prepend) {
          var m;
          var events;
          var existing;

          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');

          events = target._events;
          if (!events) {
            events = target._events = objectCreate(null);
            target._eventsCount = 0;
          } else {
            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (events.newListener) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              );

              // Re-assign `events` because a newListener handler could have caused the
              // this._events to be assigned to a new object
              events = target._events;
            }
            existing = events[type];
          }

          if (!existing) {
            // Optimize the case of one listener. Don't need the extra array object.
            existing = events[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              // Adding the second element, need to change to array.
              existing = events[type] = prepend
                ? [listener, existing]
                : [existing, listener];
            } else {
              // If we've already got an array, just append.
              if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
            }

            // Check for listener leak
            if (!existing.warned) {
              m = $getMaxListeners(target);
              if (m && m > 0 && existing.length > m) {
                existing.warned = true;
                var w = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    existing.length +
                    ' "' +
                    String(type) +
                    '" listeners ' +
                    "added. Use emitter.setMaxListeners() to " +
                    "increase limit."
                );
                w.name = "MaxListenersExceededWarning";
                w.emitter = target;
                w.type = type;
                w.count = existing.length;
                if (typeof console === "object" && console.warn) {
                  console.warn("%s: %s", w.name, w.message);
                }
              }
            }
          }

          return target;
        }

        EventEmitter.prototype.addListener = function addListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, false);
        };

        EventEmitter.prototype.on = EventEmitter.prototype.addListener;

        EventEmitter.prototype.prependListener = function prependListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, true);
        };

        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            switch (arguments.length) {
              case 0:
                return this.listener.call(this.target);
              case 1:
                return this.listener.call(this.target, arguments[0]);
              case 2:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1]
                );
              case 3:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1],
                  arguments[2]
                );
              default:
                var args = new Array(arguments.length);
                for (var i = 0; i < args.length; ++i) args[i] = arguments[i];
                this.listener.apply(this.target, args);
            }
          }
        }

        function _onceWrap(target, type, listener) {
          var state = {
            fired: false,
            wrapFn: undefined,
            target: target,
            type: type,
            listener: listener,
          };
          var wrapped = bind.call(onceWrapper, state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }

        EventEmitter.prototype.once = function once(type, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };

        EventEmitter.prototype.prependOnceListener = function prependOnceListener(
          type,
          listener
        ) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

        // Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener = function removeListener(
          type,
          listener
        ) {
          var list, events, position, i, originalListener;

          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');

          events = this._events;
          if (!events) return this;

          list = events[type];
          if (!list) return this;

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0) this._events = objectCreate(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit("removeListener", type, list.listener || listener);
            }
          } else if (typeof list !== "function") {
            position = -1;

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0) return this;

            if (position === 0) list.shift();
            else spliceOne(list, position);

            if (list.length === 1) events[type] = list[0];

            if (events.removeListener)
              this.emit("removeListener", type, originalListener || listener);
          }

          return this;
        };

        EventEmitter.prototype.removeAllListeners = function removeAllListeners(
          type
        ) {
          var listeners, events, i;

          events = this._events;
          if (!events) return this;

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = objectCreate(null);
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0) this._events = objectCreate(null);
              else delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = objectKeys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "removeListener") continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = objectCreate(null);
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }

          return this;
        };

        function _listeners(target, type, unwrap) {
          var events = target._events;

          if (!events) return [];

          var evlistener = events[type];
          if (!evlistener) return [];

          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];

          return unwrap
            ? unwrapListeners(evlistener)
            : arrayClone(evlistener, evlistener.length);
        }

        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };

        EventEmitter.listenerCount = function (emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };

        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;

          if (events) {
            var evlistener = events[type];

            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener) {
              return evlistener.length;
            }
          }

          return 0;
        }

        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };

        // About 1.5x faster than the two-arg version of Array#splice().
        function spliceOne(list, index) {
          for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
            list[i] = list[k];
          list.pop();
        }

        function arrayClone(arr, n) {
          var copy = new Array(n);
          for (var i = 0; i < n; ++i) copy[i] = arr[i];
          return copy;
        }

        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }

        function objectCreatePolyfill(proto) {
          var F = function () {};
          F.prototype = proto;
          return new F();
        }
        function objectKeysPolyfill(obj) {
          var keys = [];
          for (var k in obj)
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              keys.push(k);
            }
          return k;
        }
        function functionBindPolyfill(context) {
          var fn = this;
          return function () {
            return fn.apply(context, arguments);
          };
        }
      },
      {},
    ],
    57: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var HTML_ALPHA = [
          "apos",
          "nbsp",
          "iexcl",
          "cent",
          "pound",
          "curren",
          "yen",
          "brvbar",
          "sect",
          "uml",
          "copy",
          "ordf",
          "laquo",
          "not",
          "shy",
          "reg",
          "macr",
          "deg",
          "plusmn",
          "sup2",
          "sup3",
          "acute",
          "micro",
          "para",
          "middot",
          "cedil",
          "sup1",
          "ordm",
          "raquo",
          "frac14",
          "frac12",
          "frac34",
          "iquest",
          "Agrave",
          "Aacute",
          "Acirc",
          "Atilde",
          "Auml",
          "Aring",
          "Aelig",
          "Ccedil",
          "Egrave",
          "Eacute",
          "Ecirc",
          "Euml",
          "Igrave",
          "Iacute",
          "Icirc",
          "Iuml",
          "ETH",
          "Ntilde",
          "Ograve",
          "Oacute",
          "Ocirc",
          "Otilde",
          "Ouml",
          "times",
          "Oslash",
          "Ugrave",
          "Uacute",
          "Ucirc",
          "Uuml",
          "Yacute",
          "THORN",
          "szlig",
          "agrave",
          "aacute",
          "acirc",
          "atilde",
          "auml",
          "aring",
          "aelig",
          "ccedil",
          "egrave",
          "eacute",
          "ecirc",
          "euml",
          "igrave",
          "iacute",
          "icirc",
          "iuml",
          "eth",
          "ntilde",
          "ograve",
          "oacute",
          "ocirc",
          "otilde",
          "ouml",
          "divide",
          "oslash",
          "ugrave",
          "uacute",
          "ucirc",
          "uuml",
          "yacute",
          "thorn",
          "yuml",
          "quot",
          "amp",
          "lt",
          "gt",
          "OElig",
          "oelig",
          "Scaron",
          "scaron",
          "Yuml",
          "circ",
          "tilde",
          "ensp",
          "emsp",
          "thinsp",
          "zwnj",
          "zwj",
          "lrm",
          "rlm",
          "ndash",
          "mdash",
          "lsquo",
          "rsquo",
          "sbquo",
          "ldquo",
          "rdquo",
          "bdquo",
          "dagger",
          "Dagger",
          "permil",
          "lsaquo",
          "rsaquo",
          "euro",
          "fnof",
          "Alpha",
          "Beta",
          "Gamma",
          "Delta",
          "Epsilon",
          "Zeta",
          "Eta",
          "Theta",
          "Iota",
          "Kappa",
          "Lambda",
          "Mu",
          "Nu",
          "Xi",
          "Omicron",
          "Pi",
          "Rho",
          "Sigma",
          "Tau",
          "Upsilon",
          "Phi",
          "Chi",
          "Psi",
          "Omega",
          "alpha",
          "beta",
          "gamma",
          "delta",
          "epsilon",
          "zeta",
          "eta",
          "theta",
          "iota",
          "kappa",
          "lambda",
          "mu",
          "nu",
          "xi",
          "omicron",
          "pi",
          "rho",
          "sigmaf",
          "sigma",
          "tau",
          "upsilon",
          "phi",
          "chi",
          "psi",
          "omega",
          "thetasym",
          "upsih",
          "piv",
          "bull",
          "hellip",
          "prime",
          "Prime",
          "oline",
          "frasl",
          "weierp",
          "image",
          "real",
          "trade",
          "alefsym",
          "larr",
          "uarr",
          "rarr",
          "darr",
          "harr",
          "crarr",
          "lArr",
          "uArr",
          "rArr",
          "dArr",
          "hArr",
          "forall",
          "part",
          "exist",
          "empty",
          "nabla",
          "isin",
          "notin",
          "ni",
          "prod",
          "sum",
          "minus",
          "lowast",
          "radic",
          "prop",
          "infin",
          "ang",
          "and",
          "or",
          "cap",
          "cup",
          "int",
          "there4",
          "sim",
          "cong",
          "asymp",
          "ne",
          "equiv",
          "le",
          "ge",
          "sub",
          "sup",
          "nsub",
          "sube",
          "supe",
          "oplus",
          "otimes",
          "perp",
          "sdot",
          "lceil",
          "rceil",
          "lfloor",
          "rfloor",
          "lang",
          "rang",
          "loz",
          "spades",
          "clubs",
          "hearts",
          "diams",
        ];
        var HTML_CODES = [
          39,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          174,
          175,
          176,
          177,
          178,
          179,
          180,
          181,
          182,
          183,
          184,
          185,
          186,
          187,
          188,
          189,
          190,
          191,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255,
          34,
          38,
          60,
          62,
          338,
          339,
          352,
          353,
          376,
          710,
          732,
          8194,
          8195,
          8201,
          8204,
          8205,
          8206,
          8207,
          8211,
          8212,
          8216,
          8217,
          8218,
          8220,
          8221,
          8222,
          8224,
          8225,
          8240,
          8249,
          8250,
          8364,
          402,
          913,
          914,
          915,
          916,
          917,
          918,
          919,
          920,
          921,
          922,
          923,
          924,
          925,
          926,
          927,
          928,
          929,
          931,
          932,
          933,
          934,
          935,
          936,
          937,
          945,
          946,
          947,
          948,
          949,
          950,
          951,
          952,
          953,
          954,
          955,
          956,
          957,
          958,
          959,
          960,
          961,
          962,
          963,
          964,
          965,
          966,
          967,
          968,
          969,
          977,
          978,
          982,
          8226,
          8230,
          8242,
          8243,
          8254,
          8260,
          8472,
          8465,
          8476,
          8482,
          8501,
          8592,
          8593,
          8594,
          8595,
          8596,
          8629,
          8656,
          8657,
          8658,
          8659,
          8660,
          8704,
          8706,
          8707,
          8709,
          8711,
          8712,
          8713,
          8715,
          8719,
          8721,
          8722,
          8727,
          8730,
          8733,
          8734,
          8736,
          8743,
          8744,
          8745,
          8746,
          8747,
          8756,
          8764,
          8773,
          8776,
          8800,
          8801,
          8804,
          8805,
          8834,
          8835,
          8836,
          8838,
          8839,
          8853,
          8855,
          8869,
          8901,
          8968,
          8969,
          8970,
          8971,
          9001,
          9002,
          9674,
          9824,
          9827,
          9829,
          9830,
        ];
        var alphaIndex = {};
        var numIndex = {};
        (function () {
          var i = 0;
          var length = HTML_ALPHA.length;
          while (i < length) {
            var a = HTML_ALPHA[i];
            var c = HTML_CODES[i];
            alphaIndex[a] = String.fromCharCode(c);
            numIndex[c] = a;
            i++;
          }
        })();
        var Html4Entities = /** @class */ (function () {
          function Html4Entities() {}
          Html4Entities.prototype.decode = function (str) {
            if (!str || !str.length) {
              return "";
            }
            return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
              var chr;
              if (entity.charAt(0) === "#") {
                var code =
                  entity.charAt(1).toLowerCase() === "x"
                    ? parseInt(entity.substr(2), 16)
                    : parseInt(entity.substr(1));
                if (!(isNaN(code) || code < -32768 || code > 65535)) {
                  chr = String.fromCharCode(code);
                }
              } else {
                chr = alphaIndex[entity];
              }
              return chr || s;
            });
          };
          Html4Entities.decode = function (str) {
            return new Html4Entities().decode(str);
          };
          Html4Entities.prototype.encode = function (str) {
            if (!str || !str.length) {
              return "";
            }
            var strLength = str.length;
            var result = "";
            var i = 0;
            while (i < strLength) {
              var alpha = numIndex[str.charCodeAt(i)];
              result += alpha ? "&" + alpha + ";" : str.charAt(i);
              i++;
            }
            return result;
          };
          Html4Entities.encode = function (str) {
            return new Html4Entities().encode(str);
          };
          Html4Entities.prototype.encodeNonUTF = function (str) {
            if (!str || !str.length) {
              return "";
            }
            var strLength = str.length;
            var result = "";
            var i = 0;
            while (i < strLength) {
              var cc = str.charCodeAt(i);
              var alpha = numIndex[cc];
              if (alpha) {
                result += "&" + alpha + ";";
              } else if (cc < 32 || cc > 126) {
                result += "&#" + cc + ";";
              } else {
                result += str.charAt(i);
              }
              i++;
            }
            return result;
          };
          Html4Entities.encodeNonUTF = function (str) {
            return new Html4Entities().encodeNonUTF(str);
          };
          Html4Entities.prototype.encodeNonASCII = function (str) {
            if (!str || !str.length) {
              return "";
            }
            var strLength = str.length;
            var result = "";
            var i = 0;
            while (i < strLength) {
              var c = str.charCodeAt(i);
              if (c <= 255) {
                result += str[i++];
                continue;
              }
              result += "&#" + c + ";";
              i++;
            }
            return result;
          };
          Html4Entities.encodeNonASCII = function (str) {
            return new Html4Entities().encodeNonASCII(str);
          };
          return Html4Entities;
        })();
        exports.Html4Entities = Html4Entities;
      },
      {},
    ],
    58: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ENTITIES = [
          ["Aacute", [193]],
          ["aacute", [225]],
          ["Abreve", [258]],
          ["abreve", [259]],
          ["ac", [8766]],
          ["acd", [8767]],
          ["acE", [8766, 819]],
          ["Acirc", [194]],
          ["acirc", [226]],
          ["acute", [180]],
          ["Acy", [1040]],
          ["acy", [1072]],
          ["AElig", [198]],
          ["aelig", [230]],
          ["af", [8289]],
          ["Afr", [120068]],
          ["afr", [120094]],
          ["Agrave", [192]],
          ["agrave", [224]],
          ["alefsym", [8501]],
          ["aleph", [8501]],
          ["Alpha", [913]],
          ["alpha", [945]],
          ["Amacr", [256]],
          ["amacr", [257]],
          ["amalg", [10815]],
          ["amp", [38]],
          ["AMP", [38]],
          ["andand", [10837]],
          ["And", [10835]],
          ["and", [8743]],
          ["andd", [10844]],
          ["andslope", [10840]],
          ["andv", [10842]],
          ["ang", [8736]],
          ["ange", [10660]],
          ["angle", [8736]],
          ["angmsdaa", [10664]],
          ["angmsdab", [10665]],
          ["angmsdac", [10666]],
          ["angmsdad", [10667]],
          ["angmsdae", [10668]],
          ["angmsdaf", [10669]],
          ["angmsdag", [10670]],
          ["angmsdah", [10671]],
          ["angmsd", [8737]],
          ["angrt", [8735]],
          ["angrtvb", [8894]],
          ["angrtvbd", [10653]],
          ["angsph", [8738]],
          ["angst", [197]],
          ["angzarr", [9084]],
          ["Aogon", [260]],
          ["aogon", [261]],
          ["Aopf", [120120]],
          ["aopf", [120146]],
          ["apacir", [10863]],
          ["ap", [8776]],
          ["apE", [10864]],
          ["ape", [8778]],
          ["apid", [8779]],
          ["apos", [39]],
          ["ApplyFunction", [8289]],
          ["approx", [8776]],
          ["approxeq", [8778]],
          ["Aring", [197]],
          ["aring", [229]],
          ["Ascr", [119964]],
          ["ascr", [119990]],
          ["Assign", [8788]],
          ["ast", [42]],
          ["asymp", [8776]],
          ["asympeq", [8781]],
          ["Atilde", [195]],
          ["atilde", [227]],
          ["Auml", [196]],
          ["auml", [228]],
          ["awconint", [8755]],
          ["awint", [10769]],
          ["backcong", [8780]],
          ["backepsilon", [1014]],
          ["backprime", [8245]],
          ["backsim", [8765]],
          ["backsimeq", [8909]],
          ["Backslash", [8726]],
          ["Barv", [10983]],
          ["barvee", [8893]],
          ["barwed", [8965]],
          ["Barwed", [8966]],
          ["barwedge", [8965]],
          ["bbrk", [9141]],
          ["bbrktbrk", [9142]],
          ["bcong", [8780]],
          ["Bcy", [1041]],
          ["bcy", [1073]],
          ["bdquo", [8222]],
          ["becaus", [8757]],
          ["because", [8757]],
          ["Because", [8757]],
          ["bemptyv", [10672]],
          ["bepsi", [1014]],
          ["bernou", [8492]],
          ["Bernoullis", [8492]],
          ["Beta", [914]],
          ["beta", [946]],
          ["beth", [8502]],
          ["between", [8812]],
          ["Bfr", [120069]],
          ["bfr", [120095]],
          ["bigcap", [8898]],
          ["bigcirc", [9711]],
          ["bigcup", [8899]],
          ["bigodot", [10752]],
          ["bigoplus", [10753]],
          ["bigotimes", [10754]],
          ["bigsqcup", [10758]],
          ["bigstar", [9733]],
          ["bigtriangledown", [9661]],
          ["bigtriangleup", [9651]],
          ["biguplus", [10756]],
          ["bigvee", [8897]],
          ["bigwedge", [8896]],
          ["bkarow", [10509]],
          ["blacklozenge", [10731]],
          ["blacksquare", [9642]],
          ["blacktriangle", [9652]],
          ["blacktriangledown", [9662]],
          ["blacktriangleleft", [9666]],
          ["blacktriangleright", [9656]],
          ["blank", [9251]],
          ["blk12", [9618]],
          ["blk14", [9617]],
          ["blk34", [9619]],
          ["block", [9608]],
          ["bne", [61, 8421]],
          ["bnequiv", [8801, 8421]],
          ["bNot", [10989]],
          ["bnot", [8976]],
          ["Bopf", [120121]],
          ["bopf", [120147]],
          ["bot", [8869]],
          ["bottom", [8869]],
          ["bowtie", [8904]],
          ["boxbox", [10697]],
          ["boxdl", [9488]],
          ["boxdL", [9557]],
          ["boxDl", [9558]],
          ["boxDL", [9559]],
          ["boxdr", [9484]],
          ["boxdR", [9554]],
          ["boxDr", [9555]],
          ["boxDR", [9556]],
          ["boxh", [9472]],
          ["boxH", [9552]],
          ["boxhd", [9516]],
          ["boxHd", [9572]],
          ["boxhD", [9573]],
          ["boxHD", [9574]],
          ["boxhu", [9524]],
          ["boxHu", [9575]],
          ["boxhU", [9576]],
          ["boxHU", [9577]],
          ["boxminus", [8863]],
          ["boxplus", [8862]],
          ["boxtimes", [8864]],
          ["boxul", [9496]],
          ["boxuL", [9563]],
          ["boxUl", [9564]],
          ["boxUL", [9565]],
          ["boxur", [9492]],
          ["boxuR", [9560]],
          ["boxUr", [9561]],
          ["boxUR", [9562]],
          ["boxv", [9474]],
          ["boxV", [9553]],
          ["boxvh", [9532]],
          ["boxvH", [9578]],
          ["boxVh", [9579]],
          ["boxVH", [9580]],
          ["boxvl", [9508]],
          ["boxvL", [9569]],
          ["boxVl", [9570]],
          ["boxVL", [9571]],
          ["boxvr", [9500]],
          ["boxvR", [9566]],
          ["boxVr", [9567]],
          ["boxVR", [9568]],
          ["bprime", [8245]],
          ["breve", [728]],
          ["Breve", [728]],
          ["brvbar", [166]],
          ["bscr", [119991]],
          ["Bscr", [8492]],
          ["bsemi", [8271]],
          ["bsim", [8765]],
          ["bsime", [8909]],
          ["bsolb", [10693]],
          ["bsol", [92]],
          ["bsolhsub", [10184]],
          ["bull", [8226]],
          ["bullet", [8226]],
          ["bump", [8782]],
          ["bumpE", [10926]],
          ["bumpe", [8783]],
          ["Bumpeq", [8782]],
          ["bumpeq", [8783]],
          ["Cacute", [262]],
          ["cacute", [263]],
          ["capand", [10820]],
          ["capbrcup", [10825]],
          ["capcap", [10827]],
          ["cap", [8745]],
          ["Cap", [8914]],
          ["capcup", [10823]],
          ["capdot", [10816]],
          ["CapitalDifferentialD", [8517]],
          ["caps", [8745, 65024]],
          ["caret", [8257]],
          ["caron", [711]],
          ["Cayleys", [8493]],
          ["ccaps", [10829]],
          ["Ccaron", [268]],
          ["ccaron", [269]],
          ["Ccedil", [199]],
          ["ccedil", [231]],
          ["Ccirc", [264]],
          ["ccirc", [265]],
          ["Cconint", [8752]],
          ["ccups", [10828]],
          ["ccupssm", [10832]],
          ["Cdot", [266]],
          ["cdot", [267]],
          ["cedil", [184]],
          ["Cedilla", [184]],
          ["cemptyv", [10674]],
          ["cent", [162]],
          ["centerdot", [183]],
          ["CenterDot", [183]],
          ["cfr", [120096]],
          ["Cfr", [8493]],
          ["CHcy", [1063]],
          ["chcy", [1095]],
          ["check", [10003]],
          ["checkmark", [10003]],
          ["Chi", [935]],
          ["chi", [967]],
          ["circ", [710]],
          ["circeq", [8791]],
          ["circlearrowleft", [8634]],
          ["circlearrowright", [8635]],
          ["circledast", [8859]],
          ["circledcirc", [8858]],
          ["circleddash", [8861]],
          ["CircleDot", [8857]],
          ["circledR", [174]],
          ["circledS", [9416]],
          ["CircleMinus", [8854]],
          ["CirclePlus", [8853]],
          ["CircleTimes", [8855]],
          ["cir", [9675]],
          ["cirE", [10691]],
          ["cire", [8791]],
          ["cirfnint", [10768]],
          ["cirmid", [10991]],
          ["cirscir", [10690]],
          ["ClockwiseContourIntegral", [8754]],
          ["clubs", [9827]],
          ["clubsuit", [9827]],
          ["colon", [58]],
          ["Colon", [8759]],
          ["Colone", [10868]],
          ["colone", [8788]],
          ["coloneq", [8788]],
          ["comma", [44]],
          ["commat", [64]],
          ["comp", [8705]],
          ["compfn", [8728]],
          ["complement", [8705]],
          ["complexes", [8450]],
          ["cong", [8773]],
          ["congdot", [10861]],
          ["Congruent", [8801]],
          ["conint", [8750]],
          ["Conint", [8751]],
          ["ContourIntegral", [8750]],
          ["copf", [120148]],
          ["Copf", [8450]],
          ["coprod", [8720]],
          ["Coproduct", [8720]],
          ["copy", [169]],
          ["COPY", [169]],
          ["copysr", [8471]],
          ["CounterClockwiseContourIntegral", [8755]],
          ["crarr", [8629]],
          ["cross", [10007]],
          ["Cross", [10799]],
          ["Cscr", [119966]],
          ["cscr", [119992]],
          ["csub", [10959]],
          ["csube", [10961]],
          ["csup", [10960]],
          ["csupe", [10962]],
          ["ctdot", [8943]],
          ["cudarrl", [10552]],
          ["cudarrr", [10549]],
          ["cuepr", [8926]],
          ["cuesc", [8927]],
          ["cularr", [8630]],
          ["cularrp", [10557]],
          ["cupbrcap", [10824]],
          ["cupcap", [10822]],
          ["CupCap", [8781]],
          ["cup", [8746]],
          ["Cup", [8915]],
          ["cupcup", [10826]],
          ["cupdot", [8845]],
          ["cupor", [10821]],
          ["cups", [8746, 65024]],
          ["curarr", [8631]],
          ["curarrm", [10556]],
          ["curlyeqprec", [8926]],
          ["curlyeqsucc", [8927]],
          ["curlyvee", [8910]],
          ["curlywedge", [8911]],
          ["curren", [164]],
          ["curvearrowleft", [8630]],
          ["curvearrowright", [8631]],
          ["cuvee", [8910]],
          ["cuwed", [8911]],
          ["cwconint", [8754]],
          ["cwint", [8753]],
          ["cylcty", [9005]],
          ["dagger", [8224]],
          ["Dagger", [8225]],
          ["daleth", [8504]],
          ["darr", [8595]],
          ["Darr", [8609]],
          ["dArr", [8659]],
          ["dash", [8208]],
          ["Dashv", [10980]],
          ["dashv", [8867]],
          ["dbkarow", [10511]],
          ["dblac", [733]],
          ["Dcaron", [270]],
          ["dcaron", [271]],
          ["Dcy", [1044]],
          ["dcy", [1076]],
          ["ddagger", [8225]],
          ["ddarr", [8650]],
          ["DD", [8517]],
          ["dd", [8518]],
          ["DDotrahd", [10513]],
          ["ddotseq", [10871]],
          ["deg", [176]],
          ["Del", [8711]],
          ["Delta", [916]],
          ["delta", [948]],
          ["demptyv", [10673]],
          ["dfisht", [10623]],
          ["Dfr", [120071]],
          ["dfr", [120097]],
          ["dHar", [10597]],
          ["dharl", [8643]],
          ["dharr", [8642]],
          ["DiacriticalAcute", [180]],
          ["DiacriticalDot", [729]],
          ["DiacriticalDoubleAcute", [733]],
          ["DiacriticalGrave", [96]],
          ["DiacriticalTilde", [732]],
          ["diam", [8900]],
          ["diamond", [8900]],
          ["Diamond", [8900]],
          ["diamondsuit", [9830]],
          ["diams", [9830]],
          ["die", [168]],
          ["DifferentialD", [8518]],
          ["digamma", [989]],
          ["disin", [8946]],
          ["div", [247]],
          ["divide", [247]],
          ["divideontimes", [8903]],
          ["divonx", [8903]],
          ["DJcy", [1026]],
          ["djcy", [1106]],
          ["dlcorn", [8990]],
          ["dlcrop", [8973]],
          ["dollar", [36]],
          ["Dopf", [120123]],
          ["dopf", [120149]],
          ["Dot", [168]],
          ["dot", [729]],
          ["DotDot", [8412]],
          ["doteq", [8784]],
          ["doteqdot", [8785]],
          ["DotEqual", [8784]],
          ["dotminus", [8760]],
          ["dotplus", [8724]],
          ["dotsquare", [8865]],
          ["doublebarwedge", [8966]],
          ["DoubleContourIntegral", [8751]],
          ["DoubleDot", [168]],
          ["DoubleDownArrow", [8659]],
          ["DoubleLeftArrow", [8656]],
          ["DoubleLeftRightArrow", [8660]],
          ["DoubleLeftTee", [10980]],
          ["DoubleLongLeftArrow", [10232]],
          ["DoubleLongLeftRightArrow", [10234]],
          ["DoubleLongRightArrow", [10233]],
          ["DoubleRightArrow", [8658]],
          ["DoubleRightTee", [8872]],
          ["DoubleUpArrow", [8657]],
          ["DoubleUpDownArrow", [8661]],
          ["DoubleVerticalBar", [8741]],
          ["DownArrowBar", [10515]],
          ["downarrow", [8595]],
          ["DownArrow", [8595]],
          ["Downarrow", [8659]],
          ["DownArrowUpArrow", [8693]],
          ["DownBreve", [785]],
          ["downdownarrows", [8650]],
          ["downharpoonleft", [8643]],
          ["downharpoonright", [8642]],
          ["DownLeftRightVector", [10576]],
          ["DownLeftTeeVector", [10590]],
          ["DownLeftVectorBar", [10582]],
          ["DownLeftVector", [8637]],
          ["DownRightTeeVector", [10591]],
          ["DownRightVectorBar", [10583]],
          ["DownRightVector", [8641]],
          ["DownTeeArrow", [8615]],
          ["DownTee", [8868]],
          ["drbkarow", [10512]],
          ["drcorn", [8991]],
          ["drcrop", [8972]],
          ["Dscr", [119967]],
          ["dscr", [119993]],
          ["DScy", [1029]],
          ["dscy", [1109]],
          ["dsol", [10742]],
          ["Dstrok", [272]],
          ["dstrok", [273]],
          ["dtdot", [8945]],
          ["dtri", [9663]],
          ["dtrif", [9662]],
          ["duarr", [8693]],
          ["duhar", [10607]],
          ["dwangle", [10662]],
          ["DZcy", [1039]],
          ["dzcy", [1119]],
          ["dzigrarr", [10239]],
          ["Eacute", [201]],
          ["eacute", [233]],
          ["easter", [10862]],
          ["Ecaron", [282]],
          ["ecaron", [283]],
          ["Ecirc", [202]],
          ["ecirc", [234]],
          ["ecir", [8790]],
          ["ecolon", [8789]],
          ["Ecy", [1069]],
          ["ecy", [1101]],
          ["eDDot", [10871]],
          ["Edot", [278]],
          ["edot", [279]],
          ["eDot", [8785]],
          ["ee", [8519]],
          ["efDot", [8786]],
          ["Efr", [120072]],
          ["efr", [120098]],
          ["eg", [10906]],
          ["Egrave", [200]],
          ["egrave", [232]],
          ["egs", [10902]],
          ["egsdot", [10904]],
          ["el", [10905]],
          ["Element", [8712]],
          ["elinters", [9191]],
          ["ell", [8467]],
          ["els", [10901]],
          ["elsdot", [10903]],
          ["Emacr", [274]],
          ["emacr", [275]],
          ["empty", [8709]],
          ["emptyset", [8709]],
          ["EmptySmallSquare", [9723]],
          ["emptyv", [8709]],
          ["EmptyVerySmallSquare", [9643]],
          ["emsp13", [8196]],
          ["emsp14", [8197]],
          ["emsp", [8195]],
          ["ENG", [330]],
          ["eng", [331]],
          ["ensp", [8194]],
          ["Eogon", [280]],
          ["eogon", [281]],
          ["Eopf", [120124]],
          ["eopf", [120150]],
          ["epar", [8917]],
          ["eparsl", [10723]],
          ["eplus", [10865]],
          ["epsi", [949]],
          ["Epsilon", [917]],
          ["epsilon", [949]],
          ["epsiv", [1013]],
          ["eqcirc", [8790]],
          ["eqcolon", [8789]],
          ["eqsim", [8770]],
          ["eqslantgtr", [10902]],
          ["eqslantless", [10901]],
          ["Equal", [10869]],
          ["equals", [61]],
          ["EqualTilde", [8770]],
          ["equest", [8799]],
          ["Equilibrium", [8652]],
          ["equiv", [8801]],
          ["equivDD", [10872]],
          ["eqvparsl", [10725]],
          ["erarr", [10609]],
          ["erDot", [8787]],
          ["escr", [8495]],
          ["Escr", [8496]],
          ["esdot", [8784]],
          ["Esim", [10867]],
          ["esim", [8770]],
          ["Eta", [919]],
          ["eta", [951]],
          ["ETH", [208]],
          ["eth", [240]],
          ["Euml", [203]],
          ["euml", [235]],
          ["euro", [8364]],
          ["excl", [33]],
          ["exist", [8707]],
          ["Exists", [8707]],
          ["expectation", [8496]],
          ["exponentiale", [8519]],
          ["ExponentialE", [8519]],
          ["fallingdotseq", [8786]],
          ["Fcy", [1060]],
          ["fcy", [1092]],
          ["female", [9792]],
          ["ffilig", [64259]],
          ["fflig", [64256]],
          ["ffllig", [64260]],
          ["Ffr", [120073]],
          ["ffr", [120099]],
          ["filig", [64257]],
          ["FilledSmallSquare", [9724]],
          ["FilledVerySmallSquare", [9642]],
          ["fjlig", [102, 106]],
          ["flat", [9837]],
          ["fllig", [64258]],
          ["fltns", [9649]],
          ["fnof", [402]],
          ["Fopf", [120125]],
          ["fopf", [120151]],
          ["forall", [8704]],
          ["ForAll", [8704]],
          ["fork", [8916]],
          ["forkv", [10969]],
          ["Fouriertrf", [8497]],
          ["fpartint", [10765]],
          ["frac12", [189]],
          ["frac13", [8531]],
          ["frac14", [188]],
          ["frac15", [8533]],
          ["frac16", [8537]],
          ["frac18", [8539]],
          ["frac23", [8532]],
          ["frac25", [8534]],
          ["frac34", [190]],
          ["frac35", [8535]],
          ["frac38", [8540]],
          ["frac45", [8536]],
          ["frac56", [8538]],
          ["frac58", [8541]],
          ["frac78", [8542]],
          ["frasl", [8260]],
          ["frown", [8994]],
          ["fscr", [119995]],
          ["Fscr", [8497]],
          ["gacute", [501]],
          ["Gamma", [915]],
          ["gamma", [947]],
          ["Gammad", [988]],
          ["gammad", [989]],
          ["gap", [10886]],
          ["Gbreve", [286]],
          ["gbreve", [287]],
          ["Gcedil", [290]],
          ["Gcirc", [284]],
          ["gcirc", [285]],
          ["Gcy", [1043]],
          ["gcy", [1075]],
          ["Gdot", [288]],
          ["gdot", [289]],
          ["ge", [8805]],
          ["gE", [8807]],
          ["gEl", [10892]],
          ["gel", [8923]],
          ["geq", [8805]],
          ["geqq", [8807]],
          ["geqslant", [10878]],
          ["gescc", [10921]],
          ["ges", [10878]],
          ["gesdot", [10880]],
          ["gesdoto", [10882]],
          ["gesdotol", [10884]],
          ["gesl", [8923, 65024]],
          ["gesles", [10900]],
          ["Gfr", [120074]],
          ["gfr", [120100]],
          ["gg", [8811]],
          ["Gg", [8921]],
          ["ggg", [8921]],
          ["gimel", [8503]],
          ["GJcy", [1027]],
          ["gjcy", [1107]],
          ["gla", [10917]],
          ["gl", [8823]],
          ["glE", [10898]],
          ["glj", [10916]],
          ["gnap", [10890]],
          ["gnapprox", [10890]],
          ["gne", [10888]],
          ["gnE", [8809]],
          ["gneq", [10888]],
          ["gneqq", [8809]],
          ["gnsim", [8935]],
          ["Gopf", [120126]],
          ["gopf", [120152]],
          ["grave", [96]],
          ["GreaterEqual", [8805]],
          ["GreaterEqualLess", [8923]],
          ["GreaterFullEqual", [8807]],
          ["GreaterGreater", [10914]],
          ["GreaterLess", [8823]],
          ["GreaterSlantEqual", [10878]],
          ["GreaterTilde", [8819]],
          ["Gscr", [119970]],
          ["gscr", [8458]],
          ["gsim", [8819]],
          ["gsime", [10894]],
          ["gsiml", [10896]],
          ["gtcc", [10919]],
          ["gtcir", [10874]],
          ["gt", [62]],
          ["GT", [62]],
          ["Gt", [8811]],
          ["gtdot", [8919]],
          ["gtlPar", [10645]],
          ["gtquest", [10876]],
          ["gtrapprox", [10886]],
          ["gtrarr", [10616]],
          ["gtrdot", [8919]],
          ["gtreqless", [8923]],
          ["gtreqqless", [10892]],
          ["gtrless", [8823]],
          ["gtrsim", [8819]],
          ["gvertneqq", [8809, 65024]],
          ["gvnE", [8809, 65024]],
          ["Hacek", [711]],
          ["hairsp", [8202]],
          ["half", [189]],
          ["hamilt", [8459]],
          ["HARDcy", [1066]],
          ["hardcy", [1098]],
          ["harrcir", [10568]],
          ["harr", [8596]],
          ["hArr", [8660]],
          ["harrw", [8621]],
          ["Hat", [94]],
          ["hbar", [8463]],
          ["Hcirc", [292]],
          ["hcirc", [293]],
          ["hearts", [9829]],
          ["heartsuit", [9829]],
          ["hellip", [8230]],
          ["hercon", [8889]],
          ["hfr", [120101]],
          ["Hfr", [8460]],
          ["HilbertSpace", [8459]],
          ["hksearow", [10533]],
          ["hkswarow", [10534]],
          ["hoarr", [8703]],
          ["homtht", [8763]],
          ["hookleftarrow", [8617]],
          ["hookrightarrow", [8618]],
          ["hopf", [120153]],
          ["Hopf", [8461]],
          ["horbar", [8213]],
          ["HorizontalLine", [9472]],
          ["hscr", [119997]],
          ["Hscr", [8459]],
          ["hslash", [8463]],
          ["Hstrok", [294]],
          ["hstrok", [295]],
          ["HumpDownHump", [8782]],
          ["HumpEqual", [8783]],
          ["hybull", [8259]],
          ["hyphen", [8208]],
          ["Iacute", [205]],
          ["iacute", [237]],
          ["ic", [8291]],
          ["Icirc", [206]],
          ["icirc", [238]],
          ["Icy", [1048]],
          ["icy", [1080]],
          ["Idot", [304]],
          ["IEcy", [1045]],
          ["iecy", [1077]],
          ["iexcl", [161]],
          ["iff", [8660]],
          ["ifr", [120102]],
          ["Ifr", [8465]],
          ["Igrave", [204]],
          ["igrave", [236]],
          ["ii", [8520]],
          ["iiiint", [10764]],
          ["iiint", [8749]],
          ["iinfin", [10716]],
          ["iiota", [8489]],
          ["IJlig", [306]],
          ["ijlig", [307]],
          ["Imacr", [298]],
          ["imacr", [299]],
          ["image", [8465]],
          ["ImaginaryI", [8520]],
          ["imagline", [8464]],
          ["imagpart", [8465]],
          ["imath", [305]],
          ["Im", [8465]],
          ["imof", [8887]],
          ["imped", [437]],
          ["Implies", [8658]],
          ["incare", [8453]],
          ["in", [8712]],
          ["infin", [8734]],
          ["infintie", [10717]],
          ["inodot", [305]],
          ["intcal", [8890]],
          ["int", [8747]],
          ["Int", [8748]],
          ["integers", [8484]],
          ["Integral", [8747]],
          ["intercal", [8890]],
          ["Intersection", [8898]],
          ["intlarhk", [10775]],
          ["intprod", [10812]],
          ["InvisibleComma", [8291]],
          ["InvisibleTimes", [8290]],
          ["IOcy", [1025]],
          ["iocy", [1105]],
          ["Iogon", [302]],
          ["iogon", [303]],
          ["Iopf", [120128]],
          ["iopf", [120154]],
          ["Iota", [921]],
          ["iota", [953]],
          ["iprod", [10812]],
          ["iquest", [191]],
          ["iscr", [119998]],
          ["Iscr", [8464]],
          ["isin", [8712]],
          ["isindot", [8949]],
          ["isinE", [8953]],
          ["isins", [8948]],
          ["isinsv", [8947]],
          ["isinv", [8712]],
          ["it", [8290]],
          ["Itilde", [296]],
          ["itilde", [297]],
          ["Iukcy", [1030]],
          ["iukcy", [1110]],
          ["Iuml", [207]],
          ["iuml", [239]],
          ["Jcirc", [308]],
          ["jcirc", [309]],
          ["Jcy", [1049]],
          ["jcy", [1081]],
          ["Jfr", [120077]],
          ["jfr", [120103]],
          ["jmath", [567]],
          ["Jopf", [120129]],
          ["jopf", [120155]],
          ["Jscr", [119973]],
          ["jscr", [119999]],
          ["Jsercy", [1032]],
          ["jsercy", [1112]],
          ["Jukcy", [1028]],
          ["jukcy", [1108]],
          ["Kappa", [922]],
          ["kappa", [954]],
          ["kappav", [1008]],
          ["Kcedil", [310]],
          ["kcedil", [311]],
          ["Kcy", [1050]],
          ["kcy", [1082]],
          ["Kfr", [120078]],
          ["kfr", [120104]],
          ["kgreen", [312]],
          ["KHcy", [1061]],
          ["khcy", [1093]],
          ["KJcy", [1036]],
          ["kjcy", [1116]],
          ["Kopf", [120130]],
          ["kopf", [120156]],
          ["Kscr", [119974]],
          ["kscr", [120000]],
          ["lAarr", [8666]],
          ["Lacute", [313]],
          ["lacute", [314]],
          ["laemptyv", [10676]],
          ["lagran", [8466]],
          ["Lambda", [923]],
          ["lambda", [955]],
          ["lang", [10216]],
          ["Lang", [10218]],
          ["langd", [10641]],
          ["langle", [10216]],
          ["lap", [10885]],
          ["Laplacetrf", [8466]],
          ["laquo", [171]],
          ["larrb", [8676]],
          ["larrbfs", [10527]],
          ["larr", [8592]],
          ["Larr", [8606]],
          ["lArr", [8656]],
          ["larrfs", [10525]],
          ["larrhk", [8617]],
          ["larrlp", [8619]],
          ["larrpl", [10553]],
          ["larrsim", [10611]],
          ["larrtl", [8610]],
          ["latail", [10521]],
          ["lAtail", [10523]],
          ["lat", [10923]],
          ["late", [10925]],
          ["lates", [10925, 65024]],
          ["lbarr", [10508]],
          ["lBarr", [10510]],
          ["lbbrk", [10098]],
          ["lbrace", [123]],
          ["lbrack", [91]],
          ["lbrke", [10635]],
          ["lbrksld", [10639]],
          ["lbrkslu", [10637]],
          ["Lcaron", [317]],
          ["lcaron", [318]],
          ["Lcedil", [315]],
          ["lcedil", [316]],
          ["lceil", [8968]],
          ["lcub", [123]],
          ["Lcy", [1051]],
          ["lcy", [1083]],
          ["ldca", [10550]],
          ["ldquo", [8220]],
          ["ldquor", [8222]],
          ["ldrdhar", [10599]],
          ["ldrushar", [10571]],
          ["ldsh", [8626]],
          ["le", [8804]],
          ["lE", [8806]],
          ["LeftAngleBracket", [10216]],
          ["LeftArrowBar", [8676]],
          ["leftarrow", [8592]],
          ["LeftArrow", [8592]],
          ["Leftarrow", [8656]],
          ["LeftArrowRightArrow", [8646]],
          ["leftarrowtail", [8610]],
          ["LeftCeiling", [8968]],
          ["LeftDoubleBracket", [10214]],
          ["LeftDownTeeVector", [10593]],
          ["LeftDownVectorBar", [10585]],
          ["LeftDownVector", [8643]],
          ["LeftFloor", [8970]],
          ["leftharpoondown", [8637]],
          ["leftharpoonup", [8636]],
          ["leftleftarrows", [8647]],
          ["leftrightarrow", [8596]],
          ["LeftRightArrow", [8596]],
          ["Leftrightarrow", [8660]],
          ["leftrightarrows", [8646]],
          ["leftrightharpoons", [8651]],
          ["leftrightsquigarrow", [8621]],
          ["LeftRightVector", [10574]],
          ["LeftTeeArrow", [8612]],
          ["LeftTee", [8867]],
          ["LeftTeeVector", [10586]],
          ["leftthreetimes", [8907]],
          ["LeftTriangleBar", [10703]],
          ["LeftTriangle", [8882]],
          ["LeftTriangleEqual", [8884]],
          ["LeftUpDownVector", [10577]],
          ["LeftUpTeeVector", [10592]],
          ["LeftUpVectorBar", [10584]],
          ["LeftUpVector", [8639]],
          ["LeftVectorBar", [10578]],
          ["LeftVector", [8636]],
          ["lEg", [10891]],
          ["leg", [8922]],
          ["leq", [8804]],
          ["leqq", [8806]],
          ["leqslant", [10877]],
          ["lescc", [10920]],
          ["les", [10877]],
          ["lesdot", [10879]],
          ["lesdoto", [10881]],
          ["lesdotor", [10883]],
          ["lesg", [8922, 65024]],
          ["lesges", [10899]],
          ["lessapprox", [10885]],
          ["lessdot", [8918]],
          ["lesseqgtr", [8922]],
          ["lesseqqgtr", [10891]],
          ["LessEqualGreater", [8922]],
          ["LessFullEqual", [8806]],
          ["LessGreater", [8822]],
          ["lessgtr", [8822]],
          ["LessLess", [10913]],
          ["lesssim", [8818]],
          ["LessSlantEqual", [10877]],
          ["LessTilde", [8818]],
          ["lfisht", [10620]],
          ["lfloor", [8970]],
          ["Lfr", [120079]],
          ["lfr", [120105]],
          ["lg", [8822]],
          ["lgE", [10897]],
          ["lHar", [10594]],
          ["lhard", [8637]],
          ["lharu", [8636]],
          ["lharul", [10602]],
          ["lhblk", [9604]],
          ["LJcy", [1033]],
          ["ljcy", [1113]],
          ["llarr", [8647]],
          ["ll", [8810]],
          ["Ll", [8920]],
          ["llcorner", [8990]],
          ["Lleftarrow", [8666]],
          ["llhard", [10603]],
          ["lltri", [9722]],
          ["Lmidot", [319]],
          ["lmidot", [320]],
          ["lmoustache", [9136]],
          ["lmoust", [9136]],
          ["lnap", [10889]],
          ["lnapprox", [10889]],
          ["lne", [10887]],
          ["lnE", [8808]],
          ["lneq", [10887]],
          ["lneqq", [8808]],
          ["lnsim", [8934]],
          ["loang", [10220]],
          ["loarr", [8701]],
          ["lobrk", [10214]],
          ["longleftarrow", [10229]],
          ["LongLeftArrow", [10229]],
          ["Longleftarrow", [10232]],
          ["longleftrightarrow", [10231]],
          ["LongLeftRightArrow", [10231]],
          ["Longleftrightarrow", [10234]],
          ["longmapsto", [10236]],
          ["longrightarrow", [10230]],
          ["LongRightArrow", [10230]],
          ["Longrightarrow", [10233]],
          ["looparrowleft", [8619]],
          ["looparrowright", [8620]],
          ["lopar", [10629]],
          ["Lopf", [120131]],
          ["lopf", [120157]],
          ["loplus", [10797]],
          ["lotimes", [10804]],
          ["lowast", [8727]],
          ["lowbar", [95]],
          ["LowerLeftArrow", [8601]],
          ["LowerRightArrow", [8600]],
          ["loz", [9674]],
          ["lozenge", [9674]],
          ["lozf", [10731]],
          ["lpar", [40]],
          ["lparlt", [10643]],
          ["lrarr", [8646]],
          ["lrcorner", [8991]],
          ["lrhar", [8651]],
          ["lrhard", [10605]],
          ["lrm", [8206]],
          ["lrtri", [8895]],
          ["lsaquo", [8249]],
          ["lscr", [120001]],
          ["Lscr", [8466]],
          ["lsh", [8624]],
          ["Lsh", [8624]],
          ["lsim", [8818]],
          ["lsime", [10893]],
          ["lsimg", [10895]],
          ["lsqb", [91]],
          ["lsquo", [8216]],
          ["lsquor", [8218]],
          ["Lstrok", [321]],
          ["lstrok", [322]],
          ["ltcc", [10918]],
          ["ltcir", [10873]],
          ["lt", [60]],
          ["LT", [60]],
          ["Lt", [8810]],
          ["ltdot", [8918]],
          ["lthree", [8907]],
          ["ltimes", [8905]],
          ["ltlarr", [10614]],
          ["ltquest", [10875]],
          ["ltri", [9667]],
          ["ltrie", [8884]],
          ["ltrif", [9666]],
          ["ltrPar", [10646]],
          ["lurdshar", [10570]],
          ["luruhar", [10598]],
          ["lvertneqq", [8808, 65024]],
          ["lvnE", [8808, 65024]],
          ["macr", [175]],
          ["male", [9794]],
          ["malt", [10016]],
          ["maltese", [10016]],
          ["Map", [10501]],
          ["map", [8614]],
          ["mapsto", [8614]],
          ["mapstodown", [8615]],
          ["mapstoleft", [8612]],
          ["mapstoup", [8613]],
          ["marker", [9646]],
          ["mcomma", [10793]],
          ["Mcy", [1052]],
          ["mcy", [1084]],
          ["mdash", [8212]],
          ["mDDot", [8762]],
          ["measuredangle", [8737]],
          ["MediumSpace", [8287]],
          ["Mellintrf", [8499]],
          ["Mfr", [120080]],
          ["mfr", [120106]],
          ["mho", [8487]],
          ["micro", [181]],
          ["midast", [42]],
          ["midcir", [10992]],
          ["mid", [8739]],
          ["middot", [183]],
          ["minusb", [8863]],
          ["minus", [8722]],
          ["minusd", [8760]],
          ["minusdu", [10794]],
          ["MinusPlus", [8723]],
          ["mlcp", [10971]],
          ["mldr", [8230]],
          ["mnplus", [8723]],
          ["models", [8871]],
          ["Mopf", [120132]],
          ["mopf", [120158]],
          ["mp", [8723]],
          ["mscr", [120002]],
          ["Mscr", [8499]],
          ["mstpos", [8766]],
          ["Mu", [924]],
          ["mu", [956]],
          ["multimap", [8888]],
          ["mumap", [8888]],
          ["nabla", [8711]],
          ["Nacute", [323]],
          ["nacute", [324]],
          ["nang", [8736, 8402]],
          ["nap", [8777]],
          ["napE", [10864, 824]],
          ["napid", [8779, 824]],
          ["napos", [329]],
          ["napprox", [8777]],
          ["natural", [9838]],
          ["naturals", [8469]],
          ["natur", [9838]],
          ["nbsp", [160]],
          ["nbump", [8782, 824]],
          ["nbumpe", [8783, 824]],
          ["ncap", [10819]],
          ["Ncaron", [327]],
          ["ncaron", [328]],
          ["Ncedil", [325]],
          ["ncedil", [326]],
          ["ncong", [8775]],
          ["ncongdot", [10861, 824]],
          ["ncup", [10818]],
          ["Ncy", [1053]],
          ["ncy", [1085]],
          ["ndash", [8211]],
          ["nearhk", [10532]],
          ["nearr", [8599]],
          ["neArr", [8663]],
          ["nearrow", [8599]],
          ["ne", [8800]],
          ["nedot", [8784, 824]],
          ["NegativeMediumSpace", [8203]],
          ["NegativeThickSpace", [8203]],
          ["NegativeThinSpace", [8203]],
          ["NegativeVeryThinSpace", [8203]],
          ["nequiv", [8802]],
          ["nesear", [10536]],
          ["nesim", [8770, 824]],
          ["NestedGreaterGreater", [8811]],
          ["NestedLessLess", [8810]],
          ["nexist", [8708]],
          ["nexists", [8708]],
          ["Nfr", [120081]],
          ["nfr", [120107]],
          ["ngE", [8807, 824]],
          ["nge", [8817]],
          ["ngeq", [8817]],
          ["ngeqq", [8807, 824]],
          ["ngeqslant", [10878, 824]],
          ["nges", [10878, 824]],
          ["nGg", [8921, 824]],
          ["ngsim", [8821]],
          ["nGt", [8811, 8402]],
          ["ngt", [8815]],
          ["ngtr", [8815]],
          ["nGtv", [8811, 824]],
          ["nharr", [8622]],
          ["nhArr", [8654]],
          ["nhpar", [10994]],
          ["ni", [8715]],
          ["nis", [8956]],
          ["nisd", [8954]],
          ["niv", [8715]],
          ["NJcy", [1034]],
          ["njcy", [1114]],
          ["nlarr", [8602]],
          ["nlArr", [8653]],
          ["nldr", [8229]],
          ["nlE", [8806, 824]],
          ["nle", [8816]],
          ["nleftarrow", [8602]],
          ["nLeftarrow", [8653]],
          ["nleftrightarrow", [8622]],
          ["nLeftrightarrow", [8654]],
          ["nleq", [8816]],
          ["nleqq", [8806, 824]],
          ["nleqslant", [10877, 824]],
          ["nles", [10877, 824]],
          ["nless", [8814]],
          ["nLl", [8920, 824]],
          ["nlsim", [8820]],
          ["nLt", [8810, 8402]],
          ["nlt", [8814]],
          ["nltri", [8938]],
          ["nltrie", [8940]],
          ["nLtv", [8810, 824]],
          ["nmid", [8740]],
          ["NoBreak", [8288]],
          ["NonBreakingSpace", [160]],
          ["nopf", [120159]],
          ["Nopf", [8469]],
          ["Not", [10988]],
          ["not", [172]],
          ["NotCongruent", [8802]],
          ["NotCupCap", [8813]],
          ["NotDoubleVerticalBar", [8742]],
          ["NotElement", [8713]],
          ["NotEqual", [8800]],
          ["NotEqualTilde", [8770, 824]],
          ["NotExists", [8708]],
          ["NotGreater", [8815]],
          ["NotGreaterEqual", [8817]],
          ["NotGreaterFullEqual", [8807, 824]],
          ["NotGreaterGreater", [8811, 824]],
          ["NotGreaterLess", [8825]],
          ["NotGreaterSlantEqual", [10878, 824]],
          ["NotGreaterTilde", [8821]],
          ["NotHumpDownHump", [8782, 824]],
          ["NotHumpEqual", [8783, 824]],
          ["notin", [8713]],
          ["notindot", [8949, 824]],
          ["notinE", [8953, 824]],
          ["notinva", [8713]],
          ["notinvb", [8951]],
          ["notinvc", [8950]],
          ["NotLeftTriangleBar", [10703, 824]],
          ["NotLeftTriangle", [8938]],
          ["NotLeftTriangleEqual", [8940]],
          ["NotLess", [8814]],
          ["NotLessEqual", [8816]],
          ["NotLessGreater", [8824]],
          ["NotLessLess", [8810, 824]],
          ["NotLessSlantEqual", [10877, 824]],
          ["NotLessTilde", [8820]],
          ["NotNestedGreaterGreater", [10914, 824]],
          ["NotNestedLessLess", [10913, 824]],
          ["notni", [8716]],
          ["notniva", [8716]],
          ["notnivb", [8958]],
          ["notnivc", [8957]],
          ["NotPrecedes", [8832]],
          ["NotPrecedesEqual", [10927, 824]],
          ["NotPrecedesSlantEqual", [8928]],
          ["NotReverseElement", [8716]],
          ["NotRightTriangleBar", [10704, 824]],
          ["NotRightTriangle", [8939]],
          ["NotRightTriangleEqual", [8941]],
          ["NotSquareSubset", [8847, 824]],
          ["NotSquareSubsetEqual", [8930]],
          ["NotSquareSuperset", [8848, 824]],
          ["NotSquareSupersetEqual", [8931]],
          ["NotSubset", [8834, 8402]],
          ["NotSubsetEqual", [8840]],
          ["NotSucceeds", [8833]],
          ["NotSucceedsEqual", [10928, 824]],
          ["NotSucceedsSlantEqual", [8929]],
          ["NotSucceedsTilde", [8831, 824]],
          ["NotSuperset", [8835, 8402]],
          ["NotSupersetEqual", [8841]],
          ["NotTilde", [8769]],
          ["NotTildeEqual", [8772]],
          ["NotTildeFullEqual", [8775]],
          ["NotTildeTilde", [8777]],
          ["NotVerticalBar", [8740]],
          ["nparallel", [8742]],
          ["npar", [8742]],
          ["nparsl", [11005, 8421]],
          ["npart", [8706, 824]],
          ["npolint", [10772]],
          ["npr", [8832]],
          ["nprcue", [8928]],
          ["nprec", [8832]],
          ["npreceq", [10927, 824]],
          ["npre", [10927, 824]],
          ["nrarrc", [10547, 824]],
          ["nrarr", [8603]],
          ["nrArr", [8655]],
          ["nrarrw", [8605, 824]],
          ["nrightarrow", [8603]],
          ["nRightarrow", [8655]],
          ["nrtri", [8939]],
          ["nrtrie", [8941]],
          ["nsc", [8833]],
          ["nsccue", [8929]],
          ["nsce", [10928, 824]],
          ["Nscr", [119977]],
          ["nscr", [120003]],
          ["nshortmid", [8740]],
          ["nshortparallel", [8742]],
          ["nsim", [8769]],
          ["nsime", [8772]],
          ["nsimeq", [8772]],
          ["nsmid", [8740]],
          ["nspar", [8742]],
          ["nsqsube", [8930]],
          ["nsqsupe", [8931]],
          ["nsub", [8836]],
          ["nsubE", [10949, 824]],
          ["nsube", [8840]],
          ["nsubset", [8834, 8402]],
          ["nsubseteq", [8840]],
          ["nsubseteqq", [10949, 824]],
          ["nsucc", [8833]],
          ["nsucceq", [10928, 824]],
          ["nsup", [8837]],
          ["nsupE", [10950, 824]],
          ["nsupe", [8841]],
          ["nsupset", [8835, 8402]],
          ["nsupseteq", [8841]],
          ["nsupseteqq", [10950, 824]],
          ["ntgl", [8825]],
          ["Ntilde", [209]],
          ["ntilde", [241]],
          ["ntlg", [8824]],
          ["ntriangleleft", [8938]],
          ["ntrianglelefteq", [8940]],
          ["ntriangleright", [8939]],
          ["ntrianglerighteq", [8941]],
          ["Nu", [925]],
          ["nu", [957]],
          ["num", [35]],
          ["numero", [8470]],
          ["numsp", [8199]],
          ["nvap", [8781, 8402]],
          ["nvdash", [8876]],
          ["nvDash", [8877]],
          ["nVdash", [8878]],
          ["nVDash", [8879]],
          ["nvge", [8805, 8402]],
          ["nvgt", [62, 8402]],
          ["nvHarr", [10500]],
          ["nvinfin", [10718]],
          ["nvlArr", [10498]],
          ["nvle", [8804, 8402]],
          ["nvlt", [60, 8402]],
          ["nvltrie", [8884, 8402]],
          ["nvrArr", [10499]],
          ["nvrtrie", [8885, 8402]],
          ["nvsim", [8764, 8402]],
          ["nwarhk", [10531]],
          ["nwarr", [8598]],
          ["nwArr", [8662]],
          ["nwarrow", [8598]],
          ["nwnear", [10535]],
          ["Oacute", [211]],
          ["oacute", [243]],
          ["oast", [8859]],
          ["Ocirc", [212]],
          ["ocirc", [244]],
          ["ocir", [8858]],
          ["Ocy", [1054]],
          ["ocy", [1086]],
          ["odash", [8861]],
          ["Odblac", [336]],
          ["odblac", [337]],
          ["odiv", [10808]],
          ["odot", [8857]],
          ["odsold", [10684]],
          ["OElig", [338]],
          ["oelig", [339]],
          ["ofcir", [10687]],
          ["Ofr", [120082]],
          ["ofr", [120108]],
          ["ogon", [731]],
          ["Ograve", [210]],
          ["ograve", [242]],
          ["ogt", [10689]],
          ["ohbar", [10677]],
          ["ohm", [937]],
          ["oint", [8750]],
          ["olarr", [8634]],
          ["olcir", [10686]],
          ["olcross", [10683]],
          ["oline", [8254]],
          ["olt", [10688]],
          ["Omacr", [332]],
          ["omacr", [333]],
          ["Omega", [937]],
          ["omega", [969]],
          ["Omicron", [927]],
          ["omicron", [959]],
          ["omid", [10678]],
          ["ominus", [8854]],
          ["Oopf", [120134]],
          ["oopf", [120160]],
          ["opar", [10679]],
          ["OpenCurlyDoubleQuote", [8220]],
          ["OpenCurlyQuote", [8216]],
          ["operp", [10681]],
          ["oplus", [8853]],
          ["orarr", [8635]],
          ["Or", [10836]],
          ["or", [8744]],
          ["ord", [10845]],
          ["order", [8500]],
          ["orderof", [8500]],
          ["ordf", [170]],
          ["ordm", [186]],
          ["origof", [8886]],
          ["oror", [10838]],
          ["orslope", [10839]],
          ["orv", [10843]],
          ["oS", [9416]],
          ["Oscr", [119978]],
          ["oscr", [8500]],
          ["Oslash", [216]],
          ["oslash", [248]],
          ["osol", [8856]],
          ["Otilde", [213]],
          ["otilde", [245]],
          ["otimesas", [10806]],
          ["Otimes", [10807]],
          ["otimes", [8855]],
          ["Ouml", [214]],
          ["ouml", [246]],
          ["ovbar", [9021]],
          ["OverBar", [8254]],
          ["OverBrace", [9182]],
          ["OverBracket", [9140]],
          ["OverParenthesis", [9180]],
          ["para", [182]],
          ["parallel", [8741]],
          ["par", [8741]],
          ["parsim", [10995]],
          ["parsl", [11005]],
          ["part", [8706]],
          ["PartialD", [8706]],
          ["Pcy", [1055]],
          ["pcy", [1087]],
          ["percnt", [37]],
          ["period", [46]],
          ["permil", [8240]],
          ["perp", [8869]],
          ["pertenk", [8241]],
          ["Pfr", [120083]],
          ["pfr", [120109]],
          ["Phi", [934]],
          ["phi", [966]],
          ["phiv", [981]],
          ["phmmat", [8499]],
          ["phone", [9742]],
          ["Pi", [928]],
          ["pi", [960]],
          ["pitchfork", [8916]],
          ["piv", [982]],
          ["planck", [8463]],
          ["planckh", [8462]],
          ["plankv", [8463]],
          ["plusacir", [10787]],
          ["plusb", [8862]],
          ["pluscir", [10786]],
          ["plus", [43]],
          ["plusdo", [8724]],
          ["plusdu", [10789]],
          ["pluse", [10866]],
          ["PlusMinus", [177]],
          ["plusmn", [177]],
          ["plussim", [10790]],
          ["plustwo", [10791]],
          ["pm", [177]],
          ["Poincareplane", [8460]],
          ["pointint", [10773]],
          ["popf", [120161]],
          ["Popf", [8473]],
          ["pound", [163]],
          ["prap", [10935]],
          ["Pr", [10939]],
          ["pr", [8826]],
          ["prcue", [8828]],
          ["precapprox", [10935]],
          ["prec", [8826]],
          ["preccurlyeq", [8828]],
          ["Precedes", [8826]],
          ["PrecedesEqual", [10927]],
          ["PrecedesSlantEqual", [8828]],
          ["PrecedesTilde", [8830]],
          ["preceq", [10927]],
          ["precnapprox", [10937]],
          ["precneqq", [10933]],
          ["precnsim", [8936]],
          ["pre", [10927]],
          ["prE", [10931]],
          ["precsim", [8830]],
          ["prime", [8242]],
          ["Prime", [8243]],
          ["primes", [8473]],
          ["prnap", [10937]],
          ["prnE", [10933]],
          ["prnsim", [8936]],
          ["prod", [8719]],
          ["Product", [8719]],
          ["profalar", [9006]],
          ["profline", [8978]],
          ["profsurf", [8979]],
          ["prop", [8733]],
          ["Proportional", [8733]],
          ["Proportion", [8759]],
          ["propto", [8733]],
          ["prsim", [8830]],
          ["prurel", [8880]],
          ["Pscr", [119979]],
          ["pscr", [120005]],
          ["Psi", [936]],
          ["psi", [968]],
          ["puncsp", [8200]],
          ["Qfr", [120084]],
          ["qfr", [120110]],
          ["qint", [10764]],
          ["qopf", [120162]],
          ["Qopf", [8474]],
          ["qprime", [8279]],
          ["Qscr", [119980]],
          ["qscr", [120006]],
          ["quaternions", [8461]],
          ["quatint", [10774]],
          ["quest", [63]],
          ["questeq", [8799]],
          ["quot", [34]],
          ["QUOT", [34]],
          ["rAarr", [8667]],
          ["race", [8765, 817]],
          ["Racute", [340]],
          ["racute", [341]],
          ["radic", [8730]],
          ["raemptyv", [10675]],
          ["rang", [10217]],
          ["Rang", [10219]],
          ["rangd", [10642]],
          ["range", [10661]],
          ["rangle", [10217]],
          ["raquo", [187]],
          ["rarrap", [10613]],
          ["rarrb", [8677]],
          ["rarrbfs", [10528]],
          ["rarrc", [10547]],
          ["rarr", [8594]],
          ["Rarr", [8608]],
          ["rArr", [8658]],
          ["rarrfs", [10526]],
          ["rarrhk", [8618]],
          ["rarrlp", [8620]],
          ["rarrpl", [10565]],
          ["rarrsim", [10612]],
          ["Rarrtl", [10518]],
          ["rarrtl", [8611]],
          ["rarrw", [8605]],
          ["ratail", [10522]],
          ["rAtail", [10524]],
          ["ratio", [8758]],
          ["rationals", [8474]],
          ["rbarr", [10509]],
          ["rBarr", [10511]],
          ["RBarr", [10512]],
          ["rbbrk", [10099]],
          ["rbrace", [125]],
          ["rbrack", [93]],
          ["rbrke", [10636]],
          ["rbrksld", [10638]],
          ["rbrkslu", [10640]],
          ["Rcaron", [344]],
          ["rcaron", [345]],
          ["Rcedil", [342]],
          ["rcedil", [343]],
          ["rceil", [8969]],
          ["rcub", [125]],
          ["Rcy", [1056]],
          ["rcy", [1088]],
          ["rdca", [10551]],
          ["rdldhar", [10601]],
          ["rdquo", [8221]],
          ["rdquor", [8221]],
          ["CloseCurlyDoubleQuote", [8221]],
          ["rdsh", [8627]],
          ["real", [8476]],
          ["realine", [8475]],
          ["realpart", [8476]],
          ["reals", [8477]],
          ["Re", [8476]],
          ["rect", [9645]],
          ["reg", [174]],
          ["REG", [174]],
          ["ReverseElement", [8715]],
          ["ReverseEquilibrium", [8651]],
          ["ReverseUpEquilibrium", [10607]],
          ["rfisht", [10621]],
          ["rfloor", [8971]],
          ["rfr", [120111]],
          ["Rfr", [8476]],
          ["rHar", [10596]],
          ["rhard", [8641]],
          ["rharu", [8640]],
          ["rharul", [10604]],
          ["Rho", [929]],
          ["rho", [961]],
          ["rhov", [1009]],
          ["RightAngleBracket", [10217]],
          ["RightArrowBar", [8677]],
          ["rightarrow", [8594]],
          ["RightArrow", [8594]],
          ["Rightarrow", [8658]],
          ["RightArrowLeftArrow", [8644]],
          ["rightarrowtail", [8611]],
          ["RightCeiling", [8969]],
          ["RightDoubleBracket", [10215]],
          ["RightDownTeeVector", [10589]],
          ["RightDownVectorBar", [10581]],
          ["RightDownVector", [8642]],
          ["RightFloor", [8971]],
          ["rightharpoondown", [8641]],
          ["rightharpoonup", [8640]],
          ["rightleftarrows", [8644]],
          ["rightleftharpoons", [8652]],
          ["rightrightarrows", [8649]],
          ["rightsquigarrow", [8605]],
          ["RightTeeArrow", [8614]],
          ["RightTee", [8866]],
          ["RightTeeVector", [10587]],
          ["rightthreetimes", [8908]],
          ["RightTriangleBar", [10704]],
          ["RightTriangle", [8883]],
          ["RightTriangleEqual", [8885]],
          ["RightUpDownVector", [10575]],
          ["RightUpTeeVector", [10588]],
          ["RightUpVectorBar", [10580]],
          ["RightUpVector", [8638]],
          ["RightVectorBar", [10579]],
          ["RightVector", [8640]],
          ["ring", [730]],
          ["risingdotseq", [8787]],
          ["rlarr", [8644]],
          ["rlhar", [8652]],
          ["rlm", [8207]],
          ["rmoustache", [9137]],
          ["rmoust", [9137]],
          ["rnmid", [10990]],
          ["roang", [10221]],
          ["roarr", [8702]],
          ["robrk", [10215]],
          ["ropar", [10630]],
          ["ropf", [120163]],
          ["Ropf", [8477]],
          ["roplus", [10798]],
          ["rotimes", [10805]],
          ["RoundImplies", [10608]],
          ["rpar", [41]],
          ["rpargt", [10644]],
          ["rppolint", [10770]],
          ["rrarr", [8649]],
          ["Rrightarrow", [8667]],
          ["rsaquo", [8250]],
          ["rscr", [120007]],
          ["Rscr", [8475]],
          ["rsh", [8625]],
          ["Rsh", [8625]],
          ["rsqb", [93]],
          ["rsquo", [8217]],
          ["rsquor", [8217]],
          ["CloseCurlyQuote", [8217]],
          ["rthree", [8908]],
          ["rtimes", [8906]],
          ["rtri", [9657]],
          ["rtrie", [8885]],
          ["rtrif", [9656]],
          ["rtriltri", [10702]],
          ["RuleDelayed", [10740]],
          ["ruluhar", [10600]],
          ["rx", [8478]],
          ["Sacute", [346]],
          ["sacute", [347]],
          ["sbquo", [8218]],
          ["scap", [10936]],
          ["Scaron", [352]],
          ["scaron", [353]],
          ["Sc", [10940]],
          ["sc", [8827]],
          ["sccue", [8829]],
          ["sce", [10928]],
          ["scE", [10932]],
          ["Scedil", [350]],
          ["scedil", [351]],
          ["Scirc", [348]],
          ["scirc", [349]],
          ["scnap", [10938]],
          ["scnE", [10934]],
          ["scnsim", [8937]],
          ["scpolint", [10771]],
          ["scsim", [8831]],
          ["Scy", [1057]],
          ["scy", [1089]],
          ["sdotb", [8865]],
          ["sdot", [8901]],
          ["sdote", [10854]],
          ["searhk", [10533]],
          ["searr", [8600]],
          ["seArr", [8664]],
          ["searrow", [8600]],
          ["sect", [167]],
          ["semi", [59]],
          ["seswar", [10537]],
          ["setminus", [8726]],
          ["setmn", [8726]],
          ["sext", [10038]],
          ["Sfr", [120086]],
          ["sfr", [120112]],
          ["sfrown", [8994]],
          ["sharp", [9839]],
          ["SHCHcy", [1065]],
          ["shchcy", [1097]],
          ["SHcy", [1064]],
          ["shcy", [1096]],
          ["ShortDownArrow", [8595]],
          ["ShortLeftArrow", [8592]],
          ["shortmid", [8739]],
          ["shortparallel", [8741]],
          ["ShortRightArrow", [8594]],
          ["ShortUpArrow", [8593]],
          ["shy", [173]],
          ["Sigma", [931]],
          ["sigma", [963]],
          ["sigmaf", [962]],
          ["sigmav", [962]],
          ["sim", [8764]],
          ["simdot", [10858]],
          ["sime", [8771]],
          ["simeq", [8771]],
          ["simg", [10910]],
          ["simgE", [10912]],
          ["siml", [10909]],
          ["simlE", [10911]],
          ["simne", [8774]],
          ["simplus", [10788]],
          ["simrarr", [10610]],
          ["slarr", [8592]],
          ["SmallCircle", [8728]],
          ["smallsetminus", [8726]],
          ["smashp", [10803]],
          ["smeparsl", [10724]],
          ["smid", [8739]],
          ["smile", [8995]],
          ["smt", [10922]],
          ["smte", [10924]],
          ["smtes", [10924, 65024]],
          ["SOFTcy", [1068]],
          ["softcy", [1100]],
          ["solbar", [9023]],
          ["solb", [10692]],
          ["sol", [47]],
          ["Sopf", [120138]],
          ["sopf", [120164]],
          ["spades", [9824]],
          ["spadesuit", [9824]],
          ["spar", [8741]],
          ["sqcap", [8851]],
          ["sqcaps", [8851, 65024]],
          ["sqcup", [8852]],
          ["sqcups", [8852, 65024]],
          ["Sqrt", [8730]],
          ["sqsub", [8847]],
          ["sqsube", [8849]],
          ["sqsubset", [8847]],
          ["sqsubseteq", [8849]],
          ["sqsup", [8848]],
          ["sqsupe", [8850]],
          ["sqsupset", [8848]],
          ["sqsupseteq", [8850]],
          ["square", [9633]],
          ["Square", [9633]],
          ["SquareIntersection", [8851]],
          ["SquareSubset", [8847]],
          ["SquareSubsetEqual", [8849]],
          ["SquareSuperset", [8848]],
          ["SquareSupersetEqual", [8850]],
          ["SquareUnion", [8852]],
          ["squarf", [9642]],
          ["squ", [9633]],
          ["squf", [9642]],
          ["srarr", [8594]],
          ["Sscr", [119982]],
          ["sscr", [120008]],
          ["ssetmn", [8726]],
          ["ssmile", [8995]],
          ["sstarf", [8902]],
          ["Star", [8902]],
          ["star", [9734]],
          ["starf", [9733]],
          ["straightepsilon", [1013]],
          ["straightphi", [981]],
          ["strns", [175]],
          ["sub", [8834]],
          ["Sub", [8912]],
          ["subdot", [10941]],
          ["subE", [10949]],
          ["sube", [8838]],
          ["subedot", [10947]],
          ["submult", [10945]],
          ["subnE", [10955]],
          ["subne", [8842]],
          ["subplus", [10943]],
          ["subrarr", [10617]],
          ["subset", [8834]],
          ["Subset", [8912]],
          ["subseteq", [8838]],
          ["subseteqq", [10949]],
          ["SubsetEqual", [8838]],
          ["subsetneq", [8842]],
          ["subsetneqq", [10955]],
          ["subsim", [10951]],
          ["subsub", [10965]],
          ["subsup", [10963]],
          ["succapprox", [10936]],
          ["succ", [8827]],
          ["succcurlyeq", [8829]],
          ["Succeeds", [8827]],
          ["SucceedsEqual", [10928]],
          ["SucceedsSlantEqual", [8829]],
          ["SucceedsTilde", [8831]],
          ["succeq", [10928]],
          ["succnapprox", [10938]],
          ["succneqq", [10934]],
          ["succnsim", [8937]],
          ["succsim", [8831]],
          ["SuchThat", [8715]],
          ["sum", [8721]],
          ["Sum", [8721]],
          ["sung", [9834]],
          ["sup1", [185]],
          ["sup2", [178]],
          ["sup3", [179]],
          ["sup", [8835]],
          ["Sup", [8913]],
          ["supdot", [10942]],
          ["supdsub", [10968]],
          ["supE", [10950]],
          ["supe", [8839]],
          ["supedot", [10948]],
          ["Superset", [8835]],
          ["SupersetEqual", [8839]],
          ["suphsol", [10185]],
          ["suphsub", [10967]],
          ["suplarr", [10619]],
          ["supmult", [10946]],
          ["supnE", [10956]],
          ["supne", [8843]],
          ["supplus", [10944]],
          ["supset", [8835]],
          ["Supset", [8913]],
          ["supseteq", [8839]],
          ["supseteqq", [10950]],
          ["supsetneq", [8843]],
          ["supsetneqq", [10956]],
          ["supsim", [10952]],
          ["supsub", [10964]],
          ["supsup", [10966]],
          ["swarhk", [10534]],
          ["swarr", [8601]],
          ["swArr", [8665]],
          ["swarrow", [8601]],
          ["swnwar", [10538]],
          ["szlig", [223]],
          ["Tab", [9]],
          ["target", [8982]],
          ["Tau", [932]],
          ["tau", [964]],
          ["tbrk", [9140]],
          ["Tcaron", [356]],
          ["tcaron", [357]],
          ["Tcedil", [354]],
          ["tcedil", [355]],
          ["Tcy", [1058]],
          ["tcy", [1090]],
          ["tdot", [8411]],
          ["telrec", [8981]],
          ["Tfr", [120087]],
          ["tfr", [120113]],
          ["there4", [8756]],
          ["therefore", [8756]],
          ["Therefore", [8756]],
          ["Theta", [920]],
          ["theta", [952]],
          ["thetasym", [977]],
          ["thetav", [977]],
          ["thickapprox", [8776]],
          ["thicksim", [8764]],
          ["ThickSpace", [8287, 8202]],
          ["ThinSpace", [8201]],
          ["thinsp", [8201]],
          ["thkap", [8776]],
          ["thksim", [8764]],
          ["THORN", [222]],
          ["thorn", [254]],
          ["tilde", [732]],
          ["Tilde", [8764]],
          ["TildeEqual", [8771]],
          ["TildeFullEqual", [8773]],
          ["TildeTilde", [8776]],
          ["timesbar", [10801]],
          ["timesb", [8864]],
          ["times", [215]],
          ["timesd", [10800]],
          ["tint", [8749]],
          ["toea", [10536]],
          ["topbot", [9014]],
          ["topcir", [10993]],
          ["top", [8868]],
          ["Topf", [120139]],
          ["topf", [120165]],
          ["topfork", [10970]],
          ["tosa", [10537]],
          ["tprime", [8244]],
          ["trade", [8482]],
          ["TRADE", [8482]],
          ["triangle", [9653]],
          ["triangledown", [9663]],
          ["triangleleft", [9667]],
          ["trianglelefteq", [8884]],
          ["triangleq", [8796]],
          ["triangleright", [9657]],
          ["trianglerighteq", [8885]],
          ["tridot", [9708]],
          ["trie", [8796]],
          ["triminus", [10810]],
          ["TripleDot", [8411]],
          ["triplus", [10809]],
          ["trisb", [10701]],
          ["tritime", [10811]],
          ["trpezium", [9186]],
          ["Tscr", [119983]],
          ["tscr", [120009]],
          ["TScy", [1062]],
          ["tscy", [1094]],
          ["TSHcy", [1035]],
          ["tshcy", [1115]],
          ["Tstrok", [358]],
          ["tstrok", [359]],
          ["twixt", [8812]],
          ["twoheadleftarrow", [8606]],
          ["twoheadrightarrow", [8608]],
          ["Uacute", [218]],
          ["uacute", [250]],
          ["uarr", [8593]],
          ["Uarr", [8607]],
          ["uArr", [8657]],
          ["Uarrocir", [10569]],
          ["Ubrcy", [1038]],
          ["ubrcy", [1118]],
          ["Ubreve", [364]],
          ["ubreve", [365]],
          ["Ucirc", [219]],
          ["ucirc", [251]],
          ["Ucy", [1059]],
          ["ucy", [1091]],
          ["udarr", [8645]],
          ["Udblac", [368]],
          ["udblac", [369]],
          ["udhar", [10606]],
          ["ufisht", [10622]],
          ["Ufr", [120088]],
          ["ufr", [120114]],
          ["Ugrave", [217]],
          ["ugrave", [249]],
          ["uHar", [10595]],
          ["uharl", [8639]],
          ["uharr", [8638]],
          ["uhblk", [9600]],
          ["ulcorn", [8988]],
          ["ulcorner", [8988]],
          ["ulcrop", [8975]],
          ["ultri", [9720]],
          ["Umacr", [362]],
          ["umacr", [363]],
          ["uml", [168]],
          ["UnderBar", [95]],
          ["UnderBrace", [9183]],
          ["UnderBracket", [9141]],
          ["UnderParenthesis", [9181]],
          ["Union", [8899]],
          ["UnionPlus", [8846]],
          ["Uogon", [370]],
          ["uogon", [371]],
          ["Uopf", [120140]],
          ["uopf", [120166]],
          ["UpArrowBar", [10514]],
          ["uparrow", [8593]],
          ["UpArrow", [8593]],
          ["Uparrow", [8657]],
          ["UpArrowDownArrow", [8645]],
          ["updownarrow", [8597]],
          ["UpDownArrow", [8597]],
          ["Updownarrow", [8661]],
          ["UpEquilibrium", [10606]],
          ["upharpoonleft", [8639]],
          ["upharpoonright", [8638]],
          ["uplus", [8846]],
          ["UpperLeftArrow", [8598]],
          ["UpperRightArrow", [8599]],
          ["upsi", [965]],
          ["Upsi", [978]],
          ["upsih", [978]],
          ["Upsilon", [933]],
          ["upsilon", [965]],
          ["UpTeeArrow", [8613]],
          ["UpTee", [8869]],
          ["upuparrows", [8648]],
          ["urcorn", [8989]],
          ["urcorner", [8989]],
          ["urcrop", [8974]],
          ["Uring", [366]],
          ["uring", [367]],
          ["urtri", [9721]],
          ["Uscr", [119984]],
          ["uscr", [120010]],
          ["utdot", [8944]],
          ["Utilde", [360]],
          ["utilde", [361]],
          ["utri", [9653]],
          ["utrif", [9652]],
          ["uuarr", [8648]],
          ["Uuml", [220]],
          ["uuml", [252]],
          ["uwangle", [10663]],
          ["vangrt", [10652]],
          ["varepsilon", [1013]],
          ["varkappa", [1008]],
          ["varnothing", [8709]],
          ["varphi", [981]],
          ["varpi", [982]],
          ["varpropto", [8733]],
          ["varr", [8597]],
          ["vArr", [8661]],
          ["varrho", [1009]],
          ["varsigma", [962]],
          ["varsubsetneq", [8842, 65024]],
          ["varsubsetneqq", [10955, 65024]],
          ["varsupsetneq", [8843, 65024]],
          ["varsupsetneqq", [10956, 65024]],
          ["vartheta", [977]],
          ["vartriangleleft", [8882]],
          ["vartriangleright", [8883]],
          ["vBar", [10984]],
          ["Vbar", [10987]],
          ["vBarv", [10985]],
          ["Vcy", [1042]],
          ["vcy", [1074]],
          ["vdash", [8866]],
          ["vDash", [8872]],
          ["Vdash", [8873]],
          ["VDash", [8875]],
          ["Vdashl", [10982]],
          ["veebar", [8891]],
          ["vee", [8744]],
          ["Vee", [8897]],
          ["veeeq", [8794]],
          ["vellip", [8942]],
          ["verbar", [124]],
          ["Verbar", [8214]],
          ["vert", [124]],
          ["Vert", [8214]],
          ["VerticalBar", [8739]],
          ["VerticalLine", [124]],
          ["VerticalSeparator", [10072]],
          ["VerticalTilde", [8768]],
          ["VeryThinSpace", [8202]],
          ["Vfr", [120089]],
          ["vfr", [120115]],
          ["vltri", [8882]],
          ["vnsub", [8834, 8402]],
          ["vnsup", [8835, 8402]],
          ["Vopf", [120141]],
          ["vopf", [120167]],
          ["vprop", [8733]],
          ["vrtri", [8883]],
          ["Vscr", [119985]],
          ["vscr", [120011]],
          ["vsubnE", [10955, 65024]],
          ["vsubne", [8842, 65024]],
          ["vsupnE", [10956, 65024]],
          ["vsupne", [8843, 65024]],
          ["Vvdash", [8874]],
          ["vzigzag", [10650]],
          ["Wcirc", [372]],
          ["wcirc", [373]],
          ["wedbar", [10847]],
          ["wedge", [8743]],
          ["Wedge", [8896]],
          ["wedgeq", [8793]],
          ["weierp", [8472]],
          ["Wfr", [120090]],
          ["wfr", [120116]],
          ["Wopf", [120142]],
          ["wopf", [120168]],
          ["wp", [8472]],
          ["wr", [8768]],
          ["wreath", [8768]],
          ["Wscr", [119986]],
          ["wscr", [120012]],
          ["xcap", [8898]],
          ["xcirc", [9711]],
          ["xcup", [8899]],
          ["xdtri", [9661]],
          ["Xfr", [120091]],
          ["xfr", [120117]],
          ["xharr", [10231]],
          ["xhArr", [10234]],
          ["Xi", [926]],
          ["xi", [958]],
          ["xlarr", [10229]],
          ["xlArr", [10232]],
          ["xmap", [10236]],
          ["xnis", [8955]],
          ["xodot", [10752]],
          ["Xopf", [120143]],
          ["xopf", [120169]],
          ["xoplus", [10753]],
          ["xotime", [10754]],
          ["xrarr", [10230]],
          ["xrArr", [10233]],
          ["Xscr", [119987]],
          ["xscr", [120013]],
          ["xsqcup", [10758]],
          ["xuplus", [10756]],
          ["xutri", [9651]],
          ["xvee", [8897]],
          ["xwedge", [8896]],
          ["Yacute", [221]],
          ["yacute", [253]],
          ["YAcy", [1071]],
          ["yacy", [1103]],
          ["Ycirc", [374]],
          ["ycirc", [375]],
          ["Ycy", [1067]],
          ["ycy", [1099]],
          ["yen", [165]],
          ["Yfr", [120092]],
          ["yfr", [120118]],
          ["YIcy", [1031]],
          ["yicy", [1111]],
          ["Yopf", [120144]],
          ["yopf", [120170]],
          ["Yscr", [119988]],
          ["yscr", [120014]],
          ["YUcy", [1070]],
          ["yucy", [1102]],
          ["yuml", [255]],
          ["Yuml", [376]],
          ["Zacute", [377]],
          ["zacute", [378]],
          ["Zcaron", [381]],
          ["zcaron", [382]],
          ["Zcy", [1047]],
          ["zcy", [1079]],
          ["Zdot", [379]],
          ["zdot", [380]],
          ["zeetrf", [8488]],
          ["ZeroWidthSpace", [8203]],
          ["Zeta", [918]],
          ["zeta", [950]],
          ["zfr", [120119]],
          ["Zfr", [8488]],
          ["ZHcy", [1046]],
          ["zhcy", [1078]],
          ["zigrarr", [8669]],
          ["zopf", [120171]],
          ["Zopf", [8484]],
          ["Zscr", [119989]],
          ["zscr", [120015]],
          ["zwj", [8205]],
          ["zwnj", [8204]],
        ];
        var alphaIndex = {};
        var charIndex = {};
        createIndexes(alphaIndex, charIndex);
        var Html5Entities = /** @class */ (function () {
          function Html5Entities() {}
          Html5Entities.prototype.decode = function (str) {
            if (!str || !str.length) {
              return "";
            }
            return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
              var chr;
              if (entity.charAt(0) === "#") {
                var code =
                  entity.charAt(1) === "x"
                    ? parseInt(entity.substr(2).toLowerCase(), 16)
                    : parseInt(entity.substr(1));
                if (!(isNaN(code) || code < -32768 || code > 65535)) {
                  chr = String.fromCharCode(code);
                }
              } else {
                chr = alphaIndex[entity];
              }
              return chr || s;
            });
          };
          Html5Entities.decode = function (str) {
            return new Html5Entities().decode(str);
          };
          Html5Entities.prototype.encode = function (str) {
            if (!str || !str.length) {
              return "";
            }
            var strLength = str.length;
            var result = "";
            var i = 0;
            while (i < strLength) {
              var charInfo = charIndex[str.charCodeAt(i)];
              if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                  i++;
                } else {
                  alpha = charInfo[""];
                }
                if (alpha) {
                  result += "&" + alpha + ";";
                  i++;
                  continue;
                }
              }
              result += str.charAt(i);
              i++;
            }
            return result;
          };
          Html5Entities.encode = function (str) {
            return new Html5Entities().encode(str);
          };
          Html5Entities.prototype.encodeNonUTF = function (str) {
            if (!str || !str.length) {
              return "";
            }
            var strLength = str.length;
            var result = "";
            var i = 0;
            while (i < strLength) {
              var c = str.charCodeAt(i);
              var charInfo = charIndex[c];
              if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                  i++;
                } else {
                  alpha = charInfo[""];
                }
                if (alpha) {
                  result += "&" + alpha + ";";
                  i++;
                  continue;
                }
              }
              if (c < 32 || c > 126) {
                result += "&#" + c + ";";
              } else {
                result += str.charAt(i);
              }
              i++;
            }
            return result;
          };
          Html5Entities.encodeNonUTF = function (str) {
            return new Html5Entities().encodeNonUTF(str);
          };
          Html5Entities.prototype.encodeNonASCII = function (str) {
            if (!str || !str.length) {
              return "";
            }
            var strLength = str.length;
            var result = "";
            var i = 0;
            while (i < strLength) {
              var c = str.charCodeAt(i);
              if (c <= 255) {
                result += str[i++];
                continue;
              }
              result += "&#" + c + ";";
              i++;
            }
            return result;
          };
          Html5Entities.encodeNonASCII = function (str) {
            return new Html5Entities().encodeNonASCII(str);
          };
          return Html5Entities;
        })();
        exports.Html5Entities = Html5Entities;
        function createIndexes(alphaIndex, charIndex) {
          var i = ENTITIES.length;
          while (i--) {
            var e = ENTITIES[i];
            var alpha = e[0];
            var chars = e[1];
            var chr = chars[0];
            var addChar =
              chr < 32 ||
              chr > 126 ||
              chr === 62 ||
              chr === 60 ||
              chr === 38 ||
              chr === 34 ||
              chr === 39;
            var charInfo = void 0;
            if (addChar) {
              charInfo = charIndex[chr] = charIndex[chr] || {};
            }
            if (chars[1]) {
              var chr2 = chars[1];
              alphaIndex[alpha] =
                String.fromCharCode(chr) + String.fromCharCode(chr2);
              addChar && (charInfo[chr2] = alpha);
            } else {
              alphaIndex[alpha] = String.fromCharCode(chr);
              addChar && (charInfo[""] = alpha);
            }
          }
        }
      },
      {},
    ],
    59: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var xml_entities_1 = require("./xml-entities");
        exports.XmlEntities = xml_entities_1.XmlEntities;
        var html4_entities_1 = require("./html4-entities");
        exports.Html4Entities = html4_entities_1.Html4Entities;
        var html5_entities_1 = require("./html5-entities");
        exports.Html5Entities = html5_entities_1.Html5Entities;
        exports.AllHtmlEntities = html5_entities_1.Html5Entities;
      },
      { "./html4-entities": 57, "./html5-entities": 58, "./xml-entities": 60 },
    ],
    60: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ALPHA_INDEX = {
          "&lt": "<",
          "&gt": ">",
          "&quot": '"',
          "&apos": "'",
          "&amp": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&apos;": "'",
          "&amp;": "&",
        };
        var CHAR_INDEX = {
          60: "lt",
          62: "gt",
          34: "quot",
          39: "apos",
          38: "amp",
        };
        var CHAR_S_INDEX = {
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&apos;",
          "&": "&amp;",
        };
        var XmlEntities = /** @class */ (function () {
          function XmlEntities() {}
          XmlEntities.prototype.encode = function (str) {
            if (!str || !str.length) {
              return "";
            }
            return str.replace(/[<>"'&]/g, function (s) {
              return CHAR_S_INDEX[s];
            });
          };
          XmlEntities.encode = function (str) {
            return new XmlEntities().encode(str);
          };
          XmlEntities.prototype.decode = function (str) {
            if (!str || !str.length) {
              return "";
            }
            return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {
              if (s.charAt(1) === "#") {
                var code =
                  s.charAt(2).toLowerCase() === "x"
                    ? parseInt(s.substr(3), 16)
                    : parseInt(s.substr(2));
                if (isNaN(code) || code < -32768 || code > 65535) {
                  return "";
                }
                return String.fromCharCode(code);
              }
              return ALPHA_INDEX[s] || s;
            });
          };
          XmlEntities.decode = function (str) {
            return new XmlEntities().decode(str);
          };
          XmlEntities.prototype.encodeNonUTF = function (str) {
            if (!str || !str.length) {
              return "";
            }
            var strLength = str.length;
            var result = "";
            var i = 0;
            while (i < strLength) {
              var c = str.charCodeAt(i);
              var alpha = CHAR_INDEX[c];
              if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
              }
              if (c < 32 || c > 126) {
                result += "&#" + c + ";";
              } else {
                result += str.charAt(i);
              }
              i++;
            }
            return result;
          };
          XmlEntities.encodeNonUTF = function (str) {
            return new XmlEntities().encodeNonUTF(str);
          };
          XmlEntities.prototype.encodeNonASCII = function (str) {
            if (!str || !str.length) {
              return "";
            }
            var strLenght = str.length;
            var result = "";
            var i = 0;
            while (i < strLenght) {
              var c = str.charCodeAt(i);
              if (c <= 255) {
                result += str[i++];
                continue;
              }
              result += "&#" + c + ";";
              i++;
            }
            return result;
          };
          XmlEntities.encodeNonASCII = function (str) {
            return new XmlEntities().encodeNonASCII(str);
          };
          return XmlEntities;
        })();
        exports.XmlEntities = XmlEntities;
      },
      {},
    ],
    61: [
      function (require, module, exports) {
        var http = require("http");
        var url = require("url");

        var https = module.exports;

        for (var key in http) {
          if (http.hasOwnProperty(key)) https[key] = http[key];
        }

        https.request = function (params, cb) {
          params = validateParams(params);
          return http.request.call(this, params, cb);
        };

        https.get = function (params, cb) {
          params = validateParams(params);
          return http.get.call(this, params, cb);
        };

        function validateParams(params) {
          if (typeof params === "string") {
            params = url.parse(params);
          }
          if (!params.protocol) {
            params.protocol = "https:";
          }
          if (params.protocol !== "https:") {
            throw new Error(
              'Protocol "' +
                params.protocol +
                '" not supported. Expected "https:"'
            );
          }
          return params;
        }
      },
      { http: undefined, url: 642 },
    ],
    62: [
      function (require, module, exports) {
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];

          i += d;

          e = s & ((1 << -nBits) - 1);
          s >>= -nBits;
          nBits += eLen;
          for (
            ;
            nBits > 0;
            e = e * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          m = e & ((1 << -nBits) - 1);
          e >>= -nBits;
          nBits += mLen;
          for (
            ;
            nBits > 0;
            m = m * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

          value = Math.abs(value);

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }

            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }

          for (
            ;
            mLen >= 8;
            buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
          ) {}

          e = (e << mLen) | m;
          eLen += mLen;
          for (
            ;
            eLen > 0;
            buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
          ) {}

          buffer[offset + i - d] |= s * 128;
        };
      },
      {},
    ],
    63: [
      function (require, module, exports) {
        if (typeof Object.create === "function") {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            });
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      },
      {},
    ],
    64: [
      function (require, module, exports) {
        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */

        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function (obj) {
          return (
            obj != null &&
            (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
          );
        };

        function isBuffer(obj) {
          return (
            !!obj.constructor &&
            typeof obj.constructor.isBuffer === "function" &&
            obj.constructor.isBuffer(obj)
          );
        }

        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
          return (
            typeof obj.readFloatLE === "function" &&
            typeof obj.slice === "function" &&
            isBuffer(obj.slice(0, 0))
          );
        }
      },
      {},
    ],
    65: [
      function (require, module, exports) {
        /*!
         * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isObject = require("isobject");

        function isObjectObject(o) {
          return (
            isObject(o) === true &&
            Object.prototype.toString.call(o) === "[object Object]"
          );
        }

        module.exports = function isPlainObject(o) {
          var ctor, prot;

          if (isObjectObject(o) === false) return false;

          // If has modified constructor
          ctor = o.constructor;
          if (typeof ctor !== "function") return false;

          // If has modified prototype
          prot = ctor.prototype;
          if (isObjectObject(prot) === false) return false;

          // If constructor does not have an Object-specific method
          if (prot.hasOwnProperty("isPrototypeOf") === false) {
            return false;
          }

          // Most likely a plain Object
          return true;
        };
      },
      { isobject: 67 },
    ],
    66: [
      function (require, module, exports) {
        var toString = {}.toString;

        module.exports =
          Array.isArray ||
          function (arr) {
            return toString.call(arr) == "[object Array]";
          };
      },
      {},
    ],
    67: [
      function (require, module, exports) {
        /*!
         * isobject <https://github.com/jonschlinkert/isobject>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        module.exports = function isObject(val) {
          return (
            val != null &&
            typeof val === "object" &&
            Array.isArray(val) === false
          );
        };
      },
      {},
    ],
    68: [
      function (require, module, exports) {
        var toString = Object.prototype.toString;

        module.exports = function kindOf(val) {
          if (val === void 0) return "undefined";
          if (val === null) return "null";

          var type = typeof val;
          if (type === "boolean") return "boolean";
          if (type === "string") return "string";
          if (type === "number") return "number";
          if (type === "symbol") return "symbol";
          if (type === "function") {
            return isGeneratorFn(val) ? "generatorfunction" : "function";
          }

          if (isArray(val)) return "array";
          if (isBuffer(val)) return "buffer";
          if (isArguments(val)) return "arguments";
          if (isDate(val)) return "date";
          if (isError(val)) return "error";
          if (isRegexp(val)) return "regexp";

          switch (ctorName(val)) {
            case "Symbol":
              return "symbol";
            case "Promise":
              return "promise";

            // Set, Map, WeakSet, WeakMap
            case "WeakMap":
              return "weakmap";
            case "WeakSet":
              return "weakset";
            case "Map":
              return "map";
            case "Set":
              return "set";

            // 8-bit typed arrays
            case "Int8Array":
              return "int8array";
            case "Uint8Array":
              return "uint8array";
            case "Uint8ClampedArray":
              return "uint8clampedarray";

            // 16-bit typed arrays
            case "Int16Array":
              return "int16array";
            case "Uint16Array":
              return "uint16array";

            // 32-bit typed arrays
            case "Int32Array":
              return "int32array";
            case "Uint32Array":
              return "uint32array";
            case "Float32Array":
              return "float32array";
            case "Float64Array":
              return "float64array";
          }

          if (isGeneratorObj(val)) {
            return "generator";
          }

          // Non-plain objects
          type = toString.call(val);
          switch (type) {
            case "[object Object]":
              return "object";
            // iterators
            case "[object Map Iterator]":
              return "mapiterator";
            case "[object Set Iterator]":
              return "setiterator";
            case "[object String Iterator]":
              return "stringiterator";
            case "[object Array Iterator]":
              return "arrayiterator";
          }

          // other
          return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
        };

        function ctorName(val) {
          return typeof val.constructor === "function"
            ? val.constructor.name
            : null;
        }

        function isArray(val) {
          if (Array.isArray) return Array.isArray(val);
          return val instanceof Array;
        }

        function isError(val) {
          return (
            val instanceof Error ||
            (typeof val.message === "string" &&
              val.constructor &&
              typeof val.constructor.stackTraceLimit === "number")
          );
        }

        function isDate(val) {
          if (val instanceof Date) return true;
          return (
            typeof val.toDateString === "function" &&
            typeof val.getDate === "function" &&
            typeof val.setDate === "function"
          );
        }

        function isRegexp(val) {
          if (val instanceof RegExp) return true;
          return (
            typeof val.flags === "string" &&
            typeof val.ignoreCase === "boolean" &&
            typeof val.multiline === "boolean" &&
            typeof val.global === "boolean"
          );
        }

        function isGeneratorFn(name, val) {
          return ctorName(name) === "GeneratorFunction";
        }

        function isGeneratorObj(val) {
          return (
            typeof val.throw === "function" &&
            typeof val.return === "function" &&
            typeof val.next === "function"
          );
        }

        function isArguments(val) {
          try {
            if (
              typeof val.length === "number" &&
              typeof val.callee === "function"
            ) {
              return true;
            }
          } catch (err) {
            if (err.message.indexOf("callee") !== -1) {
              return true;
            }
          }
          return false;
        }

        /**
         * If you need to support Safari 5-7 (8-10 yr-old browser),
         * take a look at https://github.com/feross/is-buffer
         */

        function isBuffer(val) {
          if (
            val.constructor &&
            typeof val.constructor.isBuffer === "function"
          ) {
            return val.constructor.isBuffer(val);
          }
          return false;
        }
      },
      {},
    ],
    69: [
      function (require, module, exports) {
        (function (global) {
          /**
           * lodash (Custom Build) <https://lodash.com/>
           * Build: `lodash modularize exports="npm" -o ./`
           * Copyright jQuery Foundation and other contributors <https://jquery.org/>
           * Released under MIT license <https://lodash.com/license>
           * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
           * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
           */

          /** Used as the `TypeError` message for "Functions" methods. */
          var FUNC_ERROR_TEXT = "Expected a function";

          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = "__lodash_hash_undefined__";

          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0;

          /** `Object#toString` result references. */
          var funcTag = "[object Function]",
            genTag = "[object GeneratorFunction]",
            symbolTag = "[object Symbol]";

          /** Used to match property names within property paths. */
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/,
            reLeadingDot = /^\./,
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

          /**
           * Used to match `RegExp`
           * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
           */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

          /** Used to match backslashes in property paths. */
          var reEscapeChar = /\\(\\)?/g;

          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;

          /** Detect free variable `global` from Node.js. */
          var freeGlobal =
            typeof global == "object" &&
            global &&
            global.Object === Object &&
            global;

          /** Detect free variable `self`. */
          var freeSelf =
            typeof self == "object" && self && self.Object === Object && self;

          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function("return this")();

          /**
           * Gets the value at `key` of `object`.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }

          /**
           * Checks if `value` is a host object in IE < 9.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
           */
          function isHostObject(value) {
            // Many host objects are `Object` objects that can coerce to strings
            // despite having improperly defined `toString` methods.
            var result = false;
            if (value != null && typeof value.toString != "function") {
              try {
                result = !!(value + "");
              } catch (e) {}
            }
            return result;
          }

          /** Used for built-in method references. */
          var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

          /** Used to detect overreaching core-js shims. */
          var coreJsData = root["__core-js_shared__"];

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = (function () {
            var uid = /[^.]+$/.exec(
              (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ""
            );
            return uid ? "Symbol(src)_1." + uid : "";
          })();

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */
          var objectToString = objectProto.toString;

          /** Used to detect if a method is native. */
          var reIsNative = RegExp(
            "^" +
              funcToString
                .call(hasOwnProperty)
                .replace(reRegExpChar, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?"
                ) +
              "$"
          );

          /** Built-in value references. */
          var Symbol = root.Symbol,
            splice = arrayProto.splice;

          /* Built-in method references that are verified to be native. */
          var Map = getNative(root, "Map"),
            nativeCreate = getNative(Object, "create");

          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Hash(entries) {
            var index = -1,
              length = entries ? entries.length : 0;

            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
          }

          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }

          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }

          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate
              ? data[key] !== undefined
              : hasOwnProperty.call(data, key);
          }

          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */
          function hashSet(key, value) {
            var data = this.__data__;
            data[key] =
              nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function ListCache(entries) {
            var index = -1,
              length = entries ? entries.length : 0;

            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */
          function listCacheClear() {
            this.__data__ = [];
          }

          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);

            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            return true;
          }

          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);

            return index < 0 ? undefined : data[index][1];
          }

          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }

          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);

            if (index < 0) {
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function MapCache(entries) {
            var index = -1,
              length = entries ? entries.length : 0;

            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */
          function mapCacheClear() {
            this.__data__ = {
              hash: new Hash(),
              map: new (Map || ListCache)(),
              string: new Hash(),
            };
          }

          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function mapCacheDelete(key) {
            return getMapData(this, key)["delete"](key);
          }

          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }

          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }

          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */
          function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;

          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }

          /**
           * The base implementation of `_.get` without support for default values.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @returns {*} Returns the resolved value.
           */
          function baseGet(object, path) {
            path = isKey(path, object) ? [path] : castPath(path);

            var index = 0,
              length = path.length;

            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined;
          }

          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern =
              isFunction(value) || isHostObject(value)
                ? reIsNative
                : reIsHostCtor;
            return pattern.test(toSource(value));
          }

          /**
           * The base implementation of `_.toString` which doesn't convert nullish
           * values to empty strings.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {string} Returns the string.
           */
          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == "string") {
              return value;
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }

          /**
           * Casts `value` to a path array if it's not one.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Array} Returns the cast property path array.
           */
          function castPath(value) {
            return isArray(value) ? value : stringToPath(value);
          }

          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key)
              ? data[typeof key == "string" ? "string" : "hash"]
              : data.map;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }

          /**
           * Checks if `value` is a property name and not a property path.
           *
           * @private
           * @param {*} value The value to check.
           * @param {Object} [object] The object to query keys on.
           * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
           */
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (
              type == "number" ||
              type == "symbol" ||
              type == "boolean" ||
              value == null ||
              isSymbol(value)
            ) {
              return true;
            }
            return (
              reIsPlainProp.test(value) ||
              !reIsDeepProp.test(value) ||
              (object != null && value in Object(object))
            );
          }

          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" ||
              type == "number" ||
              type == "symbol" ||
              type == "boolean"
              ? value !== "__proto__"
              : value === null;
          }

          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }

          /**
           * Converts `string` to a property path array.
           *
           * @private
           * @param {string} string The string to convert.
           * @returns {Array} Returns the property path array.
           */
          var stringToPath = memoize(function (string) {
            string = toString(string);

            var result = [];
            if (reLeadingDot.test(string)) {
              result.push("");
            }
            string.replace(rePropName, function (match, number, quote, string) {
              result.push(
                quote ? string.replace(reEscapeChar, "$1") : number || match
              );
            });
            return result;
          });

          /**
           * Converts `value` to a string key if it's not a string or symbol.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {string|symbol} Returns the key.
           */
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }

          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to process.
           * @returns {string} Returns the source code.
           */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}
              try {
                return func + "";
              } catch (e) {}
            }
            return "";
          }

          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided, it determines the cache key for storing the result based on the
           * arguments provided to the memoized function. By default, the first argument
           * provided to the memoized function is used as the map cache key. The `func`
           * is invoked with the `this` binding of the memoized function.
           *
           * **Note:** The cache is exposed as the `cache` property on the memoized
           * function. Its creation may be customized by replacing the `_.memoize.Cache`
           * constructor with one whose instances implement the
           * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
           * method interface of `delete`, `get`, `has`, and `set`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] The function to resolve the cache key.
           * @returns {Function} Returns the new memoized function.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           * var other = { 'c': 3, 'd': 4 };
           *
           * var values = _.memoize(_.values);
           * values(object);
           * // => [1, 2]
           *
           * values(other);
           * // => [3, 4]
           *
           * object.a = 2;
           * values(object);
           * // => [1, 2]
           *
           * // Modify the result cache.
           * values.cache.set(object, ['a', 'b']);
           * values(object);
           * // => ['a', 'b']
           *
           * // Replace `_.memoize.Cache`.
           * _.memoize.Cache = WeakMap;
           */
          function memoize(func, resolver) {
            if (
              typeof func != "function" ||
              (resolver && typeof resolver != "function")
            ) {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function () {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result);
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }

          // Assign cache to `_.memoize`.
          memoize.Cache = MapCache;

          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */
          function eq(value, other) {
            return value === other || (value !== value && other !== other);
          }

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */
          var isArray = Array.isArray;

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 8-9 which returns 'object' for typed array and other constructors.
            var tag = isObject(value) ? objectToString.call(value) : "";
            return tag == funcTag || tag == genTag;
          }

          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == "object" || type == "function");
          }

          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */
          function isObjectLike(value) {
            return !!value && typeof value == "object";
          }

          /**
           * Checks if `value` is classified as a `Symbol` primitive or object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
           * @example
           *
           * _.isSymbol(Symbol.iterator);
           * // => true
           *
           * _.isSymbol('abc');
           * // => false
           */
          function isSymbol(value) {
            return (
              typeof value == "symbol" ||
              (isObjectLike(value) && objectToString.call(value) == symbolTag)
            );
          }

          /**
           * Converts `value` to a string. An empty string is returned for `null`
           * and `undefined` values. The sign of `-0` is preserved.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to process.
           * @returns {string} Returns the string.
           * @example
           *
           * _.toString(null);
           * // => ''
           *
           * _.toString(-0);
           * // => '-0'
           *
           * _.toString([1, 2, 3]);
           * // => '1,2,3'
           */
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }

          /**
           * Gets the value at `path` of `object`. If the resolved value is
           * `undefined`, the `defaultValue` is returned in its place.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.get(object, 'a[0].b.c');
           * // => 3
           *
           * _.get(object, ['a', '0', 'b', 'c']);
           * // => 3
           *
           * _.get(object, 'a.b.c', 'default');
           * // => 'default'
           */
          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
          }

          module.exports = get;
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {},
    ],
    70: [
      function (require, module, exports) {
        (function (global) {
          /**
           * lodash (Custom Build) <https://lodash.com/>
           * Build: `lodash modularize exports="npm" -o ./`
           * Copyright jQuery Foundation and other contributors <https://jquery.org/>
           * Released under MIT license <https://lodash.com/license>
           * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
           * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
           */

          /** Used as the `TypeError` message for "Functions" methods. */
          var FUNC_ERROR_TEXT = "Expected a function";

          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = "__lodash_hash_undefined__";

          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0,
            MAX_SAFE_INTEGER = 9007199254740991;

          /** `Object#toString` result references. */
          var funcTag = "[object Function]",
            genTag = "[object GeneratorFunction]",
            symbolTag = "[object Symbol]";

          /** Used to match property names within property paths. */
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/,
            reLeadingDot = /^\./,
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

          /**
           * Used to match `RegExp`
           * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
           */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

          /** Used to match backslashes in property paths. */
          var reEscapeChar = /\\(\\)?/g;

          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;

          /** Used to detect unsigned integer values. */
          var reIsUint = /^(?:0|[1-9]\d*)$/;

          /** Detect free variable `global` from Node.js. */
          var freeGlobal =
            typeof global == "object" &&
            global &&
            global.Object === Object &&
            global;

          /** Detect free variable `self`. */
          var freeSelf =
            typeof self == "object" && self && self.Object === Object && self;

          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function("return this")();

          /**
           * Gets the value at `key` of `object`.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }

          /**
           * Checks if `value` is a host object in IE < 9.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
           */
          function isHostObject(value) {
            // Many host objects are `Object` objects that can coerce to strings
            // despite having improperly defined `toString` methods.
            var result = false;
            if (value != null && typeof value.toString != "function") {
              try {
                result = !!(value + "");
              } catch (e) {}
            }
            return result;
          }

          /** Used for built-in method references. */
          var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

          /** Used to detect overreaching core-js shims. */
          var coreJsData = root["__core-js_shared__"];

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = (function () {
            var uid = /[^.]+$/.exec(
              (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ""
            );
            return uid ? "Symbol(src)_1." + uid : "";
          })();

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */
          var objectToString = objectProto.toString;

          /** Used to detect if a method is native. */
          var reIsNative = RegExp(
            "^" +
              funcToString
                .call(hasOwnProperty)
                .replace(reRegExpChar, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?"
                ) +
              "$"
          );

          /** Built-in value references. */
          var Symbol = root.Symbol,
            splice = arrayProto.splice;

          /* Built-in method references that are verified to be native. */
          var Map = getNative(root, "Map"),
            nativeCreate = getNative(Object, "create");

          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Hash(entries) {
            var index = -1,
              length = entries ? entries.length : 0;

            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
          }

          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }

          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }

          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate
              ? data[key] !== undefined
              : hasOwnProperty.call(data, key);
          }

          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */
          function hashSet(key, value) {
            var data = this.__data__;
            data[key] =
              nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function ListCache(entries) {
            var index = -1,
              length = entries ? entries.length : 0;

            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */
          function listCacheClear() {
            this.__data__ = [];
          }

          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);

            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            return true;
          }

          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);

            return index < 0 ? undefined : data[index][1];
          }

          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }

          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);

            if (index < 0) {
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function MapCache(entries) {
            var index = -1,
              length = entries ? entries.length : 0;

            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */
          function mapCacheClear() {
            this.__data__ = {
              hash: new Hash(),
              map: new (Map || ListCache)(),
              string: new Hash(),
            };
          }

          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function mapCacheDelete(key) {
            return getMapData(this, key)["delete"](key);
          }

          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }

          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }

          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */
          function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;

          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (
              !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined && !(key in object))
            ) {
              object[key] = value;
            }
          }

          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }

          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern =
              isFunction(value) || isHostObject(value)
                ? reIsNative
                : reIsHostCtor;
            return pattern.test(toSource(value));
          }

          /**
           * The base implementation of `_.set`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = isKey(path, object) ? [path] : castPath(path);

            var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;

            while (nested != null && ++index < length) {
              var key = toKey(path[index]),
                newValue = value;

              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer
                  ? customizer(objValue, key, nested)
                  : undefined;
                if (newValue === undefined) {
                  newValue = isObject(objValue)
                    ? objValue
                    : isIndex(path[index + 1])
                    ? []
                    : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }

          /**
           * The base implementation of `_.toString` which doesn't convert nullish
           * values to empty strings.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {string} Returns the string.
           */
          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == "string") {
              return value;
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }

          /**
           * Casts `value` to a path array if it's not one.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Array} Returns the cast property path array.
           */
          function castPath(value) {
            return isArray(value) ? value : stringToPath(value);
          }

          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key)
              ? data[typeof key == "string" ? "string" : "hash"]
              : data.map;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return (
              !!length &&
              (typeof value == "number" || reIsUint.test(value)) &&
              value > -1 &&
              value % 1 == 0 &&
              value < length
            );
          }

          /**
           * Checks if `value` is a property name and not a property path.
           *
           * @private
           * @param {*} value The value to check.
           * @param {Object} [object] The object to query keys on.
           * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
           */
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (
              type == "number" ||
              type == "symbol" ||
              type == "boolean" ||
              value == null ||
              isSymbol(value)
            ) {
              return true;
            }
            return (
              reIsPlainProp.test(value) ||
              !reIsDeepProp.test(value) ||
              (object != null && value in Object(object))
            );
          }

          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" ||
              type == "number" ||
              type == "symbol" ||
              type == "boolean"
              ? value !== "__proto__"
              : value === null;
          }

          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }

          /**
           * Converts `string` to a property path array.
           *
           * @private
           * @param {string} string The string to convert.
           * @returns {Array} Returns the property path array.
           */
          var stringToPath = memoize(function (string) {
            string = toString(string);

            var result = [];
            if (reLeadingDot.test(string)) {
              result.push("");
            }
            string.replace(rePropName, function (match, number, quote, string) {
              result.push(
                quote ? string.replace(reEscapeChar, "$1") : number || match
              );
            });
            return result;
          });

          /**
           * Converts `value` to a string key if it's not a string or symbol.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {string|symbol} Returns the key.
           */
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }

          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to process.
           * @returns {string} Returns the source code.
           */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}
              try {
                return func + "";
              } catch (e) {}
            }
            return "";
          }

          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided, it determines the cache key for storing the result based on the
           * arguments provided to the memoized function. By default, the first argument
           * provided to the memoized function is used as the map cache key. The `func`
           * is invoked with the `this` binding of the memoized function.
           *
           * **Note:** The cache is exposed as the `cache` property on the memoized
           * function. Its creation may be customized by replacing the `_.memoize.Cache`
           * constructor with one whose instances implement the
           * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
           * method interface of `delete`, `get`, `has`, and `set`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] The function to resolve the cache key.
           * @returns {Function} Returns the new memoized function.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           * var other = { 'c': 3, 'd': 4 };
           *
           * var values = _.memoize(_.values);
           * values(object);
           * // => [1, 2]
           *
           * values(other);
           * // => [3, 4]
           *
           * object.a = 2;
           * values(object);
           * // => [1, 2]
           *
           * // Modify the result cache.
           * values.cache.set(object, ['a', 'b']);
           * values(object);
           * // => ['a', 'b']
           *
           * // Replace `_.memoize.Cache`.
           * _.memoize.Cache = WeakMap;
           */
          function memoize(func, resolver) {
            if (
              typeof func != "function" ||
              (resolver && typeof resolver != "function")
            ) {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function () {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result);
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }

          // Assign cache to `_.memoize`.
          memoize.Cache = MapCache;

          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */
          function eq(value, other) {
            return value === other || (value !== value && other !== other);
          }

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */
          var isArray = Array.isArray;

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 8-9 which returns 'object' for typed array and other constructors.
            var tag = isObject(value) ? objectToString.call(value) : "";
            return tag == funcTag || tag == genTag;
          }

          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == "object" || type == "function");
          }

          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */
          function isObjectLike(value) {
            return !!value && typeof value == "object";
          }

          /**
           * Checks if `value` is classified as a `Symbol` primitive or object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
           * @example
           *
           * _.isSymbol(Symbol.iterator);
           * // => true
           *
           * _.isSymbol('abc');
           * // => false
           */
          function isSymbol(value) {
            return (
              typeof value == "symbol" ||
              (isObjectLike(value) && objectToString.call(value) == symbolTag)
            );
          }

          /**
           * Converts `value` to a string. An empty string is returned for `null`
           * and `undefined` values. The sign of `-0` is preserved.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to process.
           * @returns {string} Returns the string.
           * @example
           *
           * _.toString(null);
           * // => ''
           *
           * _.toString(-0);
           * // => '-0'
           *
           * _.toString([1, 2, 3]);
           * // => '1,2,3'
           */
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }

          /**
           * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
           * it's created. Arrays are created for missing index properties while objects
           * are created for all other missing properties. Use `_.setWith` to customize
           * `path` creation.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.set(object, 'a[0].b.c', 4);
           * console.log(object.a[0].b.c);
           * // => 4
           *
           * _.set(object, ['x', '0', 'y', 'z'], 5);
           * console.log(object.x[0].y.z);
           * // => 5
           */
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }

          module.exports = set;
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {},
    ],
    71: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        const stream_1 = require("stream");
        const sax_1 = __importDefault(require("sax"));
        const parse_time_1 = require("./parse-time");
        /**
         * A wrapper around sax that emits segments.
         */
        class DashMPDParser extends stream_1.Writable {
          constructor(targetID) {
            super();
            this._parser = sax_1.default.createStream(false, {
              lowercase: true,
            });
            this._parser.on("error", this.emit.bind(this, "error"));
            let lastTag;
            let currtime = 0;
            let seq = 0;
            let segmentTemplate;
            let timescale, offset, duration, baseURL;
            let timeline = [];
            let getSegments = false;
            let isStatic;
            let treeLevel;
            let periodStart;
            const tmpl = (str) => {
              const context = {
                RepresentationID: targetID,
                Number: seq,
                Time: currtime,
              };
              return str.replace(/\$(\w+)\$/g, (m, p1) => context[p1] + "");
            };
            this._parser.on("opentag", (node) => {
              switch (node.name) {
                case "mpd":
                  currtime = node.attributes.availabilitystarttime
                    ? new Date(node.attributes.availabilitystarttime).getTime()
                    : 0;
                  isStatic = node.attributes.type !== "dynamic";
                  break;
                case "period":
                  // Reset everything on <Period> tag.
                  seq = 0;
                  timescale = 1000;
                  duration = 0;
                  offset = 0;
                  baseURL = [];
                  treeLevel = 0;
                  periodStart =
                    parse_time_1.durationStr(node.attributes.start) || 0;
                  break;
                case "segmentlist":
                  seq = parseInt(node.attributes.startnumber) || seq;
                  timescale = parseInt(node.attributes.timescale) || timescale;
                  duration = parseInt(node.attributes.duration) || duration;
                  offset =
                    parseInt(node.attributes.presentationtimeoffset) || offset;
                  break;
                case "segmenttemplate":
                  segmentTemplate = node.attributes;
                  seq = parseInt(node.attributes.startnumber) || seq;
                  timescale = parseInt(node.attributes.timescale) || timescale;
                  break;
                case "segmenttimeline":
                case "baseurl":
                  lastTag = node.name;
                  break;
                case "s":
                  timeline.push([
                    parseInt(node.attributes.d),
                    parseInt(node.attributes.r),
                  ]);
                  break;
                case "adaptationset":
                case "representation":
                  treeLevel++;
                  if (targetID == null) {
                    targetID = node.attributes.id;
                  }
                  getSegments = node.attributes.id === targetID + "";
                  if (getSegments) {
                    if (periodStart) {
                      currtime += periodStart;
                    }
                    if (offset) {
                      currtime -= (offset / timescale) * 1000;
                    }
                    this.emit("starttime", currtime);
                  }
                  if (getSegments && segmentTemplate && timeline.length) {
                    if (segmentTemplate.initialization) {
                      this.emit("item", {
                        url:
                          baseURL.filter((s) => !!s).join("") +
                          tmpl(segmentTemplate.initialization),
                        seq: seq - 1,
                        duration: 0,
                      });
                    }
                    for (let [duration, repeat] of timeline) {
                      duration = (duration / timescale) * 1000;
                      repeat = repeat || 1;
                      for (let i = 0; i < repeat; i++) {
                        this.emit("item", {
                          url:
                            baseURL.filter((s) => !!s).join("") +
                            tmpl(segmentTemplate.media),
                          seq: seq++,
                          duration,
                        });
                        currtime += duration;
                      }
                    }
                  }
                  break;
                case "initialization":
                  if (getSegments) {
                    this.emit("item", {
                      url:
                        baseURL.filter((s) => !!s).join("") +
                        node.attributes.sourceurl,
                      seq: seq++,
                      duration: 0,
                    });
                  }
                  break;
                case "segmenturl":
                  if (getSegments) {
                    let tl = timeline.shift();
                    let segmentDuration =
                      (((tl && tl[0]) || duration) / timescale) * 1000;
                    this.emit("item", {
                      url:
                        baseURL.filter((s) => !!s).join("") +
                        node.attributes.media,
                      seq: seq++,
                      duration: segmentDuration,
                    });
                    currtime += segmentDuration;
                  }
                  break;
              }
            });
            const onEnd = () => {
              if (isStatic) {
                this.emit("endlist");
              }
              if (!getSegments) {
                this.emit(
                  "error",
                  Error(`Representation '${targetID}' not found`)
                );
              }
              this.emit("end");
            };
            this._parser.on("closetag", (tagName) => {
              switch (tagName) {
                case "adaptationset":
                case "representation":
                  treeLevel--;
                  break;
                case "segmentlist":
                  if (getSegments) {
                    this.emit("endearly");
                    onEnd();
                    this._parser.removeAllListeners();
                  }
                  break;
              }
            });
            this._parser.on("text", (text) => {
              if (lastTag === "baseurl") {
                baseURL[treeLevel] = text;
                lastTag = null;
              }
            });
            this.on("finish", onEnd);
          }
          _write(chunk, encoding, callback) {
            this._parser.write(chunk, encoding);
            callback();
          }
        }
        exports.default = DashMPDParser;
      },
      { "./parse-time": 74, sax: 551, stream: 555 },
    ],
    72: [
      function (require, module, exports) {
        "use strict";
        var __importDefault =
          (this && this.__importDefault) ||
          function (mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          };
        const stream_1 = require("stream");
        const url_1 = require("url");
        const miniget_1 = __importDefault(require("miniget"));
        const m3u8_parser_1 = __importDefault(require("./m3u8-parser"));
        const dash_mpd_parser_1 = __importDefault(require("./dash-mpd-parser"));
        const queue_1 = __importDefault(require("./queue"));
        const parse_time_1 = require("./parse-time");
        const supportedParsers = {
          m3u8: m3u8_parser_1.default,
          "dash-mpd": dash_mpd_parser_1.default,
        };
        let m3u8stream = (playlistURL, options = {}) => {
          const stream = new stream_1.PassThrough();
          const chunkReadahead = options.chunkReadahead || 3;
          const liveBuffer = options.liveBuffer || 20000; // 20 seconds
          const requestOptions = options.requestOptions;
          const Parser =
            supportedParsers[
              options.parser ||
                (/\.mpd$/.test(playlistURL) ? "dash-mpd" : "m3u8")
            ];
          if (!Parser) {
            throw TypeError(`parser '${options.parser}' not supported`);
          }
          let begin = 0;
          if (typeof options.begin !== "undefined") {
            begin =
              typeof options.begin === "string"
                ? parse_time_1.humanStr(options.begin)
                : Math.max(options.begin - liveBuffer, 0);
          }
          let liveBegin = Date.now() - liveBuffer;
          let currSegment;
          const streamQueue = new queue_1.default(
            (req, callback) => {
              currSegment = req;
              // Count the size manually, since the `content-length` header is not
              // always there.
              let size = 0;
              req.on("data", (chunk) => (size += chunk.length));
              req.pipe(stream, { end: false });
              req.on("end", () => callback(undefined, size));
            },
            { concurrency: 1 }
          );
          let segmentNumber = 0;
          let downloaded = 0;
          const requestQueue = new queue_1.default(
            (segment, callback) => {
              let req = miniget_1.default(
                url_1.resolve(playlistURL, segment.url),
                requestOptions
              );
              req.on("error", callback);
              streamQueue.push(req, (err, size) => {
                downloaded += +size;
                stream.emit(
                  "progress",
                  {
                    num: ++segmentNumber,
                    size: size,
                    duration: segment.duration,
                    url: segment.url,
                  },
                  requestQueue.total,
                  downloaded
                );
                callback();
              });
            },
            { concurrency: chunkReadahead }
          );
          const onError = (err) => {
            if (ended) {
              return;
            }
            stream.emit("error", err);
            // Stop on any error.
            stream.end();
          };
          // When to look for items again.
          let refreshThreshold;
          let minRefreshTime;
          let refreshTimeout;
          let fetchingPlaylist = true;
          let ended = false;
          let isStatic = false;
          let lastRefresh;
          const onQueuedEnd = (err) => {
            currSegment = null;
            if (err) {
              onError(err);
            } else if (
              !fetchingPlaylist &&
              !ended &&
              !isStatic &&
              requestQueue.tasks.length + requestQueue.active <=
                refreshThreshold
            ) {
              let ms = Math.max(0, minRefreshTime - (Date.now() - lastRefresh));
              fetchingPlaylist = true;
              refreshTimeout = setTimeout(refreshPlaylist, ms);
            } else if (
              (ended || isStatic) &&
              !requestQueue.tasks.length &&
              !requestQueue.active
            ) {
              stream.end();
            }
          };
          let currPlaylist;
          let lastSeq;
          let starttime = 0;
          const refreshPlaylist = () => {
            lastRefresh = Date.now();
            currPlaylist = miniget_1.default(playlistURL, requestOptions);
            currPlaylist.on("error", onError);
            const parser = currPlaylist.pipe(new Parser(options.id));
            parser.on("starttime", (a) => {
              if (starttime) {
                return;
              }
              starttime = a;
              if (typeof options.begin === "string" && begin >= 0) {
                begin += starttime;
              }
            });
            parser.on("endlist", () => {
              isStatic = true;
            });
            parser.on(
              "endearly",
              currPlaylist.unpipe.bind(currPlaylist, parser)
            );
            let addedItems = [];
            let liveAddedItems = [];
            const addItem = (item, isLive) => {
              if (item.seq <= lastSeq) {
                return;
              }
              lastSeq = item.seq;
              begin = item.time;
              requestQueue.push(item, onQueuedEnd);
              addedItems.push(item);
              if (isLive) {
                liveAddedItems.push(item);
              }
            };
            let tailedItems = [],
              tailedItemsDuration = 0;
            parser.on("item", (item) => {
              let timedItem = Object.assign({ time: starttime }, item);
              let isLive = liveBegin <= timedItem.time;
              if (begin <= timedItem.time) {
                addItem(timedItem, isLive);
              } else {
                tailedItems.push(timedItem);
                tailedItemsDuration += timedItem.duration;
                // Only keep the last `liveBuffer` of items.
                while (
                  tailedItems.length > 1 &&
                  tailedItemsDuration - tailedItems[0].duration > liveBuffer
                ) {
                  tailedItemsDuration -= tailedItems.shift().duration;
                }
              }
              starttime += timedItem.duration;
            });
            parser.on("end", () => {
              currPlaylist = null;
              // If we are too ahead of the stream, make sure to get the
              // latest available items with a small buffer.
              if (!addedItems.length && tailedItems.length) {
                tailedItems.forEach((item) => {
                  addItem(item, true);
                });
              }
              // Refresh the playlist when remaining segments get low.
              refreshThreshold = Math.max(
                1,
                Math.ceil(addedItems.length * 0.01)
              );
              // Throttle refreshing the playlist by looking at the duration
              // of live items added on this refresh.
              minRefreshTime = addedItems.reduce(
                (total, item) => item.duration + total,
                0
              );
              fetchingPlaylist = false;
            });
          };
          refreshPlaylist();
          stream.end = () => {
            ended = true;
            streamQueue.die();
            requestQueue.die();
            clearTimeout(refreshTimeout);
            if (currPlaylist) {
              currPlaylist.unpipe();
              currPlaylist.abort();
            }
            if (currSegment) {
              currSegment.unpipe();
              currSegment.abort();
            }
            stream_1.PassThrough.prototype.end.call(stream, null);
          };
          return stream;
        };
        module.exports = m3u8stream;
      },
      {
        "./dash-mpd-parser": 71,
        "./m3u8-parser": 73,
        "./parse-time": 74,
        "./queue": 75,
        miniget: 76,
        stream: 555,
        url: 642,
      },
    ],
    73: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const stream_1 = require("stream");
        /**
         * A very simple m3u8 playlist file parser that detects tags and segments.
         */
        class m3u8Parser extends stream_1.Writable {
          constructor() {
            super();
            this._lastLine = "";
            this._seq = 0;
            this._nextItemDuration = null;
            this.on("finish", () => {
              this._parseLine(this._lastLine);
              this.emit("end");
            });
          }
          _parseLine(line) {
            let match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);
            if (match) {
              // This is a tag.
              const tag = match[1];
              const value = match[2] || "";
              switch (tag) {
                case "EXT-X-PROGRAM-DATE-TIME":
                  this.emit("starttime", new Date(value).getTime());
                  break;
                case "EXT-X-MEDIA-SEQUENCE":
                  this._seq = parseInt(value);
                  break;
                case "EXTINF":
                  this._nextItemDuration = Math.round(
                    parseFloat(value.split(",")[0]) * 1000
                  );
                  break;
                case "EXT-X-ENDLIST":
                  this.emit("endlist");
                  break;
              }
            } else if (!/^#/.test(line) && line.trim()) {
              // This is a segment
              this.emit("item", {
                url: line.trim(),
                seq: this._seq++,
                duration: this._nextItemDuration,
              });
            }
          }
          _write(chunk, encoding, callback) {
            let lines = chunk.toString("utf8").split("\n");
            if (this._lastLine) {
              lines[0] = this._lastLine + lines[0];
            }
            lines.forEach((line, i) => {
              if (i < lines.length - 1) {
                this._parseLine(line);
              } else {
                // Save the last line in case it has been broken up.
                this._lastLine = line;
              }
            });
            callback();
          }
        }
        exports.default = m3u8Parser;
      },
      { stream: 555 },
    ],
    74: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * Converts human friendly time to milliseconds. Supports the format
         * 00:00:00.000 for hours, minutes, seconds, and milliseconds respectively.
         * And 0ms, 0s, 0m, 0h, and together 1m1s.
         */
        const numberFormat = /^\d+$/;
        const timeFormat = /^(?:(?:(\d+):)?(\d{1,2}):)?(\d{1,2})(?:\.(\d{3}))?$/;
        const timeUnits = {
          ms: 1,
          s: 1000,
          m: 60000,
          h: 3600000,
        };
        exports.humanStr = (time) => {
          if (typeof time === "number") {
            return time;
          }
          if (numberFormat.test(time)) {
            return +time;
          }
          const firstFormat = timeFormat.exec(time);
          if (firstFormat) {
            return (
              +(firstFormat[1] || 0) * timeUnits.h +
              +(firstFormat[2] || 0) * timeUnits.m +
              +firstFormat[3] * timeUnits.s +
              +(firstFormat[4] || 0)
            );
          } else {
            let total = 0;
            const r = /(-?\d+)(ms|s|m|h)/g;
            let rs;
            while ((rs = r.exec(time)) != null) {
              total += +rs[1] * timeUnits[rs[2]];
            }
            return total;
          }
        };
        /**
         * Parses a duration string in the form of "123.456S", returns milliseconds.
         */
        exports.durationStr = (time) => {
          let total = 0;
          const r = /(\d+(?:\.\d+)?)(S|M|H)/g;
          let rs;
          while ((rs = r.exec(time)) != null) {
            total += +rs[1] * timeUnits[rs[2].toLowerCase()];
          }
          return total;
        };
      },
      {},
    ],
    75: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        class Queue {
          /**
           * A really simple queue with concurrency.
           */
          constructor(worker, options = {}) {
            this._worker = worker;
            this._concurrency = options.concurrency || 1;
            this.tasks = [];
            this.total = 0;
            this.active = 0;
          }
          /**
           * Push a task to the queue.
           */
          push(item, callback) {
            this.tasks.push({ item, callback });
            this.total++;
            this._next();
          }
          /**
           * Process next job in queue.
           */
          _next() {
            if (this.active >= this._concurrency || !this.tasks.length) {
              return;
            }
            const { item, callback } = this.tasks.shift();
            let callbackCalled = false;
            this.active++;
            this._worker(item, (err, result) => {
              if (callbackCalled) {
                return;
              }
              this.active--;
              callbackCalled = true;
              if (callback) {
                callback(err, result);
              }
              this._next();
            });
          }
          /**
           * Stops processing queued jobs.
           */
          die() {
            this.tasks = [];
          }
        }
        exports.default = Queue;
      },
      {},
    ],
    76: [
      function (require, module, exports) {
        (function (process) {
          "use strict";
          var __importDefault =
            (this && this.__importDefault) ||
            function (mod) {
              return mod && mod.__esModule ? mod : { default: mod };
            };
          const http_1 = __importDefault(require("http"));
          const https_1 = __importDefault(require("https"));
          const url_1 = require("url");
          const stream_1 = require("stream");
          const httpLibs = {
            "http:": http_1.default,
            "https:": https_1.default,
          };
          const redirectCodes = { 301: true, 302: true, 303: true, 307: true };
          const retryCodes = { 429: true, 503: true };
          const defaults = {
            maxRedirects: 2,
            maxRetries: 2,
            maxReconnects: 0,
            backoff: { inc: 100, max: 10000 },
          };
          function Miniget(url, options, callback) {
            if (typeof options === "function") {
              callback = options;
              options = {};
            } else if (!options) {
              options = {};
            }
            const opts = Object.assign({}, defaults, options);
            const stream = new stream_1.PassThrough({
              highWaterMark: opts.highWaterMark,
            });
            let myreq, mydecoded;
            let aborted = false;
            let redirects = 0;
            let retries = 0;
            let retryTimeout;
            let reconnects = 0;
            let contentLength;
            let acceptRanges = false;
            let rangeStart = 0,
              rangeEnd;
            let downloaded = 0;
            // Check if this is a ranged request.
            if (opts.headers && opts.headers.Range) {
              let r = /bytes=(\d+)-(\d+)?/.exec(opts.headers.Range + "");
              if (r) {
                rangeStart = parseInt(r[1], 10);
                rangeEnd = parseInt(r[2], 10);
              }
            }
            // Add `Accept-Encoding` header.
            if (opts.acceptEncoding) {
              opts.headers = Object.assign(
                {
                  "Accept-Encoding": Object.keys(opts.acceptEncoding).join(
                    ", "
                  ),
                },
                opts.headers
              );
            }
            const doRetry = (retryOptions = {}) => {
              if (aborted) {
                return false;
              }
              // If there is an error when the download has already started,
              // but not finished, try reconnecting.
              if (mydecoded && 0 < downloaded) {
                if (
                  acceptRanges &&
                  downloaded < contentLength &&
                  reconnects++ < opts.maxReconnects
                ) {
                  mydecoded = null;
                  retries = 0;
                  let inc = opts.backoff.inc;
                  let ms = Math.min(inc, opts.backoff.max);
                  retryTimeout = setTimeout(doDownload, ms);
                  stream.emit("reconnect", reconnects, retryOptions.err);
                  return true;
                }
              } else if (
                (!retryOptions.statusCode ||
                  (retryOptions.err &&
                    retryOptions.err.message === "ENOTFOUND")) &&
                retries++ < opts.maxRetries
              ) {
                let ms =
                  retryOptions.retryAfter ||
                  Math.min(retries * opts.backoff.inc, opts.backoff.max);
                retryTimeout = setTimeout(doDownload, ms);
                stream.emit("retry", retries, retryOptions.err);
                return true;
              }
              return false;
            };
            const onRequestError = (err, statusCode) => {
              if (!doRetry({ err, statusCode })) {
                stream.emit("error", err);
              }
            };
            const doDownload = () => {
              if (aborted) {
                return;
              }
              let parsed = url_1.parse(url);
              let httpLib = httpLibs[parsed.protocol];
              if (!httpLib) {
                stream.emit("error", Error("Invalid URL: " + url));
                return;
              }
              Object.assign(parsed, opts);
              if (acceptRanges && downloaded > 0) {
                let start = downloaded + rangeStart;
                let end = rangeEnd || "";
                parsed.headers = Object.assign({}, parsed.headers, {
                  Range: `bytes=${start}-${end}`,
                });
              }
              if (opts.transform) {
                parsed = opts.transform(parsed);
                if (parsed.protocol) {
                  httpLib = httpLibs[parsed.protocol];
                }
              }
              myreq = httpLib.get(parsed, (res) => {
                if (res.statusCode in redirectCodes) {
                  if (redirects++ >= opts.maxRedirects) {
                    stream.emit("error", Error("Too many redirects"));
                  } else {
                    url = res.headers.location;
                    setTimeout(
                      doDownload,
                      res.headers["retry-after"]
                        ? parseInt(res.headers["retry-after"], 10) * 1000
                        : 0
                    );
                    stream.emit("redirect", url);
                  }
                  return;
                  // Check for rate limiting.
                } else if (res.statusCode in retryCodes) {
                  doRetry({
                    retryAfter: parseInt(res.headers["retry-after"], 10),
                  });
                  return;
                } else if (res.statusCode < 200 || 400 <= res.statusCode) {
                  let err = Error("Status code: " + res.statusCode);
                  if (res.statusCode >= 500) {
                    onRequestError(err, res.statusCode);
                  } else {
                    stream.emit("error", err);
                  }
                  return;
                }
                let decoded = res;
                const cleanup = () => {
                  res.removeListener("data", ondata);
                  decoded.removeListener("end", onend);
                  decoded.removeListener("error", onerror);
                  res.removeListener("error", onerror);
                };
                const ondata = (chunk) => {
                  downloaded += chunk.length;
                };
                const onend = () => {
                  cleanup();
                  if (!doRetry()) {
                    stream.end();
                  }
                };
                const onerror = (err) => {
                  cleanup();
                  onRequestError(err);
                };
                if (opts.acceptEncoding && res.headers["content-encoding"]) {
                  for (let enc of res.headers["content-encoding"]
                    .split(", ")
                    .reverse()) {
                    let fn = opts.acceptEncoding[enc];
                    if (fn != null) {
                      decoded = decoded.pipe(fn());
                      decoded.on("error", onerror);
                    }
                  }
                }
                if (!contentLength) {
                  contentLength = parseInt(
                    res.headers["content-length"] + "",
                    10
                  );
                  acceptRanges =
                    res.headers["accept-ranges"] === "bytes" &&
                    contentLength > 0 &&
                    opts.maxReconnects > 0;
                }
                res.on("data", ondata);
                decoded.on("end", onend);
                decoded.pipe(stream, { end: !acceptRanges });
                mydecoded = decoded;
                stream.emit("response", res);
                res.on("error", onerror);
              });
              myreq.on("error", onRequestError);
              stream.emit("request", myreq);
            };
            stream.abort = () => {
              aborted = true;
              stream.emit("abort");
              if (myreq) {
                myreq.abort();
              }
              if (mydecoded) {
                mydecoded.unpipe(stream);
              }
              clearTimeout(retryTimeout);
            };
            process.nextTick(doDownload);
            if (callback) {
              let body = "",
                myres;
              stream.setEncoding("utf8");
              stream.on("data", (chunk) => (body += chunk));
              stream.on("response", (res) => (myres = res));
              stream.on("end", () => callback(null, myres, body));
              stream.on("error", callback);
            }
            return callback ? null : stream;
          }
          // istanbul ignore next
          // https://github.com/istanbuljs/nyc/issues/1209
          (function (Miniget) {
            Miniget.promise = (url, options) => {
              return new Promise((resolve, reject) => {
                Miniget(url, options, (err, res, body) => {
                  if (err) return reject(err);
                  resolve([res, body]);
                });
              });
            };
          })(Miniget || (Miniget = {}));
          module.exports = Miniget;
        }.call(this, require("_process")));
      },
      { _process: 80, http: undefined, https: 61, stream: 555, url: 642 },
    ],
    77: [
      function (require, module, exports) {
        //! moment.js

        (function (global, factory) {
          typeof exports === "object" && typeof module !== "undefined"
            ? (module.exports = factory())
            : typeof define === "function" && define.amd
            ? define(factory)
            : (global.moment = factory());
        })(this, function () {
          "use strict";

          var hookCallback;

          function hooks() {
            return hookCallback.apply(null, arguments);
          }

          // This is done to register the method called with moment()
          // without creating circular dependencies.
          function setHookCallback(callback) {
            hookCallback = callback;
          }

          function isArray(input) {
            return (
              input instanceof Array ||
              Object.prototype.toString.call(input) === "[object Array]"
            );
          }

          function isObject(input) {
            // IE8 will treat undefined and null as object if it wasn't for
            // input != null
            return (
              input != null &&
              Object.prototype.toString.call(input) === "[object Object]"
            );
          }

          function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) {
              return Object.getOwnPropertyNames(obj).length === 0;
            } else {
              var k;
              for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                  return false;
                }
              }
              return true;
            }
          }

          function isUndefined(input) {
            return input === void 0;
          }

          function isNumber(input) {
            return (
              typeof input === "number" ||
              Object.prototype.toString.call(input) === "[object Number]"
            );
          }

          function isDate(input) {
            return (
              input instanceof Date ||
              Object.prototype.toString.call(input) === "[object Date]"
            );
          }

          function map(arr, fn) {
            var res = [],
              i;
            for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
            }
            return res;
          }

          function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
          }

          function extend(a, b) {
            for (var i in b) {
              if (hasOwnProp(b, i)) {
                a[i] = b[i];
              }
            }

            if (hasOwnProp(b, "toString")) {
              a.toString = b.toString;
            }

            if (hasOwnProp(b, "valueOf")) {
              a.valueOf = b.valueOf;
            }

            return a;
          }

          function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
          }

          function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
              empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false,
              parsedDateParts: [],
              meridiem: null,
              rfc2822: false,
              weekdayMismatch: false,
            };
          }

          function getParsingFlags(m) {
            if (m._pf == null) {
              m._pf = defaultParsingFlags();
            }
            return m._pf;
          }

          var some;
          if (Array.prototype.some) {
            some = Array.prototype.some;
          } else {
            some = function (fun) {
              var t = Object(this);
              var len = t.length >>> 0;

              for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                  return true;
                }
              }

              return false;
            };
          }

          function isValid(m) {
            if (m._isValid == null) {
              var flags = getParsingFlags(m);
              var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
              });
              var isNowValid =
                !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                isNowValid =
                  isNowValid &&
                  flags.charsLeftOver === 0 &&
                  flags.unusedTokens.length === 0 &&
                  flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
              } else {
                return isNowValid;
              }
            }
            return m._isValid;
          }

          function createInvalid(flags) {
            var m = createUTC(NaN);
            if (flags != null) {
              extend(getParsingFlags(m), flags);
            } else {
              getParsingFlags(m).userInvalidated = true;
            }

            return m;
          }

          // Plugins that add properties should also add the key here (null value),
          // so we can properly clone ourselves.
          var momentProperties = (hooks.momentProperties = []);

          function copyConfig(to, from) {
            var i, prop, val;

            if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
            }
            if (!isUndefined(from._i)) {
              to._i = from._i;
            }
            if (!isUndefined(from._f)) {
              to._f = from._f;
            }
            if (!isUndefined(from._l)) {
              to._l = from._l;
            }
            if (!isUndefined(from._strict)) {
              to._strict = from._strict;
            }
            if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
            }
            if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
            }
            if (!isUndefined(from._offset)) {
              to._offset = from._offset;
            }
            if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
            }
            if (!isUndefined(from._locale)) {
              to._locale = from._locale;
            }

            if (momentProperties.length > 0) {
              for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                  to[prop] = val;
                }
              }
            }

            return to;
          }

          var updateInProgress = false;

          // Moment prototype object
          function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
            if (!this.isValid()) {
              this._d = new Date(NaN);
            }
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
              updateInProgress = true;
              hooks.updateOffset(this);
              updateInProgress = false;
            }
          }

          function isMoment(obj) {
            return (
              obj instanceof Moment ||
              (obj != null && obj._isAMomentObject != null)
            );
          }

          function absFloor(number) {
            if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
            } else {
              return Math.floor(number);
            }
          }

          function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
              value = 0;

            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
            }

            return value;
          }

          // compare two arrays, return the number of differences
          function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
            for (i = 0; i < len; i++) {
              if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
              ) {
                diffs++;
              }
            }
            return diffs + lengthDiff;
          }

          function warn(msg) {
            if (
              hooks.suppressDeprecationWarnings === false &&
              typeof console !== "undefined" &&
              console.warn
            ) {
              console.warn("Deprecation warning: " + msg);
            }
          }

          function deprecate(msg, fn) {
            var firstTime = true;

            return extend(function () {
              if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                  arg = "";
                  if (typeof arguments[i] === "object") {
                    arg += "\n[" + i + "] ";
                    for (var key in arguments[0]) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                  } else {
                    arg = arguments[i];
                  }
                  args.push(arg);
                }
                warn(
                  msg +
                    "\nArguments: " +
                    Array.prototype.slice.call(args).join("") +
                    "\n" +
                    new Error().stack
                );
                firstTime = false;
              }
              return fn.apply(this, arguments);
            }, fn);
          }

          var deprecations = {};

          function deprecateSimple(name, msg) {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(name, msg);
            }
            if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
            }
          }

          hooks.suppressDeprecationWarnings = false;
          hooks.deprecationHandler = null;

          function isFunction(input) {
            return (
              input instanceof Function ||
              Object.prototype.toString.call(input) === "[object Function]"
            );
          }

          function set(config) {
            var prop, i;
            for (i in config) {
              prop = config[i];
              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this["_" + i] = prop;
              }
            }
            this._config = config;
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
            // TODO: Remove "ordinalParse" fallback in next major release.
            this._dayOfMonthOrdinalParseLenient = new RegExp(
              (this._dayOfMonthOrdinalParse.source ||
                this._ordinalParse.source) +
                "|" +
                /\d{1,2}/.source
            );
          }

          function mergeConfigs(parentConfig, childConfig) {
            var res = extend({}, parentConfig),
              prop;
            for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                if (
                  isObject(parentConfig[prop]) &&
                  isObject(childConfig[prop])
                ) {
                  res[prop] = {};
                  extend(res[prop], parentConfig[prop]);
                  extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                  res[prop] = childConfig[prop];
                } else {
                  delete res[prop];
                }
              }
            }
            for (prop in parentConfig) {
              if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
              ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
              }
            }
            return res;
          }

          function Locale(config) {
            if (config != null) {
              this.set(config);
            }
          }

          var keys;

          if (Object.keys) {
            keys = Object.keys;
          } else {
            keys = function (obj) {
              var i,
                res = [];
              for (i in obj) {
                if (hasOwnProp(obj, i)) {
                  res.push(i);
                }
              }
              return res;
            };
          }

          var defaultCalendar = {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L",
          };

          function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar["sameElse"];
            return isFunction(output) ? output.call(mom, now) : output;
          }

          var defaultLongDateFormat = {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY h:mm A",
            LLLL: "dddd, MMMM D, YYYY h:mm A",
          };

          function longDateFormat(key) {
            var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

            if (format || !formatUpper) {
              return format;
            }

            this._longDateFormat[key] = formatUpper.replace(
              /MMMM|MM|DD|dddd/g,
              function (val) {
                return val.slice(1);
              }
            );

            return this._longDateFormat[key];
          }

          var defaultInvalidDate = "Invalid date";

          function invalidDate() {
            return this._invalidDate;
          }

          var defaultOrdinal = "%d";
          var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

          function ordinal(number) {
            return this._ordinal.replace("%d", number);
          }

          var defaultRelativeTime = {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years",
          };

          function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output)
              ? output(number, withoutSuffix, string, isFuture)
              : output.replace(/%d/i, number);
          }

          function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return isFunction(format)
              ? format(output)
              : format.replace(/%s/i, output);
          }

          var aliases = {};

          function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[
              shorthand
            ] = unit;
          }

          function normalizeUnits(units) {
            return typeof units === "string"
              ? aliases[units] || aliases[units.toLowerCase()]
              : undefined;
          }

          function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
              normalizedProp,
              prop;

            for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                  normalizedInput[normalizedProp] = inputObject[prop];
                }
              }
            }

            return normalizedInput;
          }

          var priorities = {};

          function addUnitPriority(unit, priority) {
            priorities[unit] = priority;
          }

          function getPrioritizedUnits(unitsObj) {
            var units = [];
            for (var u in unitsObj) {
              units.push({ unit: u, priority: priorities[u] });
            }
            units.sort(function (a, b) {
              return a.priority - b.priority;
            });
            return units;
          }

          function zeroFill(number, targetLength, forceSign) {
            var absNumber = "" + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
            return (
              (sign ? (forceSign ? "+" : "") : "-") +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
              absNumber
            );
          }

          var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

          var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

          var formatFunctions = {};

          var formatTokenFunctions = {};

          // token:    'M'
          // padded:   ['MM', 2]
          // ordinal:  'Mo'
          // callback: function () { this.month() + 1 }
          function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === "string") {
              func = function () {
                return this[callback]();
              };
            }
            if (token) {
              formatTokenFunctions[token] = func;
            }
            if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                return zeroFill(
                  func.apply(this, arguments),
                  padded[1],
                  padded[2]
                );
              };
            }
            if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                  func.apply(this, arguments),
                  token
                );
              };
            }
          }

          function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, "");
            }
            return input.replace(/\\/g, "");
          }

          function makeFormatFunction(format) {
            var array = format.match(formattingTokens),
              i,
              length;

            for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
              } else {
                array[i] = removeFormattingTokens(array[i]);
              }
            }

            return function (mom) {
              var output = "",
                i;
              for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                  ? array[i].call(mom, format)
                  : array[i];
              }
              return output;
            };
          }

          // format date using native date object
          function formatMoment(m, format) {
            if (!m.isValid()) {
              return m.localeData().invalidDate();
            }

            format = expandFormat(format, m.localeData());
            formatFunctions[format] =
              formatFunctions[format] || makeFormatFunction(format);

            return formatFunctions[format](m);
          }

          function expandFormat(format, locale) {
            var i = 5;

            function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
            }

            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
              );
              localFormattingTokens.lastIndex = 0;
              i -= 1;
            }

            return format;
          }

          var match1 = /\d/; //       0 - 9
          var match2 = /\d\d/; //      00 - 99
          var match3 = /\d{3}/; //     000 - 999
          var match4 = /\d{4}/; //    0000 - 9999
          var match6 = /[+-]?\d{6}/; // -999999 - 999999
          var match1to2 = /\d\d?/; //       0 - 99
          var match3to4 = /\d\d\d\d?/; //     999 - 9999
          var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
          var match1to3 = /\d{1,3}/; //       0 - 999
          var match1to4 = /\d{1,4}/; //       0 - 9999
          var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

          var matchUnsigned = /\d+/; //       0 - inf
          var matchSigned = /[+-]?\d+/; //    -inf - inf

          var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
          var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

          var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

          var regexes = {};

          function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex)
              ? regex
              : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
                };
          }

          function getParseRegexForToken(token, config) {
            if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
            }

            return regexes[token](config._strict, config._locale);
          }

          // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
          function unescapeFormat(s) {
            return regexEscape(
              s
                .replace("\\", "")
                .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                  matched,
                  p1,
                  p2,
                  p3,
                  p4
                ) {
                  return p1 || p2 || p3 || p4;
                })
            );
          }

          function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          }

          var tokens = {};

          function addParseToken(token, callback) {
            var i,
              func = callback;
            if (typeof token === "string") {
              token = [token];
            }
            if (isNumber(callback)) {
              func = function (input, array) {
                array[callback] = toInt(input);
              };
            }
            for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
            }
          }

          function addWeekParseToken(token, callback) {
            addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
            });
          }

          function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
            }
          }

          var YEAR = 0;
          var MONTH = 1;
          var DATE = 2;
          var HOUR = 3;
          var MINUTE = 4;
          var SECOND = 5;
          var MILLISECOND = 6;
          var WEEK = 7;
          var WEEKDAY = 8;

          // FORMATTING

          addFormatToken("Y", 0, 0, function () {
            var y = this.year();
            return y <= 9999 ? "" + y : "+" + y;
          });

          addFormatToken(0, ["YY", 2], 0, function () {
            return this.year() % 100;
          });

          addFormatToken(0, ["YYYY", 4], 0, "year");
          addFormatToken(0, ["YYYYY", 5], 0, "year");
          addFormatToken(0, ["YYYYYY", 6, true], 0, "year");

          // ALIASES

          addUnitAlias("year", "y");

          // PRIORITIES

          addUnitPriority("year", 1);

          // PARSING

          addRegexToken("Y", matchSigned);
          addRegexToken("YY", match1to2, match2);
          addRegexToken("YYYY", match1to4, match4);
          addRegexToken("YYYYY", match1to6, match6);
          addRegexToken("YYYYYY", match1to6, match6);

          addParseToken(["YYYYY", "YYYYYY"], YEAR);
          addParseToken("YYYY", function (input, array) {
            array[YEAR] =
              input.length === 2
                ? hooks.parseTwoDigitYear(input)
                : toInt(input);
          });
          addParseToken("YY", function (input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input);
          });
          addParseToken("Y", function (input, array) {
            array[YEAR] = parseInt(input, 10);
          });

          // HELPERS

          function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
          }

          function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
          }

          // HOOKS

          hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
          };

          // MOMENTS

          var getSetYear = makeGetSet("FullYear", true);

          function getIsLeapYear() {
            return isLeapYear(this.year());
          }

          function makeGetSet(unit, keepTime) {
            return function (value) {
              if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
              } else {
                return get(this, unit);
              }
            };
          }

          function get(mom, unit) {
            return mom.isValid()
              ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]()
              : NaN;
          }

          function set$1(mom, unit, value) {
            if (mom.isValid() && !isNaN(value)) {
              if (
                unit === "FullYear" &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
              ) {
                mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                  value,
                  mom.month(),
                  daysInMonth(value, mom.month())
                );
              } else {
                mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
              }
            }
          }

          // MOMENTS

          function stringGet(units) {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units]();
            }
            return this;
          }

          function stringSet(units, value) {
            if (typeof units === "object") {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units);
              for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
              }
            } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                return this[units](value);
              }
            }
            return this;
          }

          function mod(n, x) {
            return ((n % x) + x) % x;
          }

          var indexOf;

          if (Array.prototype.indexOf) {
            indexOf = Array.prototype.indexOf;
          } else {
            indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                  return i;
                }
              }
              return -1;
            };
          }

          function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) {
              return NaN;
            }
            var modMonth = mod(month, 12);
            year += (month - modMonth) / 12;
            return modMonth === 1
              ? isLeapYear(year)
                ? 29
                : 28
              : 31 - ((modMonth % 7) % 2);
          }

          // FORMATTING

          addFormatToken("M", ["MM", 2], "Mo", function () {
            return this.month() + 1;
          });

          addFormatToken("MMM", 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
          });

          addFormatToken("MMMM", 0, 0, function (format) {
            return this.localeData().months(this, format);
          });

          // ALIASES

          addUnitAlias("month", "M");

          // PRIORITY

          addUnitPriority("month", 8);

          // PARSING

          addRegexToken("M", match1to2);
          addRegexToken("MM", match1to2, match2);
          addRegexToken("MMM", function (isStrict, locale) {
            return locale.monthsShortRegex(isStrict);
          });
          addRegexToken("MMMM", function (isStrict, locale) {
            return locale.monthsRegex(isStrict);
          });

          addParseToken(["M", "MM"], function (input, array) {
            array[MONTH] = toInt(input) - 1;
          });

          addParseToken(["MMM", "MMMM"], function (
            input,
            array,
            config,
            token
          ) {
            var month = config._locale.monthsParse(
              input,
              token,
              config._strict
            );
            // if we didn't find a month name, mark the date as invalid.
            if (month != null) {
              array[MONTH] = month;
            } else {
              getParsingFlags(config).invalidMonth = input;
            }
          });

          // LOCALES

          var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
          var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
            "_"
          );
          function localeMonths(m, format) {
            if (!m) {
              return isArray(this._months)
                ? this._months
                : this._months["standalone"];
            }
            return isArray(this._months)
              ? this._months[m.month()]
              : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                    ? "format"
                    : "standalone"
                ][m.month()];
          }

          var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split(
            "_"
          );
          function localeMonthsShort(m, format) {
            if (!m) {
              return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort["standalone"];
            }
            return isArray(this._monthsShort)
              ? this._monthsShort[m.month()]
              : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"
                ][m.month()];
          }

          function handleStrictParse(monthName, format, strict) {
            var i,
              ii,
              mom,
              llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                  mom,
                  ""
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(
                  mom,
                  ""
                ).toLocaleLowerCase();
              }
            }

            if (strict) {
              if (format === "MMM") {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
              } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
              }
            } else {
              if (format === "MMM") {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
              } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
              }
            }
          }

          function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;

            if (this._monthsParseExact) {
              return handleStrictParse.call(this, monthName, format, strict);
            }

            if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
            }

            // TODO: add sorting
            // Sorting makes sure if one month (or abbr) is a prefix of another
            // see sorting in computeMonthsParse
            for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                  "^" + this.months(mom, "").replace(".", "") + "$",
                  "i"
                );
                this._shortMonthsParse[i] = new RegExp(
                  "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                  "i"
                );
              }
              if (!strict && !this._monthsParse[i]) {
                regex =
                  "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
              }
              // test the regex
              if (
                strict &&
                format === "MMMM" &&
                this._longMonthsParse[i].test(monthName)
              ) {
                return i;
              } else if (
                strict &&
                format === "MMM" &&
                this._shortMonthsParse[i].test(monthName)
              ) {
                return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
              }
            }
          }

          // MOMENTS

          function setMonth(mom, value) {
            var dayOfMonth;

            if (!mom.isValid()) {
              // No op
              return mom;
            }

            if (typeof value === "string") {
              if (/^\d+$/.test(value)) {
                value = toInt(value);
              } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                  return mom;
                }
              }
            }

            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](
              value,
              dayOfMonth
            );
            return mom;
          }

          function getSetMonth(value) {
            if (value != null) {
              setMonth(this, value);
              hooks.updateOffset(this, true);
              return this;
            } else {
              return get(this, "Month");
            }
          }

          function getDaysInMonth() {
            return daysInMonth(this.year(), this.month());
          }

          var defaultMonthsShortRegex = matchWord;
          function monthsShortRegex(isStrict) {
            if (this._monthsParseExact) {
              if (!hasOwnProp(this, "_monthsRegex")) {
                computeMonthsParse.call(this);
              }
              if (isStrict) {
                return this._monthsShortStrictRegex;
              } else {
                return this._monthsShortRegex;
              }
            } else {
              if (!hasOwnProp(this, "_monthsShortRegex")) {
                this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
            }
          }

          var defaultMonthsRegex = matchWord;
          function monthsRegex(isStrict) {
            if (this._monthsParseExact) {
              if (!hasOwnProp(this, "_monthsRegex")) {
                computeMonthsParse.call(this);
              }
              if (isStrict) {
                return this._monthsStrictRegex;
              } else {
                return this._monthsRegex;
              }
            } else {
              if (!hasOwnProp(this, "_monthsRegex")) {
                this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
            }
          }

          function computeMonthsParse() {
            function cmpLenRev(a, b) {
              return b.length - a.length;
            }

            var shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom;
            for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ""));
              longPieces.push(this.months(mom, ""));
              mixedPieces.push(this.months(mom, ""));
              mixedPieces.push(this.monthsShort(mom, ""));
            }
            // Sorting makes sure if one month (or abbr) is a prefix of another it
            // will match the longer piece.
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
            }
            for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._monthsRegex = new RegExp(
              "^(" + mixedPieces.join("|") + ")",
              "i"
            );
            this._monthsShortRegex = this._monthsRegex;
            this._monthsStrictRegex = new RegExp(
              "^(" + longPieces.join("|") + ")",
              "i"
            );
            this._monthsShortStrictRegex = new RegExp(
              "^(" + shortPieces.join("|") + ")",
              "i"
            );
          }

          function createDate(y, m, d, h, M, s, ms) {
            // can't just apply() to create a date:
            // https://stackoverflow.com/q/181348
            var date;
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              date = new Date(y + 400, m, d, h, M, s, ms);
              if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
              }
            } else {
              date = new Date(y, m, d, h, M, s, ms);
            }

            return date;
          }

          function createUTCDate(y) {
            var date;
            // the Date.UTC function remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
              var args = Array.prototype.slice.call(arguments);
              // preserve leap years using a full 400 year cycle, then reset
              args[0] = y + 400;
              date = new Date(Date.UTC.apply(null, args));
              if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
              }
            } else {
              date = new Date(Date.UTC.apply(null, arguments));
            }

            return date;
          }

          // start-of-first-week - start-of-year
          function firstWeekOffset(year, dow, doy) {
            var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

            return -fwdlw + fwd - 1;
          }

          // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
          function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear,
              resDayOfYear;

            if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
            } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
            } else {
              resYear = year;
              resDayOfYear = dayOfYear;
            }

            return {
              year: resYear,
              dayOfYear: resDayOfYear,
            };
          }

          function weekOfYear(mom, dow, doy) {
            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek,
              resYear;

            if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
            } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
            } else {
              resYear = mom.year();
              resWeek = week;
            }

            return {
              week: resWeek,
              year: resYear,
            };
          }

          function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
          }

          // FORMATTING

          addFormatToken("w", ["ww", 2], "wo", "week");
          addFormatToken("W", ["WW", 2], "Wo", "isoWeek");

          // ALIASES

          addUnitAlias("week", "w");
          addUnitAlias("isoWeek", "W");

          // PRIORITIES

          addUnitPriority("week", 5);
          addUnitPriority("isoWeek", 5);

          // PARSING

          addRegexToken("w", match1to2);
          addRegexToken("ww", match1to2, match2);
          addRegexToken("W", match1to2);
          addRegexToken("WW", match1to2, match2);

          addWeekParseToken(["w", "ww", "W", "WW"], function (
            input,
            week,
            config,
            token
          ) {
            week[token.substr(0, 1)] = toInt(input);
          });

          // HELPERS

          // LOCALES

          function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
          }

          var defaultLocaleWeek = {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
          };

          function localeFirstDayOfWeek() {
            return this._week.dow;
          }

          function localeFirstDayOfYear() {
            return this._week.doy;
          }

          // MOMENTS

          function getSetWeek(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, "d");
          }

          function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, "d");
          }

          // FORMATTING

          addFormatToken("d", 0, "do", "day");

          addFormatToken("dd", 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
          });

          addFormatToken("ddd", 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
          });

          addFormatToken("dddd", 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
          });

          addFormatToken("e", 0, 0, "weekday");
          addFormatToken("E", 0, 0, "isoWeekday");

          // ALIASES

          addUnitAlias("day", "d");
          addUnitAlias("weekday", "e");
          addUnitAlias("isoWeekday", "E");

          // PRIORITY
          addUnitPriority("day", 11);
          addUnitPriority("weekday", 11);
          addUnitPriority("isoWeekday", 11);

          // PARSING

          addRegexToken("d", match1to2);
          addRegexToken("e", match1to2);
          addRegexToken("E", match1to2);
          addRegexToken("dd", function (isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict);
          });
          addRegexToken("ddd", function (isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict);
          });
          addRegexToken("dddd", function (isStrict, locale) {
            return locale.weekdaysRegex(isStrict);
          });

          addWeekParseToken(["dd", "ddd", "dddd"], function (
            input,
            week,
            config,
            token
          ) {
            var weekday = config._locale.weekdaysParse(
              input,
              token,
              config._strict
            );
            // if we didn't get a weekday name, mark the date as invalid
            if (weekday != null) {
              week.d = weekday;
            } else {
              getParsingFlags(config).invalidWeekday = input;
            }
          });

          addWeekParseToken(["d", "e", "E"], function (
            input,
            week,
            config,
            token
          ) {
            week[token] = toInt(input);
          });

          // HELPERS

          function parseWeekday(input, locale) {
            if (typeof input !== "string") {
              return input;
            }

            if (!isNaN(input)) {
              return parseInt(input, 10);
            }

            input = locale.weekdaysParse(input);
            if (typeof input === "number") {
              return input;
            }

            return null;
          }

          function parseIsoWeekday(input, locale) {
            if (typeof input === "string") {
              return locale.weekdaysParse(input) % 7 || 7;
            }
            return isNaN(input) ? null : input;
          }

          // LOCALES
          function shiftWeekdays(ws, n) {
            return ws.slice(n, 7).concat(ws.slice(0, n));
          }

          var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
            "_"
          );
          function localeWeekdays(m, format) {
            var weekdays = isArray(this._weekdays)
              ? this._weekdays
              : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                    ? "format"
                    : "standalone"
                ];
            return m === true
              ? shiftWeekdays(weekdays, this._week.dow)
              : m
              ? weekdays[m.day()]
              : weekdays;
          }

          var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split(
            "_"
          );
          function localeWeekdaysShort(m) {
            return m === true
              ? shiftWeekdays(this._weekdaysShort, this._week.dow)
              : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
          }

          var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
          function localeWeekdaysMin(m) {
            return m === true
              ? shiftWeekdays(this._weekdaysMin, this._week.dow)
              : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
          }

          function handleStrictParse$1(weekdayName, format, strict) {
            var i,
              ii,
              mom,
              llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                  mom,
                  ""
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                  mom,
                  ""
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(
                  mom,
                  ""
                ).toLocaleLowerCase();
              }
            }

            if (strict) {
              if (format === "dddd") {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
              } else if (format === "ddd") {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              }
            } else {
              if (format === "dddd") {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              } else if (format === "ddd") {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              }
            }
          }

          function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;

            if (this._weekdaysParseExact) {
              return handleStrictParse$1.call(
                this,
                weekdayName,
                format,
                strict
              );
            }

            if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                  "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                  "i"
                );
                this._shortWeekdaysParse[i] = new RegExp(
                  "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                  "i"
                );
                this._minWeekdaysParse[i] = new RegExp(
                  "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                  "i"
                );
              }
              if (!this._weekdaysParse[i]) {
                regex =
                  "^" +
                  this.weekdays(mom, "") +
                  "|^" +
                  this.weekdaysShort(mom, "") +
                  "|^" +
                  this.weekdaysMin(mom, "");
                this._weekdaysParse[i] = new RegExp(
                  regex.replace(".", ""),
                  "i"
                );
              }
              // test the regex
              if (
                strict &&
                format === "dddd" &&
                this._fullWeekdaysParse[i].test(weekdayName)
              ) {
                return i;
              } else if (
                strict &&
                format === "ddd" &&
                this._shortWeekdaysParse[i].test(weekdayName)
              ) {
                return i;
              } else if (
                strict &&
                format === "dd" &&
                this._minWeekdaysParse[i].test(weekdayName)
              ) {
                return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
              }
            }
          }

          // MOMENTS

          function getSetDayOfWeek(input) {
            if (!this.isValid()) {
              return input != null ? this : NaN;
            }
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, "d");
            } else {
              return day;
            }
          }

          function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) {
              return input != null ? this : NaN;
            }
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, "d");
          }

          function getSetISODayOfWeek(input) {
            if (!this.isValid()) {
              return input != null ? this : NaN;
            }

            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.

            if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
            } else {
              return this.day() || 7;
            }
          }

          var defaultWeekdaysRegex = matchWord;
          function weekdaysRegex(isStrict) {
            if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                return this._weekdaysStrictRegex;
              } else {
                return this._weekdaysRegex;
              }
            } else {
              if (!hasOwnProp(this, "_weekdaysRegex")) {
                this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
            }
          }

          var defaultWeekdaysShortRegex = matchWord;
          function weekdaysShortRegex(isStrict) {
            if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                return this._weekdaysShortStrictRegex;
              } else {
                return this._weekdaysShortRegex;
              }
            } else {
              if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
            }
          }

          var defaultWeekdaysMinRegex = matchWord;
          function weekdaysMinRegex(isStrict) {
            if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                return this._weekdaysMinStrictRegex;
              } else {
                return this._weekdaysMinRegex;
              }
            } else {
              if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
            }
          }

          function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
              return b.length - a.length;
            }

            var minPieces = [],
              shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom,
              minp,
              shortp,
              longp;
            for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, 1]).day(i);
              minp = this.weekdaysMin(mom, "");
              shortp = this.weekdaysShort(mom, "");
              longp = this.weekdays(mom, "");
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
            }
            // Sorting makes sure if one weekday (or abbr) is a prefix of another it
            // will match the longer piece.
            minPieces.sort(cmpLenRev);
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 7; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
              mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._weekdaysRegex = new RegExp(
              "^(" + mixedPieces.join("|") + ")",
              "i"
            );
            this._weekdaysShortRegex = this._weekdaysRegex;
            this._weekdaysMinRegex = this._weekdaysRegex;

            this._weekdaysStrictRegex = new RegExp(
              "^(" + longPieces.join("|") + ")",
              "i"
            );
            this._weekdaysShortStrictRegex = new RegExp(
              "^(" + shortPieces.join("|") + ")",
              "i"
            );
            this._weekdaysMinStrictRegex = new RegExp(
              "^(" + minPieces.join("|") + ")",
              "i"
            );
          }

          // FORMATTING

          function hFormat() {
            return this.hours() % 12 || 12;
          }

          function kFormat() {
            return this.hours() || 24;
          }

          addFormatToken("H", ["HH", 2], 0, "hour");
          addFormatToken("h", ["hh", 2], 0, hFormat);
          addFormatToken("k", ["kk", 2], 0, kFormat);

          addFormatToken("hmm", 0, 0, function () {
            return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
          });

          addFormatToken("hmmss", 0, 0, function () {
            return (
              "" +
              hFormat.apply(this) +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
            );
          });

          addFormatToken("Hmm", 0, 0, function () {
            return "" + this.hours() + zeroFill(this.minutes(), 2);
          });

          addFormatToken("Hmmss", 0, 0, function () {
            return (
              "" +
              this.hours() +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
            );
          });

          function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
              );
            });
          }

          meridiem("a", true);
          meridiem("A", false);

          // ALIASES

          addUnitAlias("hour", "h");

          // PRIORITY
          addUnitPriority("hour", 13);

          // PARSING

          function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse;
          }

          addRegexToken("a", matchMeridiem);
          addRegexToken("A", matchMeridiem);
          addRegexToken("H", match1to2);
          addRegexToken("h", match1to2);
          addRegexToken("k", match1to2);
          addRegexToken("HH", match1to2, match2);
          addRegexToken("hh", match1to2, match2);
          addRegexToken("kk", match1to2, match2);

          addRegexToken("hmm", match3to4);
          addRegexToken("hmmss", match5to6);
          addRegexToken("Hmm", match3to4);
          addRegexToken("Hmmss", match5to6);

          addParseToken(["H", "HH"], HOUR);
          addParseToken(["k", "kk"], function (input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = kInput === 24 ? 0 : kInput;
          });
          addParseToken(["a", "A"], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
          });
          addParseToken(["h", "hh"], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
          });
          addParseToken("hmm", function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
            getParsingFlags(config).bigHour = true;
          });
          addParseToken("hmmss", function (input, array, config) {
            var pos1 = input.length - 4;
            var pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
            getParsingFlags(config).bigHour = true;
          });
          addParseToken("Hmm", function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
          });
          addParseToken("Hmmss", function (input, array, config) {
            var pos1 = input.length - 4;
            var pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
          });

          // LOCALES

          function localeIsPM(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + "").toLowerCase().charAt(0) === "p";
          }

          var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
          function localeMeridiem(hours, minutes, isLower) {
            if (hours > 11) {
              return isLower ? "pm" : "PM";
            } else {
              return isLower ? "am" : "AM";
            }
          }

          // MOMENTS

          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          var getSetHour = makeGetSet("Hours", true);

          var baseConfig = {
            calendar: defaultCalendar,
            longDateFormat: defaultLongDateFormat,
            invalidDate: defaultInvalidDate,
            ordinal: defaultOrdinal,
            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
            relativeTime: defaultRelativeTime,

            months: defaultLocaleMonths,
            monthsShort: defaultLocaleMonthsShort,

            week: defaultLocaleWeek,

            weekdays: defaultLocaleWeekdays,
            weekdaysMin: defaultLocaleWeekdaysMin,
            weekdaysShort: defaultLocaleWeekdaysShort,

            meridiemParse: defaultLocaleMeridiemParse,
          };

          // internal storage for locale config files
          var locales = {};
          var localeFamilies = {};
          var globalLocale;

          function normalizeLocale(key) {
            return key ? key.toLowerCase().replace("_", "-") : key;
          }

          // pick the locale from the array
          // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
          // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
          function chooseLocale(names) {
            var i = 0,
              j,
              next,
              locale,
              split;

            while (i < names.length) {
              split = normalizeLocale(names[i]).split("-");
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split("-") : null;
              while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                  return locale;
                }
                if (
                  next &&
                  next.length >= j &&
                  compareArrays(split, next, true) >= j - 1
                ) {
                  //the next array item is better than a shallower substring of this one
                  break;
                }
                j--;
              }
              i++;
            }
            return globalLocale;
          }

          function loadLocale(name) {
            var oldLocale = null;
            // TODO: Find a better way to register and load all the locales in Node
            if (
              !locales[name] &&
              typeof module !== "undefined" &&
              module &&
              module.exports
            ) {
              try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire("./locale/" + name);
                getSetGlobalLocale(oldLocale);
              } catch (e) {}
            }
            return locales[name];
          }

          // This function will load locale and then set the global locale.  If
          // no arguments are passed in, it will simply return the current global
          // locale key.
          function getSetGlobalLocale(key, values) {
            var data;
            if (key) {
              if (isUndefined(values)) {
                data = getLocale(key);
              } else {
                data = defineLocale(key, values);
              }

              if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
              } else {
                if (typeof console !== "undefined" && console.warn) {
                  //warn user if arguments are passed but the locale could not be set
                  console.warn(
                    "Locale " + key + " not found. Did you forget to load it?"
                  );
                }
              }
            }

            return globalLocale._abbr;
          }

          function defineLocale(name, config) {
            if (config !== null) {
              var locale,
                parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                deprecateSimple(
                  "defineLocaleOverride",
                  "use moment.updateLocale(localeName, config) to change " +
                    "an existing locale. moment.defineLocale(localeName, " +
                    "config) should only be used for creating a new locale " +
                    "See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
                );
                parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                  parentConfig = locales[config.parentLocale]._config;
                } else {
                  locale = loadLocale(config.parentLocale);
                  if (locale != null) {
                    parentConfig = locale._config;
                  } else {
                    if (!localeFamilies[config.parentLocale]) {
                      localeFamilies[config.parentLocale] = [];
                    }
                    localeFamilies[config.parentLocale].push({
                      name: name,
                      config: config,
                    });
                    return null;
                  }
                }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                  defineLocale(x.name, x.config);
                });
              }

              // backwards compat for now: also set the locale
              // make sure we set the locale AFTER all child locales have been
              // created, so we won't end up with the child locale set.
              getSetGlobalLocale(name);

              return locales[name];
            } else {
              // useful for testing
              delete locales[name];
              return null;
            }
          }

          function updateLocale(name, config) {
            if (config != null) {
              var locale,
                tmpLocale,
                parentConfig = baseConfig;
              // MERGE
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;

              // backwards compat for now: also set the locale
              getSetGlobalLocale(name);
            } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                  locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                  delete locales[name];
                }
              }
            }
            return locales[name];
          }

          // returns locale data
          function getLocale(key) {
            var locale;

            if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
            }

            if (!key) {
              return globalLocale;
            }

            if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                return locale;
              }
              key = [key];
            }

            return chooseLocale(key);
          }

          function listLocales() {
            return keys(locales);
          }

          function checkOverflow(m) {
            var overflow;
            var a = m._a;

            if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                  ? MONTH
                  : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                  ? DATE
                  : a[HOUR] < 0 ||
                    a[HOUR] > 24 ||
                    (a[HOUR] === 24 &&
                      (a[MINUTE] !== 0 ||
                        a[SECOND] !== 0 ||
                        a[MILLISECOND] !== 0))
                  ? HOUR
                  : a[MINUTE] < 0 || a[MINUTE] > 59
                  ? MINUTE
                  : a[SECOND] < 0 || a[SECOND] > 59
                  ? SECOND
                  : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                  ? MILLISECOND
                  : -1;

              if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
              ) {
                overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
            }

            return m;
          }

          // Pick the first defined of two or three arguments.
          function defaults(a, b, c) {
            if (a != null) {
              return a;
            }
            if (b != null) {
              return b;
            }
            return c;
          }

          function currentDateArray(config) {
            // hooks is actually the exported moment object
            var nowValue = new Date(hooks.now());
            if (config._useUTC) {
              return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
              ];
            }
            return [
              nowValue.getFullYear(),
              nowValue.getMonth(),
              nowValue.getDate(),
            ];
          }

          // convert an array to a date.
          // the array should mirror the parameters below
          // note: all values past the year are optional and will default to the lowest possible value.
          // [year, month, day , hour, minute, second, millisecond]
          function configFromArray(config) {
            var i,
              date,
              input = [],
              currentDate,
              expectedWeekday,
              yearToUse;

            if (config._d) {
              return;
            }

            currentDate = currentDateArray(config);

            //compute day of the year from weeks and weekdays
            if (
              config._w &&
              config._a[DATE] == null &&
              config._a[MONTH] == null
            ) {
              dayOfYearFromWeekInfo(config);
            }

            //if the day of the year is set, figure out what it is
            if (config._dayOfYear != null) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
              ) {
                getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
            }

            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
            }

            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
              config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
            }

            // Check for 24:00:00.000
            if (
              config._a[HOUR] === 24 &&
              config._a[MINUTE] === 0 &&
              config._a[SECOND] === 0 &&
              config._a[MILLISECOND] === 0
            ) {
              config._nextDay = true;
              config._a[HOUR] = 0;
            }

            config._d = (config._useUTC ? createUTCDate : createDate).apply(
              null,
              input
            );
            expectedWeekday = config._useUTC
              ? config._d.getUTCDay()
              : config._d.getDay();

            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }

            if (config._nextDay) {
              config._a[HOUR] = 24;
            }

            // check for mismatching day of week
            if (
              config._w &&
              typeof config._w.d !== "undefined" &&
              config._w.d !== expectedWeekday
            ) {
              getParsingFlags(config).weekdayMismatch = true;
            }
          }

          function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
              );
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
              }
            } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              var curWeek = weekOfYear(createLocal(), dow, doy);

              weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

              // Default to current week.
              week = defaults(w.w, curWeek.week);

              if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                  weekdayOverflow = true;
                }
              } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                  weekdayOverflow = true;
                }
              } else {
                // default to beginning of week
                weekday = dow;
              }
            }
            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
            } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
            } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
            }
          }

          // iso 8601 regex
          // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
          var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
          var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

          var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

          var isoDates = [
            ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
            ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
            ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
            ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
            ["YYYY-DDD", /\d{4}-\d{3}/],
            ["YYYY-MM", /\d{4}-\d\d/, false],
            ["YYYYYYMMDD", /[+-]\d{10}/],
            ["YYYYMMDD", /\d{8}/],
            // YYYYMM is NOT allowed by the standard
            ["GGGG[W]WWE", /\d{4}W\d{3}/],
            ["GGGG[W]WW", /\d{4}W\d{2}/, false],
            ["YYYYDDD", /\d{7}/],
          ];

          // iso time formats and regexes
          var isoTimes = [
            ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
            ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
            ["HH:mm:ss", /\d\d:\d\d:\d\d/],
            ["HH:mm", /\d\d:\d\d/],
            ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
            ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
            ["HHmmss", /\d\d\d\d\d\d/],
            ["HHmm", /\d\d\d\d/],
            ["HH", /\d\d/],
          ];

          var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

          // date from iso format
          function configFromISO(config) {
            var i,
              l,
              string = config._i,
              match =
                extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime,
              dateFormat,
              timeFormat,
              tzFormat;

            if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                  dateFormat = isoDates[i][0];
                  allowTime = isoDates[i][2] !== false;
                  break;
                }
              }
              if (dateFormat == null) {
                config._isValid = false;
                return;
              }
              if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                  if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || " ") + isoTimes[i][0];
                    break;
                  }
                }
                if (timeFormat == null) {
                  config._isValid = false;
                  return;
                }
              }
              if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
              }
              if (match[4]) {
                if (tzRegex.exec(match[4])) {
                  tzFormat = "Z";
                } else {
                  config._isValid = false;
                  return;
                }
              }
              config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
              configFromStringAndFormat(config);
            } else {
              config._isValid = false;
            }
          }

          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

          function extractFromRFC2822Strings(
            yearStr,
            monthStr,
            dayStr,
            hourStr,
            minuteStr,
            secondStr
          ) {
            var result = [
              untruncateYear(yearStr),
              defaultLocaleMonthsShort.indexOf(monthStr),
              parseInt(dayStr, 10),
              parseInt(hourStr, 10),
              parseInt(minuteStr, 10),
            ];

            if (secondStr) {
              result.push(parseInt(secondStr, 10));
            }

            return result;
          }

          function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            if (year <= 49) {
              return 2000 + year;
            } else if (year <= 999) {
              return 1900 + year;
            }
            return year;
          }

          function preprocessRFC2822(s) {
            // Remove comments and folding whitespace and replace multiple-spaces with a single space
            return s
              .replace(/\([^)]*\)|[\n\t]/g, " ")
              .replace(/(\s\s+)/g, " ")
              .replace(/^\s\s*/, "")
              .replace(/\s\s*$/, "");
          }

          function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
              // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
              var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(
                  weekdayStr
                ),
                weekdayActual = new Date(
                  parsedInput[0],
                  parsedInput[1],
                  parsedInput[2]
                ).getDay();
              if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
              }
            }
            return true;
          }

          var obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
          };

          function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) {
              return obsOffsets[obsOffset];
            } else if (militaryOffset) {
              // the only allowed military tz is Z
              return 0;
            } else {
              var hm = parseInt(numOffset, 10);
              var m = hm % 100,
                h = (hm - m) / 100;
              return h * 60 + m;
            }
          }

          // date and time from ref 2822 format
          function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i));
            if (match) {
              var parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
              );
              if (!checkWeekday(match[1], parsedArray, config)) {
                return;
              }

              config._a = parsedArray;
              config._tzm = calculateOffset(match[8], match[9], match[10]);

              config._d = createUTCDate.apply(null, config._a);
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

              getParsingFlags(config).rfc2822 = true;
            } else {
              config._isValid = false;
            }
          }

          // date from iso format or fallback
          function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);

            if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
            }

            configFromISO(config);
            if (config._isValid === false) {
              delete config._isValid;
            } else {
              return;
            }

            configFromRFC2822(config);
            if (config._isValid === false) {
              delete config._isValid;
            } else {
              return;
            }

            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
          }

          hooks.createFromInputFallback = deprecate(
            "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " +
              "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " +
              "discouraged and will be removed in an upcoming major release. Please refer to " +
              "http://momentjs.com/guides/#/warnings/js-date/ for more info.",
            function (config) {
              config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
            }
          );

          // constant that refers to the ISO standard
          hooks.ISO_8601 = function () {};

          // constant that refers to the RFC 2822 form
          hooks.RFC_2822 = function () {};

          // date from string and format string
          function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === hooks.ISO_8601) {
              configFromISO(config);
              return;
            }
            if (config._f === hooks.RFC_2822) {
              configFromRFC2822(config);
              return;
            }
            config._a = [];
            getParsingFlags(config).empty = true;

            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = "" + config._i,
              i,
              parsedInput,
              tokens,
              token,
              skipped,
              stringLength = string.length,
              totalParsedInputLength = 0;

            tokens =
              expandFormat(config._f, config._locale).match(formattingTokens) ||
              [];

            for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(
                getParseRegexForToken(token, config)
              ) || [])[0];
              // console.log('token', token, 'parsedInput', parsedInput,
              //         'regex', getParseRegexForToken(token, config));
              if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                  getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                  string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                if (parsedInput) {
                  getParsingFlags(config).empty = false;
                } else {
                  getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
              } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
              }
            }

            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver =
              stringLength - totalParsedInputLength;
            if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
            }

            // clear _12h flag if hour is <= 12
            if (
              config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0
            ) {
              getParsingFlags(config).bigHour = undefined;
            }

            getParsingFlags(config).parsedDateParts = config._a.slice(0);
            getParsingFlags(config).meridiem = config._meridiem;
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(
              config._locale,
              config._a[HOUR],
              config._meridiem
            );

            configFromArray(config);
            checkOverflow(config);
          }

          function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;

            if (meridiem == null) {
              // nothing to do
              return hour;
            }
            if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                hour += 12;
              }
              if (!isPm && hour === 12) {
                hour = 0;
              }
              return hour;
            } else {
              // this is not supposed to happen
              return hour;
            }
          }

          // date from string and array of format strings
          function configFromStringAndArray(config) {
            var tempConfig, bestMoment, scoreToBeat, i, currentScore;

            if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
            }

            for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (!isValid(tempConfig)) {
                continue;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore +=
                getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }

            extend(config, bestMoment || tempConfig);
          }

          function configFromObject(config) {
            if (config._d) {
              return;
            }

            var i = normalizeObjectUnits(config._i);
            config._a = map(
              [
                i.year,
                i.month,
                i.day || i.date,
                i.hour,
                i.minute,
                i.second,
                i.millisecond,
              ],
              function (obj) {
                return obj && parseInt(obj, 10);
              }
            );

            configFromArray(config);
          }

          function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, "d");
              res._nextDay = undefined;
            }

            return res;
          }

          function prepareConfig(config) {
            var input = config._i,
              format = config._f;

            config._locale = config._locale || getLocale(config._l);

            if (input === null || (format === undefined && input === "")) {
              return createInvalid({ nullInput: true });
            }

            if (typeof input === "string") {
              config._i = input = config._locale.preparse(input);
            }

            if (isMoment(input)) {
              return new Moment(checkOverflow(input));
            } else if (isDate(input)) {
              config._d = input;
            } else if (isArray(format)) {
              configFromStringAndArray(config);
            } else if (format) {
              configFromStringAndFormat(config);
            } else {
              configFromInput(config);
            }

            if (!isValid(config)) {
              config._d = null;
            }

            return config;
          }

          function configFromInput(config) {
            var input = config._i;
            if (isUndefined(input)) {
              config._d = new Date(hooks.now());
            } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
            } else if (typeof input === "string") {
              configFromString(config);
            } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
              });
              configFromArray(config);
            } else if (isObject(input)) {
              configFromObject(config);
            } else if (isNumber(input)) {
              // from milliseconds
              config._d = new Date(input);
            } else {
              hooks.createFromInputFallback(config);
            }
          }

          function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};

            if (locale === true || locale === false) {
              strict = locale;
              locale = undefined;
            }

            if (
              (isObject(input) && isObjectEmpty(input)) ||
              (isArray(input) && input.length === 0)
            ) {
              input = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;

            return createFromConfig(c);
          }

          function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
          }

          var prototypeMin = deprecate(
            "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
            function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
              } else {
                return createInvalid();
              }
            }
          );

          var prototypeMax = deprecate(
            "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
            function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
              } else {
                return createInvalid();
              }
            }
          );

          // Pick a moment m from moments so that m[fn](other) is true for all
          // other. This relies on the function fn to be transitive.
          //
          // moments should either be an array of moment objects or an array, whose
          // first element is an array of moment objects.
          function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
            }
            if (!moments.length) {
              return createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
              }
            }
            return res;
          }

          // TODO: Use [].sort instead?
          function min() {
            var args = [].slice.call(arguments, 0);

            return pickBy("isBefore", args);
          }

          function max() {
            var args = [].slice.call(arguments, 0);

            return pickBy("isAfter", args);
          }

          var now = function () {
            return Date.now ? Date.now() : +new Date();
          };

          var ordering = [
            "year",
            "quarter",
            "month",
            "week",
            "day",
            "hour",
            "minute",
            "second",
            "millisecond",
          ];

          function isDurationValid(m) {
            for (var key in m) {
              if (
                !(
                  indexOf.call(ordering, key) !== -1 &&
                  (m[key] == null || !isNaN(m[key]))
                )
              ) {
                return false;
              }
            }

            var unitHasDecimal = false;
            for (var i = 0; i < ordering.length; ++i) {
              if (m[ordering[i]]) {
                if (unitHasDecimal) {
                  return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                  unitHasDecimal = true;
                }
              }
            }

            return true;
          }

          function isValid$1() {
            return this._isValid;
          }

          function createInvalid$1() {
            return createDuration(NaN);
          }

          function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

            this._isValid = isDurationValid(normalizedInput);

            // representation for dateAddRemove
            this._milliseconds =
              +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days + weeks * 7;
            // It is impossible to translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months + quarters * 3 + years * 12;

            this._data = {};

            this._locale = getLocale();

            this._bubble();
          }

          function isDuration(obj) {
            return obj instanceof Duration;
          }

          function absRound(number) {
            if (number < 0) {
              return Math.round(-1 * number) * -1;
            } else {
              return Math.round(number);
            }
          }

          // FORMATTING

          function offset(token, separator) {
            addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset();
              var sign = "+";
              if (offset < 0) {
                offset = -offset;
                sign = "-";
              }
              return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
              );
            });
          }

          offset("Z", ":");
          offset("ZZ", "");

          // PARSING

          addRegexToken("Z", matchShortOffset);
          addRegexToken("ZZ", matchShortOffset);
          addParseToken(["Z", "ZZ"], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(matchShortOffset, input);
          });

          // HELPERS

          // timezone chunker
          // '+10:00' > ['10',  '00']
          // '-1530'  > ['-15', '30']
          var chunkOffset = /([\+\-]|\d\d)/gi;

          function offsetFromString(matcher, string) {
            var matches = (string || "").match(matcher);

            if (matches === null) {
              return null;
            }

            var chunk = matches[matches.length - 1] || [];
            var parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
            var minutes = +(parts[1] * 60) + toInt(parts[2]);

            return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
          }

          // Return a moment from input, that is local/utc/zone equivalent to model.
          function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
              res = model.clone();
              diff =
                (isMoment(input) || isDate(input)
                  ? input.valueOf()
                  : createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              hooks.updateOffset(res, false);
              return res;
            } else {
              return createLocal(input).local();
            }
          }

          function getDateOffset(m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
          }

          // HOOKS

          // This function will be called whenever a moment is mutated.
          // It is intended to keep the offset in sync with the timezone.
          hooks.updateOffset = function () {};

          // MOMENTS

          // keepLocalTime = true means only change the timezone, without
          // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
          // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
          // +0200, so we adjust the time as needed, to be valid.
          //
          // Keeping the time actually adds/subtracts (one hour)
          // from the actual represented time. That is why we call updateOffset
          // a second time. In case it wants us to change the offset again
          // _changeInProgress == true case, then we have to adjust, because
          // there is no such time in the given timezone.
          function getSetOffset(input, keepLocalTime, keepMinutes) {
            var offset = this._offset || 0,
              localAdjust;
            if (!this.isValid()) {
              return input != null ? this : NaN;
            }
            if (input != null) {
              if (typeof input === "string") {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                  return this;
                }
              } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                this.add(localAdjust, "m");
              }
              if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                  addSubtract(
                    this,
                    createDuration(input - offset, "m"),
                    1,
                    false
                  );
                } else if (!this._changeInProgress) {
                  this._changeInProgress = true;
                  hooks.updateOffset(this, true);
                  this._changeInProgress = null;
                }
              }
              return this;
            } else {
              return this._isUTC ? offset : getDateOffset(this);
            }
          }

          function getSetZone(input, keepLocalTime) {
            if (input != null) {
              if (typeof input !== "string") {
                input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
            } else {
              return -this.utcOffset();
            }
          }

          function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
          }

          function setOffsetToLocal(keepLocalTime) {
            if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                this.subtract(getDateOffset(this), "m");
              }
            }
            return this;
          }

          function setOffsetToParsedOffset() {
            if (this._tzm != null) {
              this.utcOffset(this._tzm, false, true);
            } else if (typeof this._i === "string") {
              var tZone = offsetFromString(matchOffset, this._i);
              if (tZone != null) {
                this.utcOffset(tZone);
              } else {
                this.utcOffset(0, true);
              }
            }
            return this;
          }

          function hasAlignedHourOffset(input) {
            if (!this.isValid()) {
              return false;
            }
            input = input ? createLocal(input).utcOffset() : 0;

            return (this.utcOffset() - input) % 60 === 0;
          }

          function isDaylightSavingTime() {
            return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
            );
          }

          function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
            }

            var c = {};

            copyConfig(c, this);
            c = prepareConfig(c);

            if (c._a) {
              var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
              this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
            } else {
              this._isDSTShifted = false;
            }

            return this._isDSTShifted;
          }

          function isLocal() {
            return this.isValid() ? !this._isUTC : false;
          }

          function isUtcOffset() {
            return this.isValid() ? this._isUTC : false;
          }

          function isUtc() {
            return this.isValid() ? this._isUTC && this._offset === 0 : false;
          }

          // ASP.NET json date format regex
          var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

          function createDuration(input, key) {
            var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

            if (isDuration(input)) {
              duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
              };
            } else if (isNumber(input)) {
              duration = {};
              if (key) {
                duration[key] = input;
              } else {
                duration.milliseconds = input;
              }
            } else if (!!(match = aspNetRegex.exec(input))) {
              sign = match[1] === "-" ? -1 : 1;
              duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
              };
            } else if (!!(match = isoRegex.exec(input))) {
              sign = match[1] === "-" ? -1 : 1;
              duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
              };
            } else if (duration == null) {
              // checks for null or undefined
              duration = {};
            } else if (
              typeof duration === "object" &&
              ("from" in duration || "to" in duration)
            ) {
              diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
              );

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
            }

            ret = new Duration(duration);

            if (isDuration(input) && hasOwnProp(input, "_locale")) {
              ret._locale = input._locale;
            }

            return ret;
          }

          createDuration.fn = Duration.prototype;
          createDuration.invalid = createInvalid$1;

          function parseIso(inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(",", "."));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
          }

          function positiveMomentsDifference(base, other) {
            var res = {};

            res.months =
              other.month() - base.month() + (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, "M").isAfter(other)) {
              --res.months;
            }

            res.milliseconds = +other - +base.clone().add(res.months, "M");

            return res;
          }

          function momentsDifference(base, other) {
            var res;
            if (!(base.isValid() && other.isValid())) {
              return { milliseconds: 0, months: 0 };
            }

            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
            } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
            }

            return res;
          }

          // TODO: remove 'name' arg after deprecation is removed
          function createAdder(direction, name) {
            return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                  name,
                  "moment()." +
                    name +
                    "(period, number) is deprecated. Please use moment()." +
                    name +
                    "(number, period). " +
                    "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
                );
                tmp = val;
                val = period;
                period = tmp;
              }

              val = typeof val === "string" ? +val : val;
              dur = createDuration(val, period);
              addSubtract(this, dur, direction);
              return this;
            };
          }

          function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

            if (!mom.isValid()) {
              // No op
              return;
            }

            updateOffset = updateOffset == null ? true : updateOffset;

            if (months) {
              setMonth(mom, get(mom, "Month") + months * isAdding);
            }
            if (days) {
              set$1(mom, "Date", get(mom, "Date") + days * isAdding);
            }
            if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
            }
            if (updateOffset) {
              hooks.updateOffset(mom, days || months);
            }
          }

          var add = createAdder(1, "add");
          var subtract = createAdder(-1, "subtract");

          function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, "days", true);
            return diff < -6
              ? "sameElse"
              : diff < -1
              ? "lastWeek"
              : diff < 0
              ? "lastDay"
              : diff < 1
              ? "sameDay"
              : diff < 2
              ? "nextDay"
              : diff < 7
              ? "nextWeek"
              : "sameElse";
          }

          function calendar$1(time, formats) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf("day"),
              format = hooks.calendarFormat(this, sod) || "sameElse";

            var output =
              formats &&
              (isFunction(formats[format])
                ? formats[format].call(this, now)
                : formats[format]);

            return this.format(
              output ||
                this.localeData().calendar(format, this, createLocal(now))
            );
          }

          function clone() {
            return new Moment(this);
          }

          function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
              return false;
            }
            units = normalizeUnits(units) || "millisecond";
            if (units === "millisecond") {
              return this.valueOf() > localInput.valueOf();
            } else {
              return (
                localInput.valueOf() < this.clone().startOf(units).valueOf()
              );
            }
          }

          function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
              return false;
            }
            units = normalizeUnits(units) || "millisecond";
            if (units === "millisecond") {
              return this.valueOf() < localInput.valueOf();
            } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
            }
          }

          function isBetween(from, to, units, inclusivity) {
            var localFrom = isMoment(from) ? from : createLocal(from),
              localTo = isMoment(to) ? to : createLocal(to);
            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
              return false;
            }
            inclusivity = inclusivity || "()";
            return (
              (inclusivity[0] === "("
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
              (inclusivity[1] === ")"
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
            );
          }

          function isSame(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;
            if (!(this.isValid() && localInput.isValid())) {
              return false;
            }
            units = normalizeUnits(units) || "millisecond";
            if (units === "millisecond") {
              return this.valueOf() === localInput.valueOf();
            } else {
              inputMs = localInput.valueOf();
              return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
              );
            }
          }

          function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units);
          }

          function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units);
          }

          function diff(input, units, asFloat) {
            var that, zoneDelta, output;

            if (!this.isValid()) {
              return NaN;
            }

            that = cloneWithOffset(input, this);

            if (!that.isValid()) {
              return NaN;
            }

            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

            units = normalizeUnits(units);

            switch (units) {
              case "year":
                output = monthDiff(this, that) / 12;
                break;
              case "month":
                output = monthDiff(this, that);
                break;
              case "quarter":
                output = monthDiff(this, that) / 3;
                break;
              case "second":
                output = (this - that) / 1e3;
                break; // 1000
              case "minute":
                output = (this - that) / 6e4;
                break; // 1000 * 60
              case "hour":
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
              case "day":
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
              case "week":
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
              default:
                output = this - that;
            }

            return asFloat ? output : absFloor(output);
          }

          function monthDiff(a, b) {
            // difference in months
            var wholeMonthDiff =
                (b.year() - a.year()) * 12 + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, "months"),
              anchor2,
              adjust;

            if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
            } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
            }

            //check for negative zero, return zero if negative zero
            return -(wholeMonthDiff + adjust) || 0;
          }

          hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
          hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";

          function toString() {
            return this.clone()
              .locale("en")
              .format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
          }

          function toISOString(keepOffset) {
            if (!this.isValid()) {
              return null;
            }
            var utc = keepOffset !== true;
            var m = utc ? this.clone().utc() : this;
            if (m.year() < 0 || m.year() > 9999) {
              return formatMoment(
                m,
                utc
                  ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]"
                  : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
              );
            }
            if (isFunction(Date.prototype.toISOString)) {
              // native implementation is ~50x faster, use it when we can
              if (utc) {
                return this.toDate().toISOString();
              } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                  .toISOString()
                  .replace("Z", formatMoment(m, "Z"));
              }
            }
            return formatMoment(
              m,
              utc
                ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"
                : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }

          /**
           * Return a human readable representation of a moment that can
           * also be evaluated to get a new moment which is the same
           *
           * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
           */
          function inspect() {
            if (!this.isValid()) {
              return "moment.invalid(/* " + this._i + " */)";
            }
            var func = "moment";
            var zone = "";
            if (!this.isLocal()) {
              func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
              zone = "Z";
            }
            var prefix = "[" + func + '("]';
            var year =
              0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
            var datetime = "-MM-DD[T]HH:mm:ss.SSS";
            var suffix = zone + '[")]';

            return this.format(prefix + year + datetime + suffix);
          }

          function format(inputString) {
            if (!inputString) {
              inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
            }
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output);
          }

          function from(time, withoutSuffix) {
            if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) ||
                createLocal(time).isValid())
            ) {
              return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
            } else {
              return this.localeData().invalidDate();
            }
          }

          function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix);
          }

          function to(time, withoutSuffix) {
            if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) ||
                createLocal(time).isValid())
            ) {
              return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
            } else {
              return this.localeData().invalidDate();
            }
          }

          function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix);
          }

          // If passed a locale key, it will set the locale for this
          // instance.  Otherwise, it will return the locale configuration
          // variables for this instance.
          function locale(key) {
            var newLocaleData;

            if (key === undefined) {
              return this._locale._abbr;
            } else {
              newLocaleData = getLocale(key);
              if (newLocaleData != null) {
                this._locale = newLocaleData;
              }
              return this;
            }
          }

          var lang = deprecate(
            "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
            function (key) {
              if (key === undefined) {
                return this.localeData();
              } else {
                return this.locale(key);
              }
            }
          );

          function localeData() {
            return this._locale;
          }

          var MS_PER_SECOND = 1000;
          var MS_PER_MINUTE = 60 * MS_PER_SECOND;
          var MS_PER_HOUR = 60 * MS_PER_MINUTE;
          var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

          // actual modulo - handles negative numbers (for dates before 1970):
          function mod$1(dividend, divisor) {
            return ((dividend % divisor) + divisor) % divisor;
          }

          function localStartOfDate(y, m, d) {
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return new Date(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
              return new Date(y, m, d).valueOf();
            }
          }

          function utcStartOfDate(y, m, d) {
            // Date.UTC remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
              return Date.UTC(y, m, d);
            }
          }

          function startOf(units) {
            var time;
            units = normalizeUnits(units);
            if (
              units === undefined ||
              units === "millisecond" ||
              !this.isValid()
            ) {
              return this;
            }

            var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
              case "year":
                time = startOfDate(this.year(), 0, 1);
                break;
              case "quarter":
                time = startOfDate(
                  this.year(),
                  this.month() - (this.month() % 3),
                  1
                );
                break;
              case "month":
                time = startOfDate(this.year(), this.month(), 1);
                break;
              case "week":
                time = startOfDate(
                  this.year(),
                  this.month(),
                  this.date() - this.weekday()
                );
                break;
              case "isoWeek":
                time = startOfDate(
                  this.year(),
                  this.month(),
                  this.date() - (this.isoWeekday() - 1)
                );
                break;
              case "day":
              case "date":
                time = startOfDate(this.year(), this.month(), this.date());
                break;
              case "hour":
                time = this._d.valueOf();
                time -= mod$1(
                  time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                  MS_PER_HOUR
                );
                break;
              case "minute":
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
              case "second":
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
          }

          function endOf(units) {
            var time;
            units = normalizeUnits(units);
            if (
              units === undefined ||
              units === "millisecond" ||
              !this.isValid()
            ) {
              return this;
            }

            var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
              case "year":
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
              case "quarter":
                time =
                  startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3) + 3,
                    1
                  ) - 1;
                break;
              case "month":
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
              case "week":
                time =
                  startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday() + 7
                  ) - 1;
                break;
              case "isoWeek":
                time =
                  startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1) + 7
                  ) - 1;
                break;
              case "day":
              case "date":
                time =
                  startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
              case "hour":
                time = this._d.valueOf();
                time +=
                  MS_PER_HOUR -
                  mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                  ) -
                  1;
                break;
              case "minute":
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
              case "second":
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
          }

          function valueOf() {
            return this._d.valueOf() - (this._offset || 0) * 60000;
          }

          function unix() {
            return Math.floor(this.valueOf() / 1000);
          }

          function toDate() {
            return new Date(this.valueOf());
          }

          function toArray() {
            var m = this;
            return [
              m.year(),
              m.month(),
              m.date(),
              m.hour(),
              m.minute(),
              m.second(),
              m.millisecond(),
            ];
          }

          function toObject() {
            var m = this;
            return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds(),
            };
          }

          function toJSON() {
            // new Date(NaN).toJSON() === null
            return this.isValid() ? this.toISOString() : null;
          }

          function isValid$2() {
            return isValid(this);
          }

          function parsingFlags() {
            return extend({}, getParsingFlags(this));
          }

          function invalidAt() {
            return getParsingFlags(this).overflow;
          }

          function creationData() {
            return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict,
            };
          }

          // FORMATTING

          addFormatToken(0, ["gg", 2], 0, function () {
            return this.weekYear() % 100;
          });

          addFormatToken(0, ["GG", 2], 0, function () {
            return this.isoWeekYear() % 100;
          });

          function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
          }

          addWeekYearFormatToken("gggg", "weekYear");
          addWeekYearFormatToken("ggggg", "weekYear");
          addWeekYearFormatToken("GGGG", "isoWeekYear");
          addWeekYearFormatToken("GGGGG", "isoWeekYear");

          // ALIASES

          addUnitAlias("weekYear", "gg");
          addUnitAlias("isoWeekYear", "GG");

          // PRIORITY

          addUnitPriority("weekYear", 1);
          addUnitPriority("isoWeekYear", 1);

          // PARSING

          addRegexToken("G", matchSigned);
          addRegexToken("g", matchSigned);
          addRegexToken("GG", match1to2, match2);
          addRegexToken("gg", match1to2, match2);
          addRegexToken("GGGG", match1to4, match4);
          addRegexToken("gggg", match1to4, match4);
          addRegexToken("GGGGG", match1to6, match6);
          addRegexToken("ggggg", match1to6, match6);

          addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function (
            input,
            week,
            config,
            token
          ) {
            week[token.substr(0, 2)] = toInt(input);
          });

          addWeekParseToken(["gg", "GG"], function (
            input,
            week,
            config,
            token
          ) {
            week[token] = hooks.parseTwoDigitYear(input);
          });

          // MOMENTS

          function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(
              this,
              input,
              this.week(),
              this.weekday(),
              this.localeData()._week.dow,
              this.localeData()._week.doy
            );
          }

          function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(
              this,
              input,
              this.isoWeek(),
              this.isoWeekday(),
              1,
              4
            );
          }

          function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4);
          }

          function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
          }

          function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            if (input == null) {
              return weekOfYear(this, dow, doy).year;
            } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
            }
          }

          function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(
                weekYear,
                week,
                weekday,
                dow,
                doy
              ),
              date = createUTCDate(
                dayOfYearData.year,
                0,
                dayOfYearData.dayOfYear
              );

            this.year(date.getUTCFullYear());
            this.month(date.getUTCMonth());
            this.date(date.getUTCDate());
            return this;
          }

          // FORMATTING

          addFormatToken("Q", 0, "Qo", "quarter");

          // ALIASES

          addUnitAlias("quarter", "Q");

          // PRIORITY

          addUnitPriority("quarter", 7);

          // PARSING

          addRegexToken("Q", match1);
          addParseToken("Q", function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
          });

          // MOMENTS

          function getSetQuarter(input) {
            return input == null
              ? Math.ceil((this.month() + 1) / 3)
              : this.month((input - 1) * 3 + (this.month() % 3));
          }

          // FORMATTING

          addFormatToken("D", ["DD", 2], "Do", "date");

          // ALIASES

          addUnitAlias("date", "D");

          // PRIORITY
          addUnitPriority("date", 9);

          // PARSING

          addRegexToken("D", match1to2);
          addRegexToken("DD", match1to2, match2);
          addRegexToken("Do", function (isStrict, locale) {
            // TODO: Remove "ordinalParse" fallback in next major release.
            return isStrict
              ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
              : locale._dayOfMonthOrdinalParseLenient;
          });

          addParseToken(["D", "DD"], DATE);
          addParseToken("Do", function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0]);
          });

          // MOMENTS

          var getSetDayOfMonth = makeGetSet("Date", true);

          // FORMATTING

          addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");

          // ALIASES

          addUnitAlias("dayOfYear", "DDD");

          // PRIORITY
          addUnitPriority("dayOfYear", 4);

          // PARSING

          addRegexToken("DDD", match1to3);
          addRegexToken("DDDD", match3);
          addParseToken(["DDD", "DDDD"], function (input, array, config) {
            config._dayOfYear = toInt(input);
          });

          // HELPERS

          // MOMENTS

          function getSetDayOfYear(input) {
            var dayOfYear =
              Math.round(
                (this.clone().startOf("day") - this.clone().startOf("year")) /
                  864e5
              ) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
          }

          // FORMATTING

          addFormatToken("m", ["mm", 2], 0, "minute");

          // ALIASES

          addUnitAlias("minute", "m");

          // PRIORITY

          addUnitPriority("minute", 14);

          // PARSING

          addRegexToken("m", match1to2);
          addRegexToken("mm", match1to2, match2);
          addParseToken(["m", "mm"], MINUTE);

          // MOMENTS

          var getSetMinute = makeGetSet("Minutes", false);

          // FORMATTING

          addFormatToken("s", ["ss", 2], 0, "second");

          // ALIASES

          addUnitAlias("second", "s");

          // PRIORITY

          addUnitPriority("second", 15);

          // PARSING

          addRegexToken("s", match1to2);
          addRegexToken("ss", match1to2, match2);
          addParseToken(["s", "ss"], SECOND);

          // MOMENTS

          var getSetSecond = makeGetSet("Seconds", false);

          // FORMATTING

          addFormatToken("S", 0, 0, function () {
            return ~~(this.millisecond() / 100);
          });

          addFormatToken(0, ["SS", 2], 0, function () {
            return ~~(this.millisecond() / 10);
          });

          addFormatToken(0, ["SSS", 3], 0, "millisecond");
          addFormatToken(0, ["SSSS", 4], 0, function () {
            return this.millisecond() * 10;
          });
          addFormatToken(0, ["SSSSS", 5], 0, function () {
            return this.millisecond() * 100;
          });
          addFormatToken(0, ["SSSSSS", 6], 0, function () {
            return this.millisecond() * 1000;
          });
          addFormatToken(0, ["SSSSSSS", 7], 0, function () {
            return this.millisecond() * 10000;
          });
          addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
            return this.millisecond() * 100000;
          });
          addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
            return this.millisecond() * 1000000;
          });

          // ALIASES

          addUnitAlias("millisecond", "ms");

          // PRIORITY

          addUnitPriority("millisecond", 16);

          // PARSING

          addRegexToken("S", match1to3, match1);
          addRegexToken("SS", match1to3, match2);
          addRegexToken("SSS", match1to3, match3);

          var token;
          for (token = "SSSS"; token.length <= 9; token += "S") {
            addRegexToken(token, matchUnsigned);
          }

          function parseMs(input, array) {
            array[MILLISECOND] = toInt(("0." + input) * 1000);
          }

          for (token = "S"; token.length <= 9; token += "S") {
            addParseToken(token, parseMs);
          }
          // MOMENTS

          var getSetMillisecond = makeGetSet("Milliseconds", false);

          // FORMATTING

          addFormatToken("z", 0, 0, "zoneAbbr");
          addFormatToken("zz", 0, 0, "zoneName");

          // MOMENTS

          function getZoneAbbr() {
            return this._isUTC ? "UTC" : "";
          }

          function getZoneName() {
            return this._isUTC ? "Coordinated Universal Time" : "";
          }

          var proto = Moment.prototype;

          proto.add = add;
          proto.calendar = calendar$1;
          proto.clone = clone;
          proto.diff = diff;
          proto.endOf = endOf;
          proto.format = format;
          proto.from = from;
          proto.fromNow = fromNow;
          proto.to = to;
          proto.toNow = toNow;
          proto.get = stringGet;
          proto.invalidAt = invalidAt;
          proto.isAfter = isAfter;
          proto.isBefore = isBefore;
          proto.isBetween = isBetween;
          proto.isSame = isSame;
          proto.isSameOrAfter = isSameOrAfter;
          proto.isSameOrBefore = isSameOrBefore;
          proto.isValid = isValid$2;
          proto.lang = lang;
          proto.locale = locale;
          proto.localeData = localeData;
          proto.max = prototypeMax;
          proto.min = prototypeMin;
          proto.parsingFlags = parsingFlags;
          proto.set = stringSet;
          proto.startOf = startOf;
          proto.subtract = subtract;
          proto.toArray = toArray;
          proto.toObject = toObject;
          proto.toDate = toDate;
          proto.toISOString = toISOString;
          proto.inspect = inspect;
          proto.toJSON = toJSON;
          proto.toString = toString;
          proto.unix = unix;
          proto.valueOf = valueOf;
          proto.creationData = creationData;
          proto.year = getSetYear;
          proto.isLeapYear = getIsLeapYear;
          proto.weekYear = getSetWeekYear;
          proto.isoWeekYear = getSetISOWeekYear;
          proto.quarter = proto.quarters = getSetQuarter;
          proto.month = getSetMonth;
          proto.daysInMonth = getDaysInMonth;
          proto.week = proto.weeks = getSetWeek;
          proto.isoWeek = proto.isoWeeks = getSetISOWeek;
          proto.weeksInYear = getWeeksInYear;
          proto.isoWeeksInYear = getISOWeeksInYear;
          proto.date = getSetDayOfMonth;
          proto.day = proto.days = getSetDayOfWeek;
          proto.weekday = getSetLocaleDayOfWeek;
          proto.isoWeekday = getSetISODayOfWeek;
          proto.dayOfYear = getSetDayOfYear;
          proto.hour = proto.hours = getSetHour;
          proto.minute = proto.minutes = getSetMinute;
          proto.second = proto.seconds = getSetSecond;
          proto.millisecond = proto.milliseconds = getSetMillisecond;
          proto.utcOffset = getSetOffset;
          proto.utc = setOffsetToUTC;
          proto.local = setOffsetToLocal;
          proto.parseZone = setOffsetToParsedOffset;
          proto.hasAlignedHourOffset = hasAlignedHourOffset;
          proto.isDST = isDaylightSavingTime;
          proto.isLocal = isLocal;
          proto.isUtcOffset = isUtcOffset;
          proto.isUtc = isUtc;
          proto.isUTC = isUtc;
          proto.zoneAbbr = getZoneAbbr;
          proto.zoneName = getZoneName;
          proto.dates = deprecate(
            "dates accessor is deprecated. Use date instead.",
            getSetDayOfMonth
          );
          proto.months = deprecate(
            "months accessor is deprecated. Use month instead",
            getSetMonth
          );
          proto.years = deprecate(
            "years accessor is deprecated. Use year instead",
            getSetYear
          );
          proto.zone = deprecate(
            "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
            getSetZone
          );
          proto.isDSTShifted = deprecate(
            "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
            isDaylightSavingTimeShifted
          );

          function createUnix(input) {
            return createLocal(input * 1000);
          }

          function createInZone() {
            return createLocal.apply(null, arguments).parseZone();
          }

          function preParsePostFormat(string) {
            return string;
          }

          var proto$1 = Locale.prototype;

          proto$1.calendar = calendar;
          proto$1.longDateFormat = longDateFormat;
          proto$1.invalidDate = invalidDate;
          proto$1.ordinal = ordinal;
          proto$1.preparse = preParsePostFormat;
          proto$1.postformat = preParsePostFormat;
          proto$1.relativeTime = relativeTime;
          proto$1.pastFuture = pastFuture;
          proto$1.set = set;

          proto$1.months = localeMonths;
          proto$1.monthsShort = localeMonthsShort;
          proto$1.monthsParse = localeMonthsParse;
          proto$1.monthsRegex = monthsRegex;
          proto$1.monthsShortRegex = monthsShortRegex;
          proto$1.week = localeWeek;
          proto$1.firstDayOfYear = localeFirstDayOfYear;
          proto$1.firstDayOfWeek = localeFirstDayOfWeek;

          proto$1.weekdays = localeWeekdays;
          proto$1.weekdaysMin = localeWeekdaysMin;
          proto$1.weekdaysShort = localeWeekdaysShort;
          proto$1.weekdaysParse = localeWeekdaysParse;

          proto$1.weekdaysRegex = weekdaysRegex;
          proto$1.weekdaysShortRegex = weekdaysShortRegex;
          proto$1.weekdaysMinRegex = weekdaysMinRegex;

          proto$1.isPM = localeIsPM;
          proto$1.meridiem = localeMeridiem;

          function get$1(format, index, field, setter) {
            var locale = getLocale();
            var utc = createUTC().set(setter, index);
            return locale[field](utc, format);
          }

          function listMonthsImpl(format, index, field) {
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }

            format = format || "";

            if (index != null) {
              return get$1(format, index, field, "month");
            }

            var i;
            var out = [];
            for (i = 0; i < 12; i++) {
              out[i] = get$1(format, i, field, "month");
            }
            return out;
          }

          // ()
          // (5)
          // (fmt, 5)
          // (fmt)
          // (true)
          // (true, 5)
          // (true, fmt, 5)
          // (true, fmt)
          function listWeekdaysImpl(localeSorted, format, index, field) {
            if (typeof localeSorted === "boolean") {
              if (isNumber(format)) {
                index = format;
                format = undefined;
              }

              format = format || "";
            } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (isNumber(format)) {
                index = format;
                format = undefined;
              }

              format = format || "";
            }

            var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0;

            if (index != null) {
              return get$1(format, (index + shift) % 7, field, "day");
            }

            var i;
            var out = [];
            for (i = 0; i < 7; i++) {
              out[i] = get$1(format, (i + shift) % 7, field, "day");
            }
            return out;
          }

          function listMonths(format, index) {
            return listMonthsImpl(format, index, "months");
          }

          function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, "monthsShort");
          }

          function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, "weekdays");
          }

          function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(
              localeSorted,
              format,
              index,
              "weekdaysShort"
            );
          }

          function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
          }

          getSetGlobalLocale("en", {
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
              var b = number % 10,
                output =
                  toInt((number % 100) / 10) === 1
                    ? "th"
                    : b === 1
                    ? "st"
                    : b === 2
                    ? "nd"
                    : b === 3
                    ? "rd"
                    : "th";
              return number + output;
            },
          });

          // Side effect imports

          hooks.lang = deprecate(
            "moment.lang is deprecated. Use moment.locale instead.",
            getSetGlobalLocale
          );
          hooks.langData = deprecate(
            "moment.langData is deprecated. Use moment.localeData instead.",
            getLocale
          );

          var mathAbs = Math.abs;

          function abs() {
            var data = this._data;

            this._milliseconds = mathAbs(this._milliseconds);
            this._days = mathAbs(this._days);
            this._months = mathAbs(this._months);

            data.milliseconds = mathAbs(data.milliseconds);
            data.seconds = mathAbs(data.seconds);
            data.minutes = mathAbs(data.minutes);
            data.hours = mathAbs(data.hours);
            data.months = mathAbs(data.months);
            data.years = mathAbs(data.years);

            return this;
          }

          function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);

            duration._milliseconds += direction * other._milliseconds;
            duration._days += direction * other._days;
            duration._months += direction * other._months;

            return duration._bubble();
          }

          // supports only 2.0-style add(1, 's') or add(duration)
          function add$1(input, value) {
            return addSubtract$1(this, input, value, 1);
          }

          // supports only 2.0-style subtract(1, 's') or subtract(duration)
          function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1);
          }

          function absCeil(number) {
            if (number < 0) {
              return Math.floor(number);
            } else {
              return Math.ceil(number);
            }
          }

          function bubble() {
            var milliseconds = this._milliseconds;
            var days = this._days;
            var months = this._months;
            var data = this._data;
            var seconds, minutes, hours, years, monthsFromDays;

            // if we have a mix of positive and negative values, bubble down first
            // check: https://github.com/moment/moment/issues/2166
            if (
              !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
              )
            ) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
            }

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absFloor(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absFloor(seconds / 60);
            data.minutes = minutes % 60;

            hours = absFloor(minutes / 60);
            data.hours = hours % 24;

            days += absFloor(hours / 24);

            // convert days to months
            monthsFromDays = absFloor(daysToMonths(days));
            months += monthsFromDays;
            days -= absCeil(monthsToDays(monthsFromDays));

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;

            return this;
          }

          function daysToMonths(days) {
            // 400 years have 146097 days (taking into account leap year rules)
            // 400 years have 12 months === 4800
            return (days * 4800) / 146097;
          }

          function monthsToDays(months) {
            // the reverse of daysToMonths
            return (months * 146097) / 4800;
          }

          function as(units) {
            if (!this.isValid()) {
              return NaN;
            }
            var days;
            var months;
            var milliseconds = this._milliseconds;

            units = normalizeUnits(units);

            if (units === "month" || units === "quarter" || units === "year") {
              days = this._days + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              switch (units) {
                case "month":
                  return months;
                case "quarter":
                  return months / 3;
                case "year":
                  return months / 12;
              }
            } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                case "week":
                  return days / 7 + milliseconds / 6048e5;
                case "day":
                  return days + milliseconds / 864e5;
                case "hour":
                  return days * 24 + milliseconds / 36e5;
                case "minute":
                  return days * 1440 + milliseconds / 6e4;
                case "second":
                  return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case "millisecond":
                  return Math.floor(days * 864e5) + milliseconds;
                default:
                  throw new Error("Unknown unit " + units);
              }
            }
          }

          // TODO: Use this.as('ms')?
          function valueOf$1() {
            if (!this.isValid()) {
              return NaN;
            }
            return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
            );
          }

          function makeAs(alias) {
            return function () {
              return this.as(alias);
            };
          }

          var asMilliseconds = makeAs("ms");
          var asSeconds = makeAs("s");
          var asMinutes = makeAs("m");
          var asHours = makeAs("h");
          var asDays = makeAs("d");
          var asWeeks = makeAs("w");
          var asMonths = makeAs("M");
          var asQuarters = makeAs("Q");
          var asYears = makeAs("y");

          function clone$1() {
            return createDuration(this);
          }

          function get$2(units) {
            units = normalizeUnits(units);
            return this.isValid() ? this[units + "s"]() : NaN;
          }

          function makeGetter(name) {
            return function () {
              return this.isValid() ? this._data[name] : NaN;
            };
          }

          var milliseconds = makeGetter("milliseconds");
          var seconds = makeGetter("seconds");
          var minutes = makeGetter("minutes");
          var hours = makeGetter("hours");
          var days = makeGetter("days");
          var months = makeGetter("months");
          var years = makeGetter("years");

          function weeks() {
            return absFloor(this.days() / 7);
          }

          var round = Math.round;
          var thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month
            M: 11, // months to year
          };

          // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
          function substituteTimeAgo(
            string,
            number,
            withoutSuffix,
            isFuture,
            locale
          ) {
            return locale.relativeTime(
              number || 1,
              !!withoutSuffix,
              string,
              isFuture
            );
          }

          function relativeTime$1(posNegDuration, withoutSuffix, locale) {
            var duration = createDuration(posNegDuration).abs();
            var seconds = round(duration.as("s"));
            var minutes = round(duration.as("m"));
            var hours = round(duration.as("h"));
            var days = round(duration.as("d"));
            var months = round(duration.as("M"));
            var years = round(duration.as("y"));

            var a = (seconds <= thresholds.ss && ["s", seconds]) ||
              (seconds < thresholds.s && ["ss", seconds]) ||
              (minutes <= 1 && ["m"]) ||
              (minutes < thresholds.m && ["mm", minutes]) ||
              (hours <= 1 && ["h"]) ||
              (hours < thresholds.h && ["hh", hours]) ||
              (days <= 1 && ["d"]) ||
              (days < thresholds.d && ["dd", days]) ||
              (months <= 1 && ["M"]) ||
              (months < thresholds.M && ["MM", months]) ||
              (years <= 1 && ["y"]) || ["yy", years];

            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
          }

          // This function allows you to set the rounding function for relative time strings
          function getSetRelativeTimeRounding(roundingFunction) {
            if (roundingFunction === undefined) {
              return round;
            }
            if (typeof roundingFunction === "function") {
              round = roundingFunction;
              return true;
            }
            return false;
          }

          // This function allows you to set a threshold for relative time strings
          function getSetRelativeTimeThreshold(threshold, limit) {
            if (thresholds[threshold] === undefined) {
              return false;
            }
            if (limit === undefined) {
              return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            if (threshold === "s") {
              thresholds.ss = limit - 1;
            }
            return true;
          }

          function humanize(withSuffix) {
            if (!this.isValid()) {
              return this.localeData().invalidDate();
            }

            var locale = this.localeData();
            var output = relativeTime$1(this, !withSuffix, locale);

            if (withSuffix) {
              output = locale.pastFuture(+this, output);
            }

            return locale.postformat(output);
          }

          var abs$1 = Math.abs;

          function sign(x) {
            return (x > 0) - (x < 0) || +x;
          }

          function toISOString$1() {
            // for ISO strings we do not use the normal bubbling rules:
            //  * milliseconds bubble up until they become hours
            //  * days do not bubble at all
            //  * months bubble up until they become years
            // This is because there is no context-free conversion between hours and days
            // (think of clock changes)
            // and also not between days and months (28-31 days per month)
            if (!this.isValid()) {
              return this.localeData().invalidDate();
            }

            var seconds = abs$1(this._milliseconds) / 1000;
            var days = abs$1(this._days);
            var months = abs$1(this._months);
            var minutes, hours, years;

            // 3600 seconds -> 60 minutes -> 1 hour
            minutes = absFloor(seconds / 60);
            hours = absFloor(minutes / 60);
            seconds %= 60;
            minutes %= 60;

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var Y = years;
            var M = months;
            var D = days;
            var h = hours;
            var m = minutes;
            var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";
            var total = this.asSeconds();

            if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return "P0D";
            }

            var totalSign = total < 0 ? "-" : "";
            var ymSign = sign(this._months) !== sign(total) ? "-" : "";
            var daysSign = sign(this._days) !== sign(total) ? "-" : "";
            var hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";

            return (
              totalSign +
              "P" +
              (Y ? ymSign + Y + "Y" : "") +
              (M ? ymSign + M + "M" : "") +
              (D ? daysSign + D + "D" : "") +
              (h || m || s ? "T" : "") +
              (h ? hmsSign + h + "H" : "") +
              (m ? hmsSign + m + "M" : "") +
              (s ? hmsSign + s + "S" : "")
            );
          }

          var proto$2 = Duration.prototype;

          proto$2.isValid = isValid$1;
          proto$2.abs = abs;
          proto$2.add = add$1;
          proto$2.subtract = subtract$1;
          proto$2.as = as;
          proto$2.asMilliseconds = asMilliseconds;
          proto$2.asSeconds = asSeconds;
          proto$2.asMinutes = asMinutes;
          proto$2.asHours = asHours;
          proto$2.asDays = asDays;
          proto$2.asWeeks = asWeeks;
          proto$2.asMonths = asMonths;
          proto$2.asQuarters = asQuarters;
          proto$2.asYears = asYears;
          proto$2.valueOf = valueOf$1;
          proto$2._bubble = bubble;
          proto$2.clone = clone$1;
          proto$2.get = get$2;
          proto$2.milliseconds = milliseconds;
          proto$2.seconds = seconds;
          proto$2.minutes = minutes;
          proto$2.hours = hours;
          proto$2.days = days;
          proto$2.weeks = weeks;
          proto$2.months = months;
          proto$2.years = years;
          proto$2.humanize = humanize;
          proto$2.toISOString = toISOString$1;
          proto$2.toString = toISOString$1;
          proto$2.toJSON = toISOString$1;
          proto$2.locale = locale;
          proto$2.localeData = localeData;

          proto$2.toIsoString = deprecate(
            "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
            toISOString$1
          );
          proto$2.lang = lang;

          // Side effect imports

          // FORMATTING

          addFormatToken("X", 0, 0, "unix");
          addFormatToken("x", 0, 0, "valueOf");

          // PARSING

          addRegexToken("x", matchSigned);
          addRegexToken("X", matchTimestamp);
          addParseToken("X", function (input, array, config) {
            config._d = new Date(parseFloat(input, 10) * 1000);
          });
          addParseToken("x", function (input, array, config) {
            config._d = new Date(toInt(input));
          });

          // Side effect imports

          hooks.version = "2.24.0";

          setHookCallback(createLocal);

          hooks.fn = proto;
          hooks.min = min;
          hooks.max = max;
          hooks.now = now;
          hooks.utc = createUTC;
          hooks.unix = createUnix;
          hooks.months = listMonths;
          hooks.isDate = isDate;
          hooks.locale = getSetGlobalLocale;
          hooks.invalid = createInvalid;
          hooks.duration = createDuration;
          hooks.isMoment = isMoment;
          hooks.weekdays = listWeekdays;
          hooks.parseZone = createInZone;
          hooks.localeData = getLocale;
          hooks.isDuration = isDuration;
          hooks.monthsShort = listMonthsShort;
          hooks.weekdaysMin = listWeekdaysMin;
          hooks.defineLocale = defineLocale;
          hooks.updateLocale = updateLocale;
          hooks.locales = listLocales;
          hooks.weekdaysShort = listWeekdaysShort;
          hooks.normalizeUnits = normalizeUnits;
          hooks.relativeTimeRounding = getSetRelativeTimeRounding;
          hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
          hooks.calendarFormat = getCalendarFormat;
          hooks.prototype = proto;

          // currently HTML5 input type only supports 24-hour formats
          hooks.HTML5_FMT = {
            DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", // <input type="datetime-local" />
            DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", // <input type="datetime-local" step="1" />
            DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", // <input type="datetime-local" step="0.001" />
            DATE: "YYYY-MM-DD", // <input type="date" />
            TIME: "HH:mm", // <input type="time" />
            TIME_SECONDS: "HH:mm:ss", // <input type="time" step="1" />
            TIME_MS: "HH:mm:ss.SSS", // <input type="time" step="0.001" />
            WEEK: "GGGG-[W]WW", // <input type="week" />
            MONTH: "YYYY-MM", // <input type="month" />
          };

          return hooks;
        });
      },
      {},
    ],
    78: [
      function (require, module, exports) {
        (function (process) {
          // .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
          // backported and transplited with Babel, with backwards-compat fixes

          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // resolves . and .. elements in a path array with directory names there
          // must be no slashes, empty elements, or device names (c:\) in the array
          // (so also no leading and trailing slashes - it does not distinguish
          // relative and absolute paths)
          function normalizeArray(parts, allowAboveRoot) {
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift("..");
              }
            }

            return parts;
          }

          // path.resolve([from ...], to)
          // posix version
          exports.resolve = function () {
            var resolvedPath = "",
              resolvedAbsolute = false;

            for (
              var i = arguments.length - 1;
              i >= -1 && !resolvedAbsolute;
              i--
            ) {
              var path = i >= 0 ? arguments[i] : process.cwd();

              // Skip empty and invalid entries
              if (typeof path !== "string") {
                throw new TypeError(
                  "Arguments to path.resolve must be strings"
                );
              } else if (!path) {
                continue;
              }

              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }

            // At this point the path should be resolved to a full absolute path, but
            // handle relative paths to be safe (might happen when process.cwd() fails)

            // Normalize the path
            resolvedPath = normalizeArray(
              filter(resolvedPath.split("/"), function (p) {
                return !!p;
              }),
              !resolvedAbsolute
            ).join("/");

            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          };

          // path.normalize(path)
          // posix version
          exports.normalize = function (path) {
            var isAbsolute = exports.isAbsolute(path),
              trailingSlash = substr(path, -1) === "/";

            // Normalize the path
            path = normalizeArray(
              filter(path.split("/"), function (p) {
                return !!p;
              }),
              !isAbsolute
            ).join("/");

            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }

            return (isAbsolute ? "/" : "") + path;
          };

          // posix version
          exports.isAbsolute = function (path) {
            return path.charAt(0) === "/";
          };

          // posix version
          exports.join = function () {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports.normalize(
              filter(paths, function (p, index) {
                if (typeof p !== "string") {
                  throw new TypeError("Arguments to path.join must be strings");
                }
                return p;
              }).join("/")
            );
          };

          // path.relative(from, to)
          // posix version
          exports.relative = function (from, to) {
            from = exports.resolve(from).substr(1);
            to = exports.resolve(to).substr(1);

            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "") break;
              }

              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "") break;
              }

              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }

            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));

            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }

            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }

            outputParts = outputParts.concat(toParts.slice(samePartsLength));

            return outputParts.join("/");
          };

          exports.sep = "/";
          exports.delimiter = ":";

          exports.dirname = function (path) {
            if (typeof path !== "string") path = path + "";
            if (path.length === 0) return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47; /*/*/
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);
              if (code === 47 /*/*/) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                // We saw the first non-path separator
                matchedSlash = false;
              }
            }

            if (end === -1) return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) {
              // return '//';
              // Backwards-compat fix:
              return "/";
            }
            return path.slice(0, end);
          };

          function basename(path) {
            if (typeof path !== "string") path = path + "";

            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;

            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false;
                end = i + 1;
              }
            }

            if (end === -1) return "";
            return path.slice(start, end);
          }

          // Uses a mixed approach for backwards-compatibility, as ext behavior changed
          // in new Node.js versions, so only basename() above is backported here
          exports.basename = function (path, ext) {
            var f = basename(path);
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };

          exports.extname = function (path) {
            if (typeof path !== "string") path = path + "";
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            // Track the state of characters (if any) we see before our first dot and
            // after any path separator we find
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46 /*.*/) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
              } else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
              }
            }

            if (
              startDot === -1 ||
              end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              (preDotState === 1 &&
                startDot === end - 1 &&
                startDot === startPart + 1)
            ) {
              return "";
            }
            return path.slice(startDot, end);
          };

          function filter(xs, f) {
            if (xs.filter) return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              if (f(xs[i], i, xs)) res.push(xs[i]);
            }
            return res;
          }

          // String.prototype.substr - negative index don't work in IE8
          var substr =
            "ab".substr(-1) === "b"
              ? function (str, start, len) {
                  return str.substr(start, len);
                }
              : function (str, start, len) {
                  if (start < 0) start = str.length + start;
                  return str.substr(start, len);
                };
        }.call(this, require("_process")));
      },
      { _process: 80 },
    ],
    79: [
      function (require, module, exports) {
        (function (process) {
          "use strict";

          if (
            typeof process === "undefined" ||
            !process.version ||
            process.version.indexOf("v0.") === 0 ||
            (process.version.indexOf("v1.") === 0 &&
              process.version.indexOf("v1.8.") !== 0)
          ) {
            module.exports = { nextTick: nextTick };
          } else {
            module.exports = process;
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function');
            }
            var len = arguments.length;
            var args, i;
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn);
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1);
                });
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2);
                });
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3);
                });
              default:
                args = new Array(len - 1);
                i = 0;
                while (i < args.length) {
                  args[i++] = arguments[i];
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args);
                });
            }
          }
        }.call(this, require("_process")));
      },
      { _process: 80 },
    ],
    80: [
      function (require, module, exports) {
        // shim for using process in browser
        var process = (module.exports = {});

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function () {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if (
            (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
            setTimeout
          ) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if (
            (cachedClearTimeout === defaultClearTimeout ||
              !cachedClearTimeout) &&
            clearTimeout
          ) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ""; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) {
          return [];
        };

        process.binding = function (name) {
          throw new Error("process.binding is not supported");
        };

        process.cwd = function () {
          return "/";
        };
        process.chdir = function (dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function () {
          return 0;
        };
      },
      {},
    ],
    81: [
      function (require, module, exports) {
        (function (global) {
          /*! https://mths.be/punycode v1.4.1 by @mathias */
          (function (root) {
            /** Detect free variables */
            var freeExports =
              typeof exports == "object" &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              typeof module == "object" && module && !module.nodeType && module;
            var freeGlobal = typeof global == "object" && global;
            if (
              freeGlobal.global === freeGlobal ||
              freeGlobal.window === freeGlobal ||
              freeGlobal.self === freeGlobal
            ) {
              root = freeGlobal;
            }

            /**
             * The `punycode` object.
             * @name punycode
             * @type Object
             */
            var punycode,
              /** Highest positive signed 32-bit float value */
              maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
              /** Bootstring parameters */
              base = 36,
              tMin = 1,
              tMax = 26,
              skew = 38,
              damp = 700,
              initialBias = 72,
              initialN = 128, // 0x80
              delimiter = "-", // '\x2D'
              /** Regular expressions */
              regexPunycode = /^xn--/,
              regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
              regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
              /** Error messages */
              errors = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input",
              },
              /** Convenience shortcuts */
              baseMinusTMin = base - tMin,
              floor = Math.floor,
              stringFromCharCode = String.fromCharCode,
              /** Temporary variable */
              key;

            /*--------------------------------------------------------------------------*/

            /**
             * A generic error utility function.
             * @private
             * @param {String} type The error type.
             * @returns {Error} Throws a `RangeError` with the applicable error message.
             */
            function error(type) {
              throw new RangeError(errors[type]);
            }

            /**
             * A generic `Array#map` utility function.
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} callback The function that gets called for every array
             * item.
             * @returns {Array} A new array of values returned by the callback function.
             */
            function map(array, fn) {
              var length = array.length;
              var result = [];
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }

            /**
             * A simple `Array#map`-like wrapper to work with domain name strings or email
             * addresses.
             * @private
             * @param {String} domain The domain name or email address.
             * @param {Function} callback The function that gets called for every
             * character.
             * @returns {Array} A new string of characters returned by the callback
             * function.
             */
            function mapDomain(string, fn) {
              var parts = string.split("@");
              var result = "";
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + "@";
                string = parts[1];
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, "\x2E");
              var labels = string.split(".");
              var encoded = map(labels, fn).join(".");
              return result + encoded;
            }

            /**
             * Creates an array containing the numeric code points of each Unicode
             * character in the string. While JavaScript uses UCS-2 internally,
             * this function will convert a pair of surrogate halves (each of which
             * UCS-2 exposes as separate characters) into a single code point,
             * matching UTF-16.
             * @see `punycode.ucs2.encode`
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode.ucs2
             * @name decode
             * @param {String} string The Unicode input string (UCS-2).
             * @returns {Array} The new array of code points.
             */
            function ucs2decode(string) {
              var output = [],
                counter = 0,
                length = string.length,
                value,
                extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++);
                  if ((extra & 0xfc00) == 0xdc00) {
                    // low surrogate
                    output.push(
                      ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                    );
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }

            /**
             * Creates a string based on an array of numeric code points.
             * @see `punycode.ucs2.decode`
             * @memberOf punycode.ucs2
             * @name encode
             * @param {Array} codePoints The array of numeric code points.
             * @returns {String} The new Unicode string (UCS-2).
             */
            function ucs2encode(array) {
              return map(array, function (value) {
                var output = "";
                if (value > 0xffff) {
                  value -= 0x10000;
                  output += stringFromCharCode(
                    ((value >>> 10) & 0x3ff) | 0xd800
                  );
                  value = 0xdc00 | (value & 0x3ff);
                }
                output += stringFromCharCode(value);
                return output;
              }).join("");
            }

            /**
             * Converts a basic code point into a digit/integer.
             * @see `digitToBasic()`
             * @private
             * @param {Number} codePoint The basic numeric code point value.
             * @returns {Number} The numeric value of a basic code point (for use in
             * representing integers) in the range `0` to `base - 1`, or `base` if
             * the code point does not represent a value.
             */
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base;
            }

            /**
             * Converts a digit/integer into a basic code point.
             * @see `basicToDigit()`
             * @private
             * @param {Number} digit The numeric value of a basic code point.
             * @returns {Number} The basic code point whose value (when used for
             * representing integers) is `digit`, which needs to be in the range
             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
             * used; else, the lowercase form is used. The behavior is undefined
             * if `flag` is non-zero and `digit` has no uppercase form.
             */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }

            /**
             * Bias adaptation function as per section 3.4 of RFC 3492.
             * https://tools.ietf.org/html/rfc3492#section-3.4
             * @private
             */
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (
                ;
                /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
                k += base
              ) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
            }

            /**
             * Converts a Punycode string of ASCII-only symbols to a string of Unicode
             * symbols.
             * @memberOf punycode
             * @param {String} input The Punycode string of ASCII-only symbols.
             * @returns {String} The resulting string of Unicode symbols.
             */
            function decode(input) {
              // Don't use UCS-2
              var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,
                /** Cached calculation results */
                baseMinusT;

              // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.

              basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }

              for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                  error("not-basic");
                }
                output.push(input.charCodeAt(j));
              }

              // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.

              for (
                index = basic > 0 ? basic + 1 : 0;
                index < inputLength /* no final expression */;

              ) {
                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (
                  oldi = i, w = 1, k = base /* no condition */;
                  ;
                  k += base
                ) {
                  if (index >= inputLength) {
                    error("invalid-input");
                  }

                  digit = basicToDigit(input.charCodeAt(index++));

                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error("overflow");
                  }

                  i += digit * w;
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                  if (digit < t) {
                    break;
                  }

                  baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error("overflow");
                  }

                  w *= baseMinusT;
                }

                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error("overflow");
                }

                n += floor(i / out);
                i %= out;

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);
              }

              return ucs2encode(output);
            }

            /**
             * Converts a string of Unicode symbols (e.g. a domain name label) to a
             * Punycode string of ASCII-only symbols.
             * @memberOf punycode
             * @param {String} input The string of Unicode symbols.
             * @returns {String} The resulting Punycode string of ASCII-only symbols.
             */
            function encode(input) {
              var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],
                /** `inputLength` will hold the number of code points in `input`. */
                inputLength,
                /** Cached calculation results */
                handledCPCountPlusOne,
                baseMinusT,
                qMinusT;

              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input);

              // Cache the length
              inputLength = input.length;

              // Initialize the state
              n = initialN;
              delta = 0;
              bias = initialBias;

              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue));
                }
              }

              handledCPCount = basicLength = output.length;

              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.

              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter);
              }

              // Main encoding loop:
              while (handledCPCount < inputLength) {
                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error("overflow");
                }

                delta += (m - n) * handledCPCountPlusOne;
                n = m;

                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];

                  if (currentValue < n && ++delta > maxInt) {
                    error("overflow");
                  }

                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base /* no condition */; ; k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(
                        stringFromCharCode(
                          digitToBasic(t + (qMinusT % baseMinusT), 0)
                        )
                      );
                      q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(
                      delta,
                      handledCPCountPlusOne,
                      handledCPCount == basicLength
                    );
                    delta = 0;
                    ++handledCPCount;
                  }
                }

                ++delta;
                ++n;
              }
              return output.join("");
            }

            /**
             * Converts a Punycode string representing a domain name or an email address
             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
             * it doesn't matter if you call it on a string that has already been
             * converted to Unicode.
             * @memberOf punycode
             * @param {String} input The Punycoded domain name or email address to
             * convert to Unicode.
             * @returns {String} The Unicode representation of the given Punycode
             * string.
             */
            function toUnicode(input) {
              return mapDomain(input, function (string) {
                return regexPunycode.test(string)
                  ? decode(string.slice(4).toLowerCase())
                  : string;
              });
            }

            /**
             * Converts a Unicode string representing a domain name or an email address to
             * Punycode. Only the non-ASCII parts of the domain name will be converted,
             * i.e. it doesn't matter if you call it with a domain that's already in
             * ASCII.
             * @memberOf punycode
             * @param {String} input The domain name or email address to convert, as a
             * Unicode string.
             * @returns {String} The Punycode representation of the given domain name or
             * email address.
             */
            function toASCII(input) {
              return mapDomain(input, function (string) {
                return regexNonASCII.test(string)
                  ? "xn--" + encode(string)
                  : string;
              });
            }

            /*--------------------------------------------------------------------------*/

            /** Define the public API */
            punycode = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              version: "1.4.1",
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              ucs2: {
                decode: ucs2decode,
                encode: ucs2encode,
              },
              decode: decode,
              encode: encode,
              toASCII: toASCII,
              toUnicode: toUnicode,
            };

            /** Expose `punycode` */
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (
              typeof define == "function" &&
              typeof define.amd == "object" &&
              define.amd
            ) {
              define("punycode", function () {
                return punycode;
              });
            } else if (freeExports && freeModule) {
              if (module.exports == freeExports) {
                // in Node.js, io.js, or RingoJS v0.8.0+
                freeModule.exports = punycode;
              } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                  punycode.hasOwnProperty(key) &&
                    (freeExports[key] = punycode[key]);
                }
              }
            } else {
              // in Rhino or a web browser
              root.punycode = punycode;
            }
          })(this);
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {},
    ],
    82: [
      function (require, module, exports) {
        "use strict";
        const strictUriEncode = require("strict-uri-encode");
        const decodeComponent = require("decode-uri-component");
        const splitOnFirst = require("split-on-first");

        function encoderForArrayFormat(options) {
          switch (options.arrayFormat) {
            case "index":
              return (key) => (result, value) => {
                const index = result.length;
                if (value === undefined) {
                  return result;
                }

                if (value === null) {
                  return [
                    ...result,
                    [encode(key, options), "[", index, "]"].join(""),
                  ];
                }

                return [
                  ...result,
                  [
                    encode(key, options),
                    "[",
                    encode(index, options),
                    "]=",
                    encode(value, options),
                  ].join(""),
                ];
              };

            case "bracket":
              return (key) => (result, value) => {
                if (value === undefined) {
                  return result;
                }

                if (value === null) {
                  return [...result, [encode(key, options), "[]"].join("")];
                }

                return [
                  ...result,
                  [encode(key, options), "[]=", encode(value, options)].join(
                    ""
                  ),
                ];
              };

            case "comma":
              return (key) => (result, value, index) => {
                if (
                  value === null ||
                  value === undefined ||
                  value.length === 0
                ) {
                  return result;
                }

                if (index === 0) {
                  return [
                    [encode(key, options), "=", encode(value, options)].join(
                      ""
                    ),
                  ];
                }

                return [[result, encode(value, options)].join(",")];
              };

            default:
              return (key) => (result, value) => {
                if (value === undefined) {
                  return result;
                }

                if (value === null) {
                  return [...result, encode(key, options)];
                }

                return [
                  ...result,
                  [encode(key, options), "=", encode(value, options)].join(""),
                ];
              };
          }
        }

        function parserForArrayFormat(options) {
          let result;

          switch (options.arrayFormat) {
            case "index":
              return (key, value, accumulator) => {
                result = /\[(\d*)\]$/.exec(key);

                key = key.replace(/\[\d*\]$/, "");

                if (!result) {
                  accumulator[key] = value;
                  return;
                }

                if (accumulator[key] === undefined) {
                  accumulator[key] = {};
                }

                accumulator[key][result[1]] = value;
              };

            case "bracket":
              return (key, value, accumulator) => {
                result = /(\[\])$/.exec(key);
                key = key.replace(/\[\]$/, "");

                if (!result) {
                  accumulator[key] = value;
                  return;
                }

                if (accumulator[key] === undefined) {
                  accumulator[key] = [value];
                  return;
                }

                accumulator[key] = [].concat(accumulator[key], value);
              };

            case "comma":
              return (key, value, accumulator) => {
                const isArray =
                  typeof value === "string" &&
                  value.split("").indexOf(",") > -1;
                const newValue = isArray ? value.split(",") : value;
                accumulator[key] = newValue;
              };

            default:
              return (key, value, accumulator) => {
                if (accumulator[key] === undefined) {
                  accumulator[key] = value;
                  return;
                }

                accumulator[key] = [].concat(accumulator[key], value);
              };
          }
        }

        function encode(value, options) {
          if (options.encode) {
            return options.strict
              ? strictUriEncode(value)
              : encodeURIComponent(value);
          }

          return value;
        }

        function decode(value, options) {
          if (options.decode) {
            return decodeComponent(value);
          }

          return value;
        }

        function keysSorter(input) {
          if (Array.isArray(input)) {
            return input.sort();
          }

          if (typeof input === "object") {
            return keysSorter(Object.keys(input))
              .sort((a, b) => Number(a) - Number(b))
              .map((key) => input[key]);
          }

          return input;
        }

        function removeHash(input) {
          const hashStart = input.indexOf("#");
          if (hashStart !== -1) {
            input = input.slice(0, hashStart);
          }

          return input;
        }

        function extract(input) {
          input = removeHash(input);
          const queryStart = input.indexOf("?");
          if (queryStart === -1) {
            return "";
          }

          return input.slice(queryStart + 1);
        }

        function parseValue(value, options) {
          if (
            options.parseNumbers &&
            !Number.isNaN(Number(value)) &&
            typeof value === "string" &&
            value.trim() !== ""
          ) {
            value = Number(value);
          } else if (
            options.parseBooleans &&
            value !== null &&
            (value.toLowerCase() === "true" || value.toLowerCase() === "false")
          ) {
            value = value.toLowerCase() === "true";
          }

          return value;
        }

        function parse(input, options) {
          options = Object.assign(
            {
              decode: true,
              sort: true,
              arrayFormat: "none",
              parseNumbers: false,
              parseBooleans: false,
            },
            options
          );

          const formatter = parserForArrayFormat(options);

          // Create an object with no prototype
          const ret = Object.create(null);

          if (typeof input !== "string") {
            return ret;
          }

          input = input.trim().replace(/^[?#&]/, "");

          if (!input) {
            return ret;
          }

          for (const param of input.split("&")) {
            let [key, value] = splitOnFirst(param.replace(/\+/g, " "), "=");

            // Missing `=` should be `null`:
            // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
            value = value === undefined ? null : decode(value, options);
            formatter(decode(key, options), value, ret);
          }

          for (const key of Object.keys(ret)) {
            const value = ret[key];
            if (typeof value === "object" && value !== null) {
              for (const k of Object.keys(value)) {
                value[k] = parseValue(value[k], options);
              }
            } else {
              ret[key] = parseValue(value, options);
            }
          }

          if (options.sort === false) {
            return ret;
          }

          return (options.sort === true
            ? Object.keys(ret).sort()
            : Object.keys(ret).sort(options.sort)
          ).reduce((result, key) => {
            const value = ret[key];
            if (
              Boolean(value) &&
              typeof value === "object" &&
              !Array.isArray(value)
            ) {
              // Sort object keys, not values
              result[key] = keysSorter(value);
            } else {
              result[key] = value;
            }

            return result;
          }, Object.create(null));
        }

        exports.extract = extract;
        exports.parse = parse;

        exports.stringify = (object, options) => {
          if (!object) {
            return "";
          }

          options = Object.assign(
            {
              encode: true,
              strict: true,
              arrayFormat: "none",
            },
            options
          );

          const formatter = encoderForArrayFormat(options);
          const keys = Object.keys(object);

          if (options.sort !== false) {
            keys.sort(options.sort);
          }

          return keys
            .map((key) => {
              const value = object[key];

              if (value === undefined) {
                return "";
              }

              if (value === null) {
                return encode(key, options);
              }

              if (Array.isArray(value)) {
                return value.reduce(formatter(key), []).join("&");
              }

              return encode(key, options) + "=" + encode(value, options);
            })
            .filter((x) => x.length > 0)
            .join("&");
        };

        exports.parseUrl = (input, options) => {
          return {
            url: removeHash(input).split("?")[0] || "",
            query: parse(extract(input), options),
          };
        };
      },
      {
        "decode-uri-component": 53,
        "split-on-first": 553,
        "strict-uri-encode": 556,
      },
    ],
    83: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }

        module.exports = function (qs, sep, eq, options) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};

          if (typeof qs !== "string" || qs.length === 0) {
            return obj;
          }

          var regexp = /\+/g;
          qs = qs.split(sep);

          var maxKeys = 1000;
          if (options && typeof options.maxKeys === "number") {
            maxKeys = options.maxKeys;
          }

          var len = qs.length;
          // maxKeys <= 0 means that we should not limit keys count
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }

          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, "%20"),
              idx = x.indexOf(eq),
              kstr,
              vstr,
              k,
              v;

            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = "";
            }

            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);

            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }

          return obj;
        };

        var isArray =
          Array.isArray ||
          function (xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };
      },
      {},
    ],
    84: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        var stringifyPrimitive = function (v) {
          switch (typeof v) {
            case "string":
              return v;

            case "boolean":
              return v ? "true" : "false";

            case "number":
              return isFinite(v) ? v : "";

            default:
              return "";
          }
        };

        module.exports = function (obj, sep, eq, name) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = undefined;
          }

          if (typeof obj === "object") {
            return map(objectKeys(obj), function (k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function (v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }

          if (!name) return "";
          return (
            encodeURIComponent(stringifyPrimitive(name)) +
            eq +
            encodeURIComponent(stringifyPrimitive(obj))
          );
        };

        var isArray =
          Array.isArray ||
          function (xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };

        function map(xs, f) {
          if (xs.map) return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }

        var objectKeys =
          Object.keys ||
          function (obj) {
            var res = [];
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
          };
      },
      {},
    ],
    85: [
      function (require, module, exports) {
        "use strict";

        exports.decode = exports.parse = require("./decode");
        exports.encode = exports.stringify = require("./encode");
      },
      { "./decode": 83, "./encode": 84 },
    ],
    86: [
      function (require, module, exports) {
        module.exports = require("./lib/_stream_duplex.js");
      },
      { "./lib/_stream_duplex.js": 87 },
    ],
    87: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a duplex stream is just a stream that is both readable and writable.
        // Since JS doesn't have multiple prototypal inheritance, this class
        // prototypally inherits from Readable, and then parasitically from
        // Writable.

        "use strict";

        /*<replacement>*/

        var pna = require("process-nextick-args");
        /*</replacement>*/

        /*<replacement>*/
        var objectKeys =
          Object.keys ||
          function (obj) {
            var keys = [];
            for (var key in obj) {
              keys.push(key);
            }
            return keys;
          };
        /*</replacement>*/

        module.exports = Duplex;

        /*<replacement>*/
        var util = Object.create(require("core-util-is"));
        util.inherits = require("inherits");
        /*</replacement>*/

        var Readable = require("./_stream_readable");
        var Writable = require("./_stream_writable");

        util.inherits(Duplex, Readable);

        {
          // avoid scope creep, the keys array can then be collected
          var keys = objectKeys(Writable.prototype);
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
        }

        function Duplex(options) {
          if (!(this instanceof Duplex)) return new Duplex(options);

          Readable.call(this, options);
          Writable.call(this, options);

          if (options && options.readable === false) this.readable = false;

          if (options && options.writable === false) this.writable = false;

          this.allowHalfOpen = true;
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false;

          this.once("end", onend);
        }

        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function () {
            return this._writableState.highWaterMark;
          },
        });

        // the no-half-open enforcer
        function onend() {
          // if we allow half-open state, or if the writable side ended,
          // then we're ok.
          if (this.allowHalfOpen || this._writableState.ended) return;

          // no more data can be written.
          // But allow more writes to happen in this tick.
          pna.nextTick(onEndNT, this);
        }

        function onEndNT(self) {
          self.end();
        }

        Object.defineProperty(Duplex.prototype, "destroyed", {
          get: function () {
            if (
              this._readableState === undefined ||
              this._writableState === undefined
            ) {
              return false;
            }
            return (
              this._readableState.destroyed && this._writableState.destroyed
            );
          },
          set: function (value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (
              this._readableState === undefined ||
              this._writableState === undefined
            ) {
              return;
            }

            // backward compatibility, the user is explicitly
            // managing destroyed
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          },
        });

        Duplex.prototype._destroy = function (err, cb) {
          this.push(null);
          this.end();

          pna.nextTick(cb, err);
        };
      },
      {
        "./_stream_readable": 89,
        "./_stream_writable": 91,
        "core-util-is": 52,
        inherits: 63,
        "process-nextick-args": 79,
      },
    ],
    88: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a passthrough stream.
        // basically just the most minimal sort of Transform stream.
        // Every written chunk gets output as-is.

        "use strict";

        module.exports = PassThrough;

        var Transform = require("./_stream_transform");

        /*<replacement>*/
        var util = Object.create(require("core-util-is"));
        util.inherits = require("inherits");
        /*</replacement>*/

        util.inherits(PassThrough, Transform);

        function PassThrough(options) {
          if (!(this instanceof PassThrough)) return new PassThrough(options);

          Transform.call(this, options);
        }

        PassThrough.prototype._transform = function (chunk, encoding, cb) {
          cb(null, chunk);
        };
      },
      { "./_stream_transform": 90, "core-util-is": 52, inherits: 63 },
    ],
    89: [
      function (require, module, exports) {
        (function (process, global) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          "use strict";

          /*<replacement>*/

          var pna = require("process-nextick-args");
          /*</replacement>*/

          module.exports = Readable;

          /*<replacement>*/
          var isArray = require("isarray");
          /*</replacement>*/

          /*<replacement>*/
          var Duplex;
          /*</replacement>*/

          Readable.ReadableState = ReadableState;

          /*<replacement>*/
          var EE = require("events").EventEmitter;

          var EElistenerCount = function (emitter, type) {
            return emitter.listeners(type).length;
          };
          /*</replacement>*/

          /*<replacement>*/
          var Stream = require("./internal/streams/stream");
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = require("safe-buffer").Buffer;
          var OurUint8Array = global.Uint8Array || function () {};
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }

          /*</replacement>*/

          /*<replacement>*/
          var util = Object.create(require("core-util-is"));
          util.inherits = require("inherits");
          /*</replacement>*/

          /*<replacement>*/
          var debugUtil = require("util");
          var debug = void 0;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream");
          } else {
            debug = function () {};
          }
          /*</replacement>*/

          var BufferList = require("./internal/streams/BufferList");
          var destroyImpl = require("./internal/streams/destroy");
          var StringDecoder;

          util.inherits(Readable, Stream);

          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];

          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn);

            // This is a hack to make sure that our error handler is attached before any
            // userland ones.  NEVER DO THIS. This is here only because this code needs
            // to continue to work with older versions of Node.js that do not include
            // the prependListener() method. The goal is to eventually remove this hack.
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn);
            else if (isArray(emitter._events[event]))
              emitter._events[event].unshift(fn);
            else emitter._events[event] = [fn, emitter._events[event]];
          }

          function ReadableState(options, stream) {
            Duplex = Duplex || require("./_stream_duplex");

            options = options || {};

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex;

            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode;

            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;

            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark;
            var readableHwm = options.readableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;

            if (hwm || hwm === 0) this.highWaterMark = hwm;
            else if (isDuplex && (readableHwm || readableHwm === 0))
              this.highWaterMark = readableHwm;
            else this.highWaterMark = defaultHwm;

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark);

            // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;

            // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.
            this.sync = true;

            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;

            // has it been destroyed
            this.destroyed = false;

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || "utf8";

            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0;

            // if true, a maybeReadMore has been scheduled
            this.readingMore = false;

            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require("string_decoder/").StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }

          function Readable(options) {
            Duplex = Duplex || require("./_stream_duplex");

            if (!(this instanceof Readable)) return new Readable(options);

            this._readableState = new ReadableState(options, this);

            // legacy
            this.readable = true;

            if (options) {
              if (typeof options.read === "function") this._read = options.read;

              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
            }

            Stream.call(this);
          }

          Object.defineProperty(Readable.prototype, "destroyed", {
            get: function () {
              if (this._readableState === undefined) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function (value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return;
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._readableState.destroyed = value;
            },
          });

          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function (err, cb) {
            this.push(null);
            cb(err);
          };

          // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.
          Readable.prototype.push = function (chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;

            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = "";
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }

            return readableAddChunk(
              this,
              chunk,
              encoding,
              false,
              skipChunkCheck
            );
          };

          // Unshift should *always* be something directly out of read()
          Readable.prototype.unshift = function (chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };

          function readableAddChunk(
            stream,
            chunk,
            encoding,
            addToFront,
            skipChunkCheck
          ) {
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck) er = chunkInvalid(state, chunk);
              if (er) {
                stream.emit("error", er);
              } else if (state.objectMode || (chunk && chunk.length > 0)) {
                if (
                  typeof chunk !== "string" &&
                  !state.objectMode &&
                  Object.getPrototypeOf(chunk) !== Buffer.prototype
                ) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }

                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit(
                      "error",
                      new Error("stream.unshift() after end event")
                    );
                  else addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  stream.emit("error", new Error("stream.push() after EOF"));
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
              }
            }

            return needMoreData(state);
          }

          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit("data", chunk);
              stream.read(0);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);
              else state.buffer.push(chunk);

              if (state.needReadable) emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }

          function chunkInvalid(state, chunk) {
            var er;
            if (
              !_isUint8Array(chunk) &&
              typeof chunk !== "string" &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError("Invalid non-string/buffer chunk");
            }
            return er;
          }

          // if it's past the high water mark, we can push in some more.
          // Also, if we have no data yet, we can stand some
          // more bytes.  This is to work around cases where hwm=0,
          // such as the repl.  Also, if the push() triggered a
          // readable event, and the user called read(largeNumber) such that
          // needReadable was set, then we ought to push more, so that another
          // 'readable' event will be triggered.
          function needMoreData(state) {
            return (
              !state.ended &&
              (state.needReadable ||
                state.length < state.highWaterMark ||
                state.length === 0)
            );
          }

          Readable.prototype.isPaused = function () {
            return this._readableState.flowing === false;
          };

          // backwards compatibility.
          Readable.prototype.setEncoding = function (enc) {
            if (!StringDecoder)
              StringDecoder = require("string_decoder/").StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
          };

          // Don't raise the hwm > 8MB
          var MAX_HWM = 0x800000;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }

          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function howMuchToRead(n, state) {
            if (n <= 0 || (state.length === 0 && state.ended)) return 0;
            if (state.objectMode) return 1;
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else return state.length;
            }
            // If we're asking for more than the current hwm, then raise the hwm.
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length) return n;
            // Don't have enough
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }

          // you can override either this method, or the async _read(n) below.
          Readable.prototype.read = function (n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;

            if (n !== 0) state.emittedReadable = false;

            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (
              n === 0 &&
              state.needReadable &&
              (state.length >= state.highWaterMark || state.ended)
            ) {
              debug("read: emitReadable", state.length, state.ended);
              if (state.length === 0 && state.ended) endReadable(this);
              else emitReadable(this);
              return null;
            }

            n = howMuchToRead(n, state);

            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
              if (state.length === 0) endReadable(this);
              return null;
            }

            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.

            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable;
            debug("need readable", doRead);

            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug("length less than watermark", doRead);
            }

            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
              doRead = false;
              debug("reading or ended", doRead);
            } else if (doRead) {
              debug("do read");
              state.reading = true;
              state.sync = true;
              // if the length is currently zero, then we *need* a readable event.
              if (state.length === 0) state.needReadable = true;
              // call internal read method
              this._read(state.highWaterMark);
              state.sync = false;
              // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.
              if (!state.reading) n = howMuchToRead(nOrig, state);
            }

            var ret;
            if (n > 0) ret = fromList(n, state);
            else ret = null;

            if (ret === null) {
              state.needReadable = true;
              n = 0;
            } else {
              state.length -= n;
            }

            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended) state.needReadable = true;

              // If we tried to read() past the EOF, then emit end on the next tick.
              if (nOrig !== n && state.ended) endReadable(this);
            }

            if (ret !== null) this.emit("data", ret);

            return ret;
          };

          function onEofChunk(stream, state) {
            if (state.ended) return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;

            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream);
          }

          // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing);
              state.emittedReadable = true;
              if (state.sync) pna.nextTick(emitReadable_, stream);
              else emitReadable_(stream);
            }
          }

          function emitReadable_(stream) {
            debug("emit readable");
            stream.emit("readable");
            flow(stream);
          }

          // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              pna.nextTick(maybeReadMore_, stream, state);
            }
          }

          function maybeReadMore_(stream, state) {
            var len = state.length;
            while (
              !state.reading &&
              !state.flowing &&
              !state.ended &&
              state.length < state.highWaterMark
            ) {
              debug("maybeReadMore read 0");
              stream.read(0);
              if (len === state.length)
                // didn't get any data, stop spinning.
                break;
              else len = state.length;
            }
            state.readingMore = false;
          }

          // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.
          Readable.prototype._read = function (n) {
            this.emit("error", new Error("_read() is not implemented"));
          };

          Readable.prototype.pipe = function (dest, pipeOpts) {
            var src = this;
            var state = this._readableState;

            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);

            var doEnd =
              (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted) pna.nextTick(endFn);
            else src.once("end", endFn);

            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe");
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }

            function onend() {
              debug("onend");
              dest.end();
            }

            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);

            var cleanedUp = false;
            function cleanup() {
              debug("cleanup");
              // cleanup event handlers once the pipe is broken
              dest.removeListener("close", onclose);
              dest.removeListener("finish", onfinish);
              dest.removeListener("drain", ondrain);
              dest.removeListener("error", onerror);
              dest.removeListener("unpipe", onunpipe);
              src.removeListener("end", onend);
              src.removeListener("end", unpipe);
              src.removeListener("data", ondata);

              cleanedUp = true;

              // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.
              if (
                state.awaitDrain &&
                (!dest._writableState || dest._writableState.needDrain)
              )
                ondrain();
            }

            // If the user pushes more data while we're writing to dest then we'll end up
            // in ondata again. However, we only want to increase awaitDrain once because
            // dest will only emit one 'drain' event for the multiple writes.
            // => Introduce a guard on increasing awaitDrain.
            var increasedAwaitDrain = false;
            src.on("data", ondata);
            function ondata(chunk) {
              debug("ondata");
              increasedAwaitDrain = false;
              var ret = dest.write(chunk);
              if (false === ret && !increasedAwaitDrain) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if (
                  ((state.pipesCount === 1 && state.pipes === dest) ||
                    (state.pipesCount > 1 &&
                      indexOf(state.pipes, dest) !== -1)) &&
                  !cleanedUp
                ) {
                  debug(
                    "false write response, pause",
                    src._readableState.awaitDrain
                  );
                  src._readableState.awaitDrain++;
                  increasedAwaitDrain = true;
                }
                src.pause();
              }
            }

            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
              debug("onerror", er);
              unpipe();
              dest.removeListener("error", onerror);
              if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
            }

            // Make sure our error handler is attached before userland ones.
            prependListener(dest, "error", onerror);

            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
              dest.removeListener("finish", onfinish);
              unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
              debug("onfinish");
              dest.removeListener("close", onclose);
              unpipe();
            }
            dest.once("finish", onfinish);

            function unpipe() {
              debug("unpipe");
              src.unpipe(dest);
            }

            // tell the dest that it's being piped to
            dest.emit("pipe", src);

            // start the flow if it hasn't been started already.
            if (!state.flowing) {
              debug("pipe resume");
              src.resume();
            }

            return dest;
          };

          function pipeOnDrain(src) {
            return function () {
              var state = src._readableState;
              debug("pipeOnDrain", state.awaitDrain);
              if (state.awaitDrain) state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true;
                flow(src);
              }
            };
          }

          Readable.prototype.unpipe = function (dest) {
            var state = this._readableState;
            var unpipeInfo = { hasUnpiped: false };

            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0) return this;

            // just one destination.  most common case.
            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes) return this;

              if (!dest) dest = state.pipes;

              // got a match.
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest) dest.emit("unpipe", this, unpipeInfo);
              return this;
            }

            // slow case. multiple pipe destinations.

            if (!dest) {
              // remove all.
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;

              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, unpipeInfo);
              }
              return this;
            }

            // try to find the right one.
            var index = indexOf(state.pipes, dest);
            if (index === -1) return this;

            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1) state.pipes = state.pipes[0];

            dest.emit("unpipe", this, unpipeInfo);

            return this;
          };

          // set up data events if they are asked for
          // Ensure readable listeners eventually get something
          Readable.prototype.on = function (ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);

            if (ev === "data") {
              // Start flowing on next tick if stream isn't explicitly paused
              if (this._readableState.flowing !== false) this.resume();
            } else if (ev === "readable") {
              var state = this._readableState;
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.emittedReadable = false;
                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this);
                } else if (state.length) {
                  emitReadable(this);
                }
              }
            }

            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;

          function nReadingNextTick(self) {
            debug("readable nexttick read 0");
            self.read(0);
          }

          // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.
          Readable.prototype.resume = function () {
            var state = this._readableState;
            if (!state.flowing) {
              debug("resume");
              state.flowing = true;
              resume(this, state);
            }
            return this;
          };

          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              pna.nextTick(resume_, stream, state);
            }
          }

          function resume_(stream, state) {
            if (!state.reading) {
              debug("resume read 0");
              stream.read(0);
            }

            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading) stream.read(0);
          }

          Readable.prototype.pause = function () {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (false !== this._readableState.flowing) {
              debug("pause");
              this._readableState.flowing = false;
              this.emit("pause");
            }
            return this;
          };

          function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && stream.read() !== null) {}
          }

          // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.
          Readable.prototype.wrap = function (stream) {
            var _this = this;

            var state = this._readableState;
            var paused = false;

            stream.on("end", function () {
              debug("wrapped end");
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) _this.push(chunk);
              }

              _this.push(null);
            });

            stream.on("data", function (chunk) {
              debug("wrapped data");
              if (state.decoder) chunk = state.decoder.write(chunk);

              // don't skip over falsy values in objectMode
              if (state.objectMode && (chunk === null || chunk === undefined))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length)) return;

              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });

            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === "function") {
                this[i] = (function (method) {
                  return function () {
                    return stream[method].apply(stream, arguments);
                  };
                })(i);
              }
            }

            // proxy certain important events.
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            }

            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            this._read = function (n) {
              debug("wrapped _read", n);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };

            return this;
          };

          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function () {
              return this._readableState.highWaterMark;
            },
          });

          // exposed for testing purposes only.
          Readable._fromList = fromList;

          // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0) return null;

            var ret;
            if (state.objectMode) ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder) ret = state.buffer.join("");
              else if (state.buffer.length === 1) ret = state.buffer.head.data;
              else ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              // read part of list
              ret = fromListPartial(n, state.buffer, state.decoder);
            }

            return ret;
          }

          // Extracts only enough buffered data to satisfy the amount requested.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromListPartial(n, list, hasStrings) {
            var ret;
            if (n < list.head.data.length) {
              // slice is the same for buffers and strings
              ret = list.head.data.slice(0, n);
              list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) {
              // first chunk is a perfect match
              ret = list.shift();
            } else {
              // result spans more than one buffer
              ret = hasStrings
                ? copyFromBufferString(n, list)
                : copyFromBuffer(n, list);
            }
            return ret;
          }

          // Copies a specified amount of characters from the list of buffered data
          // chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while ((p = p.next)) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str;
              else ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) list.head = p.next;
                  else list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }

          // Copies a specified amount of bytes from the list of buffered data chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while ((p = p.next)) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) list.head = p.next;
                  else list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }

          function endReadable(stream) {
            var state = stream._readableState;

            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream');

            if (!state.endEmitted) {
              state.ended = true;
              pna.nextTick(endReadableNT, state, stream);
            }
          }

          function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit("end");
            }
          }

          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x) return i;
            }
            return -1;
          }
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {
        "./_stream_duplex": 87,
        "./internal/streams/BufferList": 92,
        "./internal/streams/destroy": 93,
        "./internal/streams/stream": 94,
        _process: 80,
        "core-util-is": 52,
        events: 56,
        inherits: 63,
        isarray: 66,
        "process-nextick-args": 79,
        "safe-buffer": 550,
        "string_decoder/": 95,
        util: 49,
      },
    ],
    90: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a transform stream is a readable/writable stream where you do
        // something with the data.  Sometimes it's called a "filter",
        // but that's not a great name for it, since that implies a thing where
        // some bits pass through, and others are simply ignored.  (That would
        // be a valid example of a transform, of course.)
        //
        // While the output is causally related to the input, it's not a
        // necessarily symmetric or synchronous transformation.  For example,
        // a zlib stream might take multiple plain-text writes(), and then
        // emit a single compressed chunk some time in the future.
        //
        // Here's how this works:
        //
        // The Transform stream has all the aspects of the readable and writable
        // stream classes.  When you write(chunk), that calls _write(chunk,cb)
        // internally, and returns false if there's a lot of pending writes
        // buffered up.  When you call read(), that calls _read(n) until
        // there's enough pending readable data buffered up.
        //
        // In a transform stream, the written data is placed in a buffer.  When
        // _read(n) is called, it transforms the queued up data, calling the
        // buffered _write cb's as it consumes chunks.  If consuming a single
        // written chunk would result in multiple output chunks, then the first
        // outputted bit calls the readcb, and subsequent chunks just go into
        // the read buffer, and will cause it to emit 'readable' if necessary.
        //
        // This way, back-pressure is actually determined by the reading side,
        // since _read has to be called to start processing a new chunk.  However,
        // a pathological inflate type of transform can cause excessive buffering
        // here.  For example, imagine a stream where every byte of input is
        // interpreted as an integer from 0-255, and then results in that many
        // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
        // 1kb of data being output.  In this case, you could write a very small
        // amount of input, and end up with a very large amount of output.  In
        // such a pathological inflating mechanism, there'd be no way to tell
        // the system to stop doing the transform.  A single 4MB write could
        // cause the system to run out of memory.
        //
        // However, even in such a pathological case, only a single written chunk
        // would be consumed, and then the rest would wait (un-transformed) until
        // the results of the previous transformed chunk were consumed.

        "use strict";

        module.exports = Transform;

        var Duplex = require("./_stream_duplex");

        /*<replacement>*/
        var util = Object.create(require("core-util-is"));
        util.inherits = require("inherits");
        /*</replacement>*/

        util.inherits(Transform, Duplex);

        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;

          var cb = ts.writecb;

          if (!cb) {
            return this.emit(
              "error",
              new Error("write callback called multiple times")
            );
          }

          ts.writechunk = null;
          ts.writecb = null;

          if (data != null)
            // single equals check for both `null` and `undefined`
            this.push(data);

          cb(er);

          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }

        function Transform(options) {
          if (!(this instanceof Transform)) return new Transform(options);

          Duplex.call(this, options);

          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null,
          };

          // start out asking for a readable event once data is transformed.
          this._readableState.needReadable = true;

          // we have implemented the _read method, and done the other things
          // that Readable wants before the first _read call, so unset the
          // sync guard flag.
          this._readableState.sync = false;

          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;

            if (typeof options.flush === "function")
              this._flush = options.flush;
          }

          // When the writable side finishes, then flush out anything remaining.
          this.on("prefinish", prefinish);
        }

        function prefinish() {
          var _this = this;

          if (typeof this._flush === "function") {
            this._flush(function (er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }

        Transform.prototype.push = function (chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };

        // This is the part where you do stuff!
        // override this function in implementation classes.
        // 'chunk' is an input chunk.
        //
        // Call `push(newChunk)` to pass along transformed output
        // to the readable side.  You may call 'push' zero or more times.
        //
        // Call `cb(err)` when you are done with this chunk.  If you pass
        // an error, then that'll put the hurt on the whole operation.  If you
        // never call cb(), then you'll never get another chunk.
        Transform.prototype._transform = function (chunk, encoding, cb) {
          throw new Error("_transform() is not implemented");
        };

        Transform.prototype._write = function (chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (
              ts.needTransform ||
              rs.needReadable ||
              rs.length < rs.highWaterMark
            )
              this._read(rs.highWaterMark);
          }
        };

        // Doesn't matter what the args are here.
        // _transform does all the work.
        // That we got here means that the readable side wants more data.
        Transform.prototype._read = function (n) {
          var ts = this._transformState;

          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true;
          }
        };

        Transform.prototype._destroy = function (err, cb) {
          var _this2 = this;

          Duplex.prototype._destroy.call(this, err, function (err2) {
            cb(err2);
            _this2.emit("close");
          });
        };

        function done(stream, er, data) {
          if (er) return stream.emit("error", er);

          if (data != null)
            // single equals check for both `null` and `undefined`
            stream.push(data);

          // if there's nothing in the write buffer, then that means
          // that nothing more will ever be provided
          if (stream._writableState.length)
            throw new Error("Calling transform done when ws.length != 0");

          if (stream._transformState.transforming)
            throw new Error("Calling transform done when still transforming");

          return stream.push(null);
        }
      },
      { "./_stream_duplex": 87, "core-util-is": 52, inherits: 63 },
    ],
    91: [
      function (require, module, exports) {
        (function (process, global, setImmediate) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.

          "use strict";

          /*<replacement>*/

          var pna = require("process-nextick-args");
          /*</replacement>*/

          module.exports = Writable;

          /* <replacement> */
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
          }

          // It seems a linked list but it is not
          // there will be only 2 of these for each stream
          function CorkedRequest(state) {
            var _this = this;

            this.next = null;
            this.entry = null;
            this.finish = function () {
              onCorkedFinish(_this, state);
            };
          }
          /* </replacement> */

          /*<replacement>*/
          var asyncWrite =
            !process.browser &&
            ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1
              ? setImmediate
              : pna.nextTick;
          /*</replacement>*/

          /*<replacement>*/
          var Duplex;
          /*</replacement>*/

          Writable.WritableState = WritableState;

          /*<replacement>*/
          var util = Object.create(require("core-util-is"));
          util.inherits = require("inherits");
          /*</replacement>*/

          /*<replacement>*/
          var internalUtil = {
            deprecate: require("util-deprecate"),
          };
          /*</replacement>*/

          /*<replacement>*/
          var Stream = require("./internal/streams/stream");
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = require("safe-buffer").Buffer;
          var OurUint8Array = global.Uint8Array || function () {};
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }

          /*</replacement>*/

          var destroyImpl = require("./internal/streams/destroy");

          util.inherits(Writable, Stream);

          function nop() {}

          function WritableState(options, stream) {
            Duplex = Duplex || require("./_stream_duplex");

            options = options || {};

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex;

            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode;

            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;

            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark;
            var writableHwm = options.writableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;

            if (hwm || hwm === 0) this.highWaterMark = hwm;
            else if (isDuplex && (writableHwm || writableHwm === 0))
              this.highWaterMark = writableHwm;
            else this.highWaterMark = defaultHwm;

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark);

            // if _final has been called
            this.finalCalled = false;

            // drain event flag.
            this.needDrain = false;
            // at the start of calling end()
            this.ending = false;
            // when end() has been called, and returned
            this.ended = false;
            // when 'finish' is emitted
            this.finished = false;

            // has it been destroyed
            this.destroyed = false;

            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || "utf8";

            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0;

            // a flag to see when we're in the middle of a write.
            this.writing = false;

            // when true all writes will be buffered until .uncork() call
            this.corked = 0;

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;

            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false;

            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function (er) {
              onwrite(stream, er);
            };

            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null;

            // the amount that is being written when _write is called.
            this.writelen = 0;

            this.bufferedRequest = null;
            this.lastBufferedRequest = null;

            // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted
            this.pendingcb = 0;

            // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams
            this.prefinished = false;

            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false;

            // count buffered requests
            this.bufferedRequestCount = 0;

            // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two
            this.corkedRequestsFree = new CorkedRequest(this);
          }

          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };

          (function () {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", {
                get: internalUtil.deprecate(
                  function () {
                    return this.getBuffer();
                  },
                  "_writableState.buffer is deprecated. Use _writableState.getBuffer " +
                    "instead.",
                  "DEP0003"
                ),
              });
            } catch (_) {}
          })();

          // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.
          var realHasInstance;
          if (
            typeof Symbol === "function" &&
            Symbol.hasInstance &&
            typeof Function.prototype[Symbol.hasInstance] === "function"
          ) {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function (object) {
                if (realHasInstance.call(this, object)) return true;
                if (this !== Writable) return false;

                return object && object._writableState instanceof WritableState;
              },
            });
          } else {
            realHasInstance = function (object) {
              return object instanceof this;
            };
          }

          function Writable(options) {
            Duplex = Duplex || require("./_stream_duplex");

            // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.

            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.
            if (
              !realHasInstance.call(Writable, this) &&
              !(this instanceof Duplex)
            ) {
              return new Writable(options);
            }

            this._writableState = new WritableState(options, this);

            // legacy.
            this.writable = true;

            if (options) {
              if (typeof options.write === "function")
                this._write = options.write;

              if (typeof options.writev === "function")
                this._writev = options.writev;

              if (typeof options.destroy === "function")
                this._destroy = options.destroy;

              if (typeof options.final === "function")
                this._final = options.final;
            }

            Stream.call(this);
          }

          // Otherwise people can pipe Writable streams, which is just wrong.
          Writable.prototype.pipe = function () {
            this.emit("error", new Error("Cannot pipe, not readable"));
          };

          function writeAfterEnd(stream, cb) {
            var er = new Error("write after end");
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit("error", er);
            pna.nextTick(cb, er);
          }

          // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er = false;

            if (chunk === null) {
              er = new TypeError("May not write null values to stream");
            } else if (
              typeof chunk !== "string" &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError("Invalid non-string/buffer chunk");
            }
            if (er) {
              stream.emit("error", er);
              pna.nextTick(cb, er);
              valid = false;
            }
            return valid;
          }

          Writable.prototype.write = function (chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);

            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }

            if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }

            if (isBuf) encoding = "buffer";
            else if (!encoding) encoding = state.defaultEncoding;

            if (typeof cb !== "function") cb = nop;

            if (state.ended) writeAfterEnd(this, cb);
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }

            return ret;
          };

          Writable.prototype.cork = function () {
            var state = this._writableState;

            state.corked++;
          };

          Writable.prototype.uncork = function () {
            var state = this._writableState;

            if (state.corked) {
              state.corked--;

              if (
                !state.writing &&
                !state.corked &&
                !state.finished &&
                !state.bufferProcessing &&
                state.bufferedRequest
              )
                clearBuffer(this, state);
            }
          };

          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(
            encoding
          ) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === "string") encoding = encoding.toLowerCase();
            if (
              !(
                [
                  "hex",
                  "utf8",
                  "utf-8",
                  "ascii",
                  "binary",
                  "base64",
                  "ucs2",
                  "ucs-2",
                  "utf16le",
                  "utf-16le",
                  "raw",
                ].indexOf((encoding + "").toLowerCase()) > -1
              )
            )
              throw new TypeError("Unknown encoding: " + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };

          function decodeChunk(state, chunk, encoding) {
            if (
              !state.objectMode &&
              state.decodeStrings !== false &&
              typeof chunk === "string"
            ) {
              chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
          }

          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function () {
              return this._writableState.highWaterMark;
            },
          });

          // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = "buffer";
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;

            state.length += len;

            var ret = state.length < state.highWaterMark;
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret) state.needDrain = true;

            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null,
              };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }

            return ret;
          }

          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev) stream._writev(chunk, state.onwrite);
            else stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }

          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;

            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              pna.nextTick(cb, er);
              // this can emit finish, and it will always happen
              // after error
              pna.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
              // this can emit finish, but finish must
              // always follow error
              finishMaybe(stream, state);
            }
          }

          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }

          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;

            onwriteStateUpdate(state);

            if (er) onwriteError(stream, state, sync, er, cb);
            else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state);

              if (
                !finished &&
                !state.corked &&
                !state.bufferProcessing &&
                state.bufferedRequest
              ) {
                clearBuffer(stream, state);
              }

              if (sync) {
                /*<replacement>*/
                asyncWrite(afterWrite, stream, state, finished, cb);
                /*</replacement>*/
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }

          function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }

          // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit("drain");
            }
          }

          // if there's something in the buffer waiting, then process it
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;

            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;

              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf) allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;

              doWrite(
                stream,
                state,
                true,
                state.length,
                buffer,
                "",
                holder.finish
              );

              // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;

                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--;
                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                  break;
                }
              }

              if (entry === null) state.lastBufferedRequest = null;
            }

            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }

          Writable.prototype._write = function (chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"));
          };

          Writable.prototype._writev = null;

          Writable.prototype.end = function (chunk, encoding, cb) {
            var state = this._writableState;

            if (typeof chunk === "function") {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }

            if (chunk !== null && chunk !== undefined)
              this.write(chunk, encoding);

            // .end() fully uncorks
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }

            // ignore unnecessary end() calls.
            if (!state.ending && !state.finished) endWritable(this, state, cb);
          };

          function needFinish(state) {
            return (
              state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing
            );
          }
          function callFinal(stream, state) {
            stream._final(function (err) {
              state.pendingcb--;
              if (err) {
                stream.emit("error", err);
              }
              state.prefinished = true;
              stream.emit("prefinish");
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function") {
                state.pendingcb++;
                state.finalCalled = true;
                pna.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit("prefinish");
              }
            }
          }

          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit("finish");
              }
            }
            return need;
          }

          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished) pna.nextTick(cb);
              else stream.once("finish", cb);
            }
            state.ended = true;
            stream.writable = false;
          }

          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = corkReq;
            } else {
              state.corkedRequestsFree = corkReq;
            }
          }

          Object.defineProperty(Writable.prototype, "destroyed", {
            get: function () {
              if (this._writableState === undefined) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function (value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return;
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._writableState.destroyed = value;
            },
          });

          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function (err, cb) {
            this.end();
            cb(err);
          };
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {},
          require("timers").setImmediate
        ));
      },
      {
        "./_stream_duplex": 87,
        "./internal/streams/destroy": 93,
        "./internal/streams/stream": 94,
        _process: 80,
        "core-util-is": 52,
        inherits: 63,
        "process-nextick-args": 79,
        "safe-buffer": 550,
        timers: 563,
        "util-deprecate": 644,
      },
    ],
    92: [
      function (require, module, exports) {
        "use strict";

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var Buffer = require("safe-buffer").Buffer;
        var util = require("util");

        function copyBuffer(src, target, offset) {
          src.copy(target, offset);
        }

        module.exports = (function () {
          function BufferList() {
            _classCallCheck(this, BufferList);

            this.head = null;
            this.tail = null;
            this.length = 0;
          }

          BufferList.prototype.push = function push(v) {
            var entry = { data: v, next: null };
            if (this.length > 0) this.tail.next = entry;
            else this.head = entry;
            this.tail = entry;
            ++this.length;
          };

          BufferList.prototype.unshift = function unshift(v) {
            var entry = { data: v, next: this.head };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          };

          BufferList.prototype.shift = function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;
            else this.head = this.head.next;
            --this.length;
            return ret;
          };

          BufferList.prototype.clear = function clear() {
            this.head = this.tail = null;
            this.length = 0;
          };

          BufferList.prototype.join = function join(s) {
            if (this.length === 0) return "";
            var p = this.head;
            var ret = "" + p.data;
            while ((p = p.next)) {
              ret += s + p.data;
            }
            return ret;
          };

          BufferList.prototype.concat = function concat(n) {
            if (this.length === 0) return Buffer.alloc(0);
            if (this.length === 1) return this.head.data;
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          };

          return BufferList;
        })();

        if (util && util.inspect && util.inspect.custom) {
          module.exports.prototype[util.inspect.custom] = function () {
            var obj = util.inspect({ length: this.length });
            return this.constructor.name + " " + obj;
          };
        }
      },
      { "safe-buffer": 550, util: 49 },
    ],
    93: [
      function (require, module, exports) {
        "use strict";

        /*<replacement>*/

        var pna = require("process-nextick-args");
        /*</replacement>*/

        // undocumented cb() API, needed for core, not for public API
        function destroy(err, cb) {
          var _this = this;

          var readableDestroyed =
            this._readableState && this._readableState.destroyed;
          var writableDestroyed =
            this._writableState && this._writableState.destroyed;

          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err);
            } else if (
              err &&
              (!this._writableState || !this._writableState.errorEmitted)
            ) {
              pna.nextTick(emitErrorNT, this, err);
            }
            return this;
          }

          // we set destroyed to true before firing error callbacks in order
          // to make it re-entrance safe in case destroy() is called within callbacks

          if (this._readableState) {
            this._readableState.destroyed = true;
          }

          // if this is a duplex stream mark the writable part as destroyed as well
          if (this._writableState) {
            this._writableState.destroyed = true;
          }

          this._destroy(err || null, function (err) {
            if (!cb && err) {
              pna.nextTick(emitErrorNT, _this, err);
              if (_this._writableState) {
                _this._writableState.errorEmitted = true;
              }
            } else if (cb) {
              cb(err);
            }
          });

          return this;
        }

        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
          }

          if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
          }
        }

        function emitErrorNT(self, err) {
          self.emit("error", err);
        }

        module.exports = {
          destroy: destroy,
          undestroy: undestroy,
        };
      },
      { "process-nextick-args": 79 },
    ],
    94: [
      function (require, module, exports) {
        module.exports = require("events").EventEmitter;
      },
      { events: 56 },
    ],
    95: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        /*<replacement>*/

        var Buffer = require("safe-buffer").Buffer;
        /*</replacement>*/

        var isEncoding =
          Buffer.isEncoding ||
          function (encoding) {
            encoding = "" + encoding;
            switch (encoding && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true;
              default:
                return false;
            }
          };

        function _normalizeEncoding(enc) {
          if (!enc) return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried) return; // undefined
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }

        // Do not cache `Buffer.isEncoding` when checking encoding names as some
        // modules monkey-patch it to support additional encodings
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (
            typeof nenc !== "string" &&
            (Buffer.isEncoding === isEncoding || !isEncoding(enc))
          )
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }

        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters.
        exports.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer.allocUnsafe(nb);
        }

        StringDecoder.prototype.write = function (buf) {
          if (buf.length === 0) return "";
          var r;
          var i;
          if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === undefined) return "";
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i);
          return r || "";
        };

        StringDecoder.prototype.end = utf8End;

        // Returns only complete characters in a Buffer
        StringDecoder.prototype.text = utf8Text;

        // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
        StringDecoder.prototype.fillLast = function (buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(
              this.lastChar,
              this.lastTotal - this.lastNeed,
              0,
              this.lastNeed
            );
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(
            this.lastChar,
            this.lastTotal - this.lastNeed,
            0,
            buf.length
          );
          this.lastNeed -= buf.length;
        };

        // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
        // continuation byte. If an invalid byte is detected, -2 is returned.
        function utf8CheckByte(byte) {
          if (byte <= 0x7f) return 0;
          else if (byte >> 5 === 0x06) return 2;
          else if (byte >> 4 === 0x0e) return 3;
          else if (byte >> 3 === 0x1e) return 4;
          return byte >> 6 === 0x02 ? -1 : -2;
        }

        // Checks at most 3 bytes at the end of a Buffer in order to detect an
        // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
        // needed to complete the UTF-8 character (if applicable) are returned.
        function utf8CheckIncomplete(self, buf, i) {
          var j = buf.length - 1;
          if (j < i) return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i || nb === -2) return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i || nb === -2) return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2) nb = 0;
              else self.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }

        // Validates as many continuation bytes for a multi-byte UTF-8 character as
        // needed or are available. If we see a non-continuation byte where we expect
        // one, we "replace" the validated continuation bytes we've seen so far with
        // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
        // behavior. The continuation byte check is included three times in the case
        // where all of the continuation bytes for a character exist in the same buffer.
        // It is also done this way as a slight performance increase instead of using a
        // loop.
        function utf8CheckExtraBytes(self, buf, p) {
          if ((buf[0] & 0xc0) !== 0x80) {
            self.lastNeed = 0;
            return "\ufffd";
          }
          if (self.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 0xc0) !== 0x80) {
              self.lastNeed = 1;
              return "\ufffd";
            }
            if (self.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2;
                return "\ufffd";
              }
            }
          }
        }

        // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed;
          var r = utf8CheckExtraBytes(this, buf, p);
          if (r !== undefined) return r;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p, 0, buf.length);
          this.lastNeed -= buf.length;
        }

        // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
        // partial character, the character's bytes are buffered until the required
        // number of bytes are available.
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed) return buf.toString("utf8", i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i, end);
        }

        // For UTF-8, a replacement character is added when ending on a partial
        // character.
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) return r + "\ufffd";
          return r;
        }

        // UTF-16LE typically needs two bytes per character, but even if we have an even
        // number of bytes available, we need to check if we end on a leading/high
        // surrogate. In that case, we need to wait for the next two bytes in order to
        // decode the last character properly.
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
              var c = r.charCodeAt(r.length - 1);
              if (c >= 0xd800 && c <= 0xdbff) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
              }
            }
            return r;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i, buf.length - 1);
        }

        // For UTF-16LE we do not explicitly append special replacement characters if we
        // end on a partial character, we simply let v8 handle that.
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
          }
          return r;
        }

        function base64Text(buf, i) {
          var n = (buf.length - i) % 3;
          if (n === 0) return buf.toString("base64", i);
          this.lastNeed = 3 - n;
          this.lastTotal = 3;
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i, buf.length - n);
        }

        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r;
        }

        // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }

        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      },
      { "safe-buffer": 550 },
    ],
    96: [
      function (require, module, exports) {
        module.exports = require("./readable").PassThrough;
      },
      { "./readable": 97 },
    ],
    97: [
      function (require, module, exports) {
        exports = module.exports = require("./lib/_stream_readable.js");
        exports.Stream = exports;
        exports.Readable = exports;
        exports.Writable = require("./lib/_stream_writable.js");
        exports.Duplex = require("./lib/_stream_duplex.js");
        exports.Transform = require("./lib/_stream_transform.js");
        exports.PassThrough = require("./lib/_stream_passthrough.js");
      },
      {
        "./lib/_stream_duplex.js": 87,
        "./lib/_stream_passthrough.js": 88,
        "./lib/_stream_readable.js": 89,
        "./lib/_stream_transform.js": 90,
        "./lib/_stream_writable.js": 91,
      },
    ],
    98: [
      function (require, module, exports) {
        module.exports = require("./readable").Transform;
      },
      { "./readable": 97 },
    ],
    99: [
      function (require, module, exports) {
        module.exports = require("./lib/_stream_writable.js");
      },
      { "./lib/_stream_writable.js": 91 },
    ],
    100: [
      function (require, module, exports) {
        (function (process, global) {
          /*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
          var Reflect;
          (function (Reflect) {
            // Metadata Proposal
            // https://rbuckton.github.io/reflect-metadata/
            (function (factory) {
              var root =
                typeof global === "object"
                  ? global
                  : typeof self === "object"
                  ? self
                  : typeof this === "object"
                  ? this
                  : Function("return this;")();
              var exporter = makeExporter(Reflect);
              if (typeof root.Reflect === "undefined") {
                root.Reflect = Reflect;
              } else {
                exporter = makeExporter(root.Reflect, exporter);
              }
              factory(exporter);
              function makeExporter(target, previous) {
                return function (key, value) {
                  if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, {
                      configurable: true,
                      writable: true,
                      value: value,
                    });
                  }
                  if (previous) previous(key, value);
                };
              }
            })(function (exporter) {
              var hasOwn = Object.prototype.hasOwnProperty;
              // feature test for Symbol support
              var supportsSymbol = typeof Symbol === "function";
              var toPrimitiveSymbol =
                supportsSymbol && typeof Symbol.toPrimitive !== "undefined"
                  ? Symbol.toPrimitive
                  : "@@toPrimitive";
              var iteratorSymbol =
                supportsSymbol && typeof Symbol.iterator !== "undefined"
                  ? Symbol.iterator
                  : "@@iterator";
              var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
              var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
              var downLevel = !supportsCreate && !supportsProto;
              var HashMap = {
                // create an object in dictionary mode (a.k.a. "slow" mode in v8)
                create: supportsCreate
                  ? function () {
                      return MakeDictionary(Object.create(null));
                    }
                  : supportsProto
                  ? function () {
                      return MakeDictionary({ __proto__: null });
                    }
                  : function () {
                      return MakeDictionary({});
                    },
                has: downLevel
                  ? function (map, key) {
                      return hasOwn.call(map, key);
                    }
                  : function (map, key) {
                      return key in map;
                    },
                get: downLevel
                  ? function (map, key) {
                      return hasOwn.call(map, key) ? map[key] : undefined;
                    }
                  : function (map, key) {
                      return map[key];
                    },
              };
              // Load global or shim versions of Map, Set, and WeakMap
              var functionPrototype = Object.getPrototypeOf(Function);
              var usePolyfill =
                typeof process === "object" &&
                process.env &&
                process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
              var _Map =
                !usePolyfill &&
                typeof Map === "function" &&
                typeof Map.prototype.entries === "function"
                  ? Map
                  : CreateMapPolyfill();
              var _Set =
                !usePolyfill &&
                typeof Set === "function" &&
                typeof Set.prototype.entries === "function"
                  ? Set
                  : CreateSetPolyfill();
              var _WeakMap =
                !usePolyfill && typeof WeakMap === "function"
                  ? WeakMap
                  : CreateWeakMapPolyfill();
              // [[Metadata]] internal slot
              // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
              var Metadata = new _WeakMap();
              /**
               * Applies a set of decorators to a property of a target object.
               * @param decorators An array of decorators.
               * @param target The target object.
               * @param propertyKey (Optional) The property key to decorate.
               * @param attributes (Optional) The property descriptor for the target key.
               * @remarks Decorators are applied in reverse order.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     Example = Reflect.decorate(decoratorsArray, Example);
               *
               *     // property (on constructor)
               *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
               *
               *     // property (on prototype)
               *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
               *
               *     // method (on constructor)
               *     Object.defineProperty(Example, "staticMethod",
               *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
               *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
               *
               *     // method (on prototype)
               *     Object.defineProperty(Example.prototype, "method",
               *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
               *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
               *
               */
              function decorate(decorators, target, propertyKey, attributes) {
                if (!IsUndefined(propertyKey)) {
                  if (!IsArray(decorators)) throw new TypeError();
                  if (!IsObject(target)) throw new TypeError();
                  if (
                    !IsObject(attributes) &&
                    !IsUndefined(attributes) &&
                    !IsNull(attributes)
                  )
                    throw new TypeError();
                  if (IsNull(attributes)) attributes = undefined;
                  propertyKey = ToPropertyKey(propertyKey);
                  return DecorateProperty(
                    decorators,
                    target,
                    propertyKey,
                    attributes
                  );
                } else {
                  if (!IsArray(decorators)) throw new TypeError();
                  if (!IsConstructor(target)) throw new TypeError();
                  return DecorateConstructor(decorators, target);
                }
              }
              exporter("decorate", decorate);
              // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
              // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
              /**
               * A default metadata decorator factory that can be used on a class, class member, or parameter.
               * @param metadataKey The key for the metadata entry.
               * @param metadataValue The value for the metadata entry.
               * @returns A decorator function.
               * @remarks
               * If `metadataKey` is already defined for the target and target key, the
               * metadataValue for that key will be overwritten.
               * @example
               *
               *     // constructor
               *     @Reflect.metadata(key, value)
               *     class Example {
               *     }
               *
               *     // property (on constructor, TypeScript only)
               *     class Example {
               *         @Reflect.metadata(key, value)
               *         static staticProperty;
               *     }
               *
               *     // property (on prototype, TypeScript only)
               *     class Example {
               *         @Reflect.metadata(key, value)
               *         property;
               *     }
               *
               *     // method (on constructor)
               *     class Example {
               *         @Reflect.metadata(key, value)
               *         static staticMethod() { }
               *     }
               *
               *     // method (on prototype)
               *     class Example {
               *         @Reflect.metadata(key, value)
               *         method() { }
               *     }
               *
               */
              function metadata(metadataKey, metadataValue) {
                function decorator(target, propertyKey) {
                  if (!IsObject(target)) throw new TypeError();
                  if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                  OrdinaryDefineOwnMetadata(
                    metadataKey,
                    metadataValue,
                    target,
                    propertyKey
                  );
                }
                return decorator;
              }
              exporter("metadata", metadata);
              /**
               * Define a unique metadata entry on the target.
               * @param metadataKey A key used to store and retrieve metadata.
               * @param metadataValue A value that contains attached metadata.
               * @param target The target object on which to define metadata.
               * @param propertyKey (Optional) The property key for the target.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     Reflect.defineMetadata("custom:annotation", options, Example);
               *
               *     // property (on constructor)
               *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
               *
               *     // property (on prototype)
               *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
               *
               *     // method (on constructor)
               *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
               *
               *     // method (on prototype)
               *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
               *
               *     // decorator factory as metadata-producing annotation.
               *     function MyAnnotation(options): Decorator {
               *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
               *     }
               *
               */
              function defineMetadata(
                metadataKey,
                metadataValue,
                target,
                propertyKey
              ) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryDefineOwnMetadata(
                  metadataKey,
                  metadataValue,
                  target,
                  propertyKey
                );
              }
              exporter("defineMetadata", defineMetadata);
              /**
               * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
               * @param metadataKey A key used to store and retrieve metadata.
               * @param target The target object on which the metadata is defined.
               * @param propertyKey (Optional) The property key for the target.
               * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     result = Reflect.hasMetadata("custom:annotation", Example);
               *
               *     // property (on constructor)
               *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
               *
               *     // property (on prototype)
               *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
               *
               *     // method (on constructor)
               *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
               *
               *     // method (on prototype)
               *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
               *
               */
              function hasMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryHasMetadata(metadataKey, target, propertyKey);
              }
              exporter("hasMetadata", hasMetadata);
              /**
               * Gets a value indicating whether the target object has the provided metadata key defined.
               * @param metadataKey A key used to store and retrieve metadata.
               * @param target The target object on which the metadata is defined.
               * @param propertyKey (Optional) The property key for the target.
               * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
               *
               *     // property (on constructor)
               *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
               *
               *     // property (on prototype)
               *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
               *
               *     // method (on constructor)
               *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
               *
               *     // method (on prototype)
               *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
               *
               */
              function hasOwnMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
              }
              exporter("hasOwnMetadata", hasOwnMetadata);
              /**
               * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
               * @param metadataKey A key used to store and retrieve metadata.
               * @param target The target object on which the metadata is defined.
               * @param propertyKey (Optional) The property key for the target.
               * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     result = Reflect.getMetadata("custom:annotation", Example);
               *
               *     // property (on constructor)
               *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
               *
               *     // property (on prototype)
               *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
               *
               *     // method (on constructor)
               *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
               *
               *     // method (on prototype)
               *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
               *
               */
              function getMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryGetMetadata(metadataKey, target, propertyKey);
              }
              exporter("getMetadata", getMetadata);
              /**
               * Gets the metadata value for the provided metadata key on the target object.
               * @param metadataKey A key used to store and retrieve metadata.
               * @param target The target object on which the metadata is defined.
               * @param propertyKey (Optional) The property key for the target.
               * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     result = Reflect.getOwnMetadata("custom:annotation", Example);
               *
               *     // property (on constructor)
               *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
               *
               *     // property (on prototype)
               *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
               *
               *     // method (on constructor)
               *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
               *
               *     // method (on prototype)
               *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
               *
               */
              function getOwnMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
              }
              exporter("getOwnMetadata", getOwnMetadata);
              /**
               * Gets the metadata keys defined on the target object or its prototype chain.
               * @param target The target object on which the metadata is defined.
               * @param propertyKey (Optional) The property key for the target.
               * @returns An array of unique metadata keys.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     result = Reflect.getMetadataKeys(Example);
               *
               *     // property (on constructor)
               *     result = Reflect.getMetadataKeys(Example, "staticProperty");
               *
               *     // property (on prototype)
               *     result = Reflect.getMetadataKeys(Example.prototype, "property");
               *
               *     // method (on constructor)
               *     result = Reflect.getMetadataKeys(Example, "staticMethod");
               *
               *     // method (on prototype)
               *     result = Reflect.getMetadataKeys(Example.prototype, "method");
               *
               */
              function getMetadataKeys(target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryMetadataKeys(target, propertyKey);
              }
              exporter("getMetadataKeys", getMetadataKeys);
              /**
               * Gets the unique metadata keys defined on the target object.
               * @param target The target object on which the metadata is defined.
               * @param propertyKey (Optional) The property key for the target.
               * @returns An array of unique metadata keys.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     result = Reflect.getOwnMetadataKeys(Example);
               *
               *     // property (on constructor)
               *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
               *
               *     // property (on prototype)
               *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
               *
               *     // method (on constructor)
               *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
               *
               *     // method (on prototype)
               *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
               *
               */
              function getOwnMetadataKeys(target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryOwnMetadataKeys(target, propertyKey);
              }
              exporter("getOwnMetadataKeys", getOwnMetadataKeys);
              /**
               * Deletes the metadata entry from the target object with the provided key.
               * @param metadataKey A key used to store and retrieve metadata.
               * @param target The target object on which the metadata is defined.
               * @param propertyKey (Optional) The property key for the target.
               * @returns `true` if the metadata entry was found and deleted; otherwise, false.
               * @example
               *
               *     class Example {
               *         // property declarations are not part of ES6, though they are valid in TypeScript:
               *         // static staticProperty;
               *         // property;
               *
               *         constructor(p) { }
               *         static staticMethod(p) { }
               *         method(p) { }
               *     }
               *
               *     // constructor
               *     result = Reflect.deleteMetadata("custom:annotation", Example);
               *
               *     // property (on constructor)
               *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
               *
               *     // property (on prototype)
               *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
               *
               *     // method (on constructor)
               *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
               *
               *     // method (on prototype)
               *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
               *
               */
              function deleteMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
                var metadataMap = GetOrCreateMetadataMap(
                  target,
                  propertyKey,
                  /*Create*/ false
                );
                if (IsUndefined(metadataMap)) return false;
                if (!metadataMap.delete(metadataKey)) return false;
                if (metadataMap.size > 0) return true;
                var targetMetadata = Metadata.get(target);
                targetMetadata.delete(propertyKey);
                if (targetMetadata.size > 0) return true;
                Metadata.delete(target);
                return true;
              }
              exporter("deleteMetadata", deleteMetadata);
              function DecorateConstructor(decorators, target) {
                for (var i = decorators.length - 1; i >= 0; --i) {
                  var decorator = decorators[i];
                  var decorated = decorator(target);
                  if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated)) throw new TypeError();
                    target = decorated;
                  }
                }
                return target;
              }
              function DecorateProperty(
                decorators,
                target,
                propertyKey,
                descriptor
              ) {
                for (var i = decorators.length - 1; i >= 0; --i) {
                  var decorator = decorators[i];
                  var decorated = decorator(target, propertyKey, descriptor);
                  if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated)) throw new TypeError();
                    descriptor = decorated;
                  }
                }
                return descriptor;
              }
              function GetOrCreateMetadataMap(O, P, Create) {
                var targetMetadata = Metadata.get(O);
                if (IsUndefined(targetMetadata)) {
                  if (!Create) return undefined;
                  targetMetadata = new _Map();
                  Metadata.set(O, targetMetadata);
                }
                var metadataMap = targetMetadata.get(P);
                if (IsUndefined(metadataMap)) {
                  if (!Create) return undefined;
                  metadataMap = new _Map();
                  targetMetadata.set(P, metadataMap);
                }
                return metadataMap;
              }
              // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
              // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
              function OrdinaryHasMetadata(MetadataKey, O, P) {
                var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
                if (hasOwn) return true;
                var parent = OrdinaryGetPrototypeOf(O);
                if (!IsNull(parent))
                  return OrdinaryHasMetadata(MetadataKey, parent, P);
                return false;
              }
              // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
              // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
              function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(
                  O,
                  P,
                  /*Create*/ false
                );
                if (IsUndefined(metadataMap)) return false;
                return ToBoolean(metadataMap.has(MetadataKey));
              }
              // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
              // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
              function OrdinaryGetMetadata(MetadataKey, O, P) {
                var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
                if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
                var parent = OrdinaryGetPrototypeOf(O);
                if (!IsNull(parent))
                  return OrdinaryGetMetadata(MetadataKey, parent, P);
                return undefined;
              }
              // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
              // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
              function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(
                  O,
                  P,
                  /*Create*/ false
                );
                if (IsUndefined(metadataMap)) return undefined;
                return metadataMap.get(MetadataKey);
              }
              // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
              // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
              function OrdinaryDefineOwnMetadata(
                MetadataKey,
                MetadataValue,
                O,
                P
              ) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
                metadataMap.set(MetadataKey, MetadataValue);
              }
              // 3.1.6.1 OrdinaryMetadataKeys(O, P)
              // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
              function OrdinaryMetadataKeys(O, P) {
                var ownKeys = OrdinaryOwnMetadataKeys(O, P);
                var parent = OrdinaryGetPrototypeOf(O);
                if (parent === null) return ownKeys;
                var parentKeys = OrdinaryMetadataKeys(parent, P);
                if (parentKeys.length <= 0) return ownKeys;
                if (ownKeys.length <= 0) return parentKeys;
                var set = new _Set();
                var keys = [];
                for (
                  var _i = 0, ownKeys_1 = ownKeys;
                  _i < ownKeys_1.length;
                  _i++
                ) {
                  var key = ownKeys_1[_i];
                  var hasKey = set.has(key);
                  if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                  }
                }
                for (
                  var _a = 0, parentKeys_1 = parentKeys;
                  _a < parentKeys_1.length;
                  _a++
                ) {
                  var key = parentKeys_1[_a];
                  var hasKey = set.has(key);
                  if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                  }
                }
                return keys;
              }
              // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
              // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
              function OrdinaryOwnMetadataKeys(O, P) {
                var keys = [];
                var metadataMap = GetOrCreateMetadataMap(
                  O,
                  P,
                  /*Create*/ false
                );
                if (IsUndefined(metadataMap)) return keys;
                var keysObj = metadataMap.keys();
                var iterator = GetIterator(keysObj);
                var k = 0;
                while (true) {
                  var next = IteratorStep(iterator);
                  if (!next) {
                    keys.length = k;
                    return keys;
                  }
                  var nextValue = IteratorValue(next);
                  try {
                    keys[k] = nextValue;
                  } catch (e) {
                    try {
                      IteratorClose(iterator);
                    } finally {
                      throw e;
                    }
                  }
                  k++;
                }
              }
              // 6 ECMAScript Data Typ0es and Values
              // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
              function Type(x) {
                if (x === null) return 1 /* Null */;
                switch (typeof x) {
                  case "undefined":
                    return 0 /* Undefined */;
                  case "boolean":
                    return 2 /* Boolean */;
                  case "string":
                    return 3 /* String */;
                  case "symbol":
                    return 4 /* Symbol */;
                  case "number":
                    return 5 /* Number */;
                  case "object":
                    return x === null ? 1 /* Null */ : 6 /* Object */;
                  default:
                    return 6 /* Object */;
                }
              }
              // 6.1.1 The Undefined Type
              // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
              function IsUndefined(x) {
                return x === undefined;
              }
              // 6.1.2 The Null Type
              // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
              function IsNull(x) {
                return x === null;
              }
              // 6.1.5 The Symbol Type
              // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
              function IsSymbol(x) {
                return typeof x === "symbol";
              }
              // 6.1.7 The Object Type
              // https://tc39.github.io/ecma262/#sec-object-type
              function IsObject(x) {
                return typeof x === "object"
                  ? x !== null
                  : typeof x === "function";
              }
              // 7.1 Type Conversion
              // https://tc39.github.io/ecma262/#sec-type-conversion
              // 7.1.1 ToPrimitive(input [, PreferredType])
              // https://tc39.github.io/ecma262/#sec-toprimitive
              function ToPrimitive(input, PreferredType) {
                switch (Type(input)) {
                  case 0 /* Undefined */:
                    return input;
                  case 1 /* Null */:
                    return input;
                  case 2 /* Boolean */:
                    return input;
                  case 3 /* String */:
                    return input;
                  case 4 /* Symbol */:
                    return input;
                  case 5 /* Number */:
                    return input;
                }
                var hint =
                  PreferredType === 3 /* String */
                    ? "string"
                    : PreferredType === 5 /* Number */
                    ? "number"
                    : "default";
                var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
                if (exoticToPrim !== undefined) {
                  var result = exoticToPrim.call(input, hint);
                  if (IsObject(result)) throw new TypeError();
                  return result;
                }
                return OrdinaryToPrimitive(
                  input,
                  hint === "default" ? "number" : hint
                );
              }
              // 7.1.1.1 OrdinaryToPrimitive(O, hint)
              // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
              function OrdinaryToPrimitive(O, hint) {
                if (hint === "string") {
                  var toString_1 = O.toString;
                  if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result)) return result;
                  }
                  var valueOf = O.valueOf;
                  if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result)) return result;
                  }
                } else {
                  var valueOf = O.valueOf;
                  if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result)) return result;
                  }
                  var toString_2 = O.toString;
                  if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result)) return result;
                  }
                }
                throw new TypeError();
              }
              // 7.1.2 ToBoolean(argument)
              // https://tc39.github.io/ecma262/2016/#sec-toboolean
              function ToBoolean(argument) {
                return !!argument;
              }
              // 7.1.12 ToString(argument)
              // https://tc39.github.io/ecma262/#sec-tostring
              function ToString(argument) {
                return "" + argument;
              }
              // 7.1.14 ToPropertyKey(argument)
              // https://tc39.github.io/ecma262/#sec-topropertykey
              function ToPropertyKey(argument) {
                var key = ToPrimitive(argument, 3 /* String */);
                if (IsSymbol(key)) return key;
                return ToString(key);
              }
              // 7.2 Testing and Comparison Operations
              // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
              // 7.2.2 IsArray(argument)
              // https://tc39.github.io/ecma262/#sec-isarray
              function IsArray(argument) {
                return Array.isArray
                  ? Array.isArray(argument)
                  : argument instanceof Object
                  ? argument instanceof Array
                  : Object.prototype.toString.call(argument) ===
                    "[object Array]";
              }
              // 7.2.3 IsCallable(argument)
              // https://tc39.github.io/ecma262/#sec-iscallable
              function IsCallable(argument) {
                // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
                return typeof argument === "function";
              }
              // 7.2.4 IsConstructor(argument)
              // https://tc39.github.io/ecma262/#sec-isconstructor
              function IsConstructor(argument) {
                // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
                return typeof argument === "function";
              }
              // 7.2.7 IsPropertyKey(argument)
              // https://tc39.github.io/ecma262/#sec-ispropertykey
              function IsPropertyKey(argument) {
                switch (Type(argument)) {
                  case 3 /* String */:
                    return true;
                  case 4 /* Symbol */:
                    return true;
                  default:
                    return false;
                }
              }
              // 7.3 Operations on Objects
              // https://tc39.github.io/ecma262/#sec-operations-on-objects
              // 7.3.9 GetMethod(V, P)
              // https://tc39.github.io/ecma262/#sec-getmethod
              function GetMethod(V, P) {
                var func = V[P];
                if (func === undefined || func === null) return undefined;
                if (!IsCallable(func)) throw new TypeError();
                return func;
              }
              // 7.4 Operations on Iterator Objects
              // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
              function GetIterator(obj) {
                var method = GetMethod(obj, iteratorSymbol);
                if (!IsCallable(method)) throw new TypeError(); // from Call
                var iterator = method.call(obj);
                if (!IsObject(iterator)) throw new TypeError();
                return iterator;
              }
              // 7.4.4 IteratorValue(iterResult)
              // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
              function IteratorValue(iterResult) {
                return iterResult.value;
              }
              // 7.4.5 IteratorStep(iterator)
              // https://tc39.github.io/ecma262/#sec-iteratorstep
              function IteratorStep(iterator) {
                var result = iterator.next();
                return result.done ? false : result;
              }
              // 7.4.6 IteratorClose(iterator, completion)
              // https://tc39.github.io/ecma262/#sec-iteratorclose
              function IteratorClose(iterator) {
                var f = iterator["return"];
                if (f) f.call(iterator);
              }
              // 9.1 Ordinary Object Internal Methods and Internal Slots
              // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
              // 9.1.1.1 OrdinaryGetPrototypeOf(O)
              // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
              function OrdinaryGetPrototypeOf(O) {
                var proto = Object.getPrototypeOf(O);
                if (typeof O !== "function" || O === functionPrototype)
                  return proto;
                // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
                // Try to determine the superclass constructor. Compatible implementations
                // must either set __proto__ on a subclass constructor to the superclass constructor,
                // or ensure each class has a valid `constructor` property on its prototype that
                // points back to the constructor.
                // If this is not the same as Function.[[Prototype]], then this is definately inherited.
                // This is the case when in ES6 or when using __proto__ in a compatible browser.
                if (proto !== functionPrototype) return proto;
                // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
                var prototype = O.prototype;
                var prototypeProto =
                  prototype && Object.getPrototypeOf(prototype);
                if (
                  prototypeProto == null ||
                  prototypeProto === Object.prototype
                )
                  return proto;
                // If the constructor was not a function, then we cannot determine the heritage.
                var constructor = prototypeProto.constructor;
                if (typeof constructor !== "function") return proto;
                // If we have some kind of self-reference, then we cannot determine the heritage.
                if (constructor === O) return proto;
                // we have a pretty good guess at the heritage.
                return constructor;
              }
              // naive Map shim
              function CreateMapPolyfill() {
                var cacheSentinel = {};
                var arraySentinel = [];
                var MapIterator = /** @class */ (function () {
                  function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                  }
                  MapIterator.prototype["@@iterator"] = function () {
                    return this;
                  };
                  MapIterator.prototype[iteratorSymbol] = function () {
                    return this;
                  };
                  MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                      var result = this._selector(
                        this._keys[index],
                        this._values[index]
                      );
                      if (index + 1 >= this._keys.length) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                      } else {
                        this._index++;
                      }
                      return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                  };
                  MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                      this._index = -1;
                      this._keys = arraySentinel;
                      this._values = arraySentinel;
                    }
                    throw error;
                  };
                  MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                      this._index = -1;
                      this._keys = arraySentinel;
                      this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                  };
                  return MapIterator;
                })();
                return /** @class */ (function () {
                  function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  Object.defineProperty(Map.prototype, "size", {
                    get: function () {
                      return this._keys.length;
                    },
                    enumerable: true,
                    configurable: true,
                  });
                  Map.prototype.has = function (key) {
                    return this._find(key, /*insert*/ false) >= 0;
                  };
                  Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                  };
                  Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                  };
                  Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                      var size = this._keys.length;
                      for (var i = index + 1; i < size; i++) {
                        this._keys[i - 1] = this._keys[i];
                        this._values[i - 1] = this._values[i];
                      }
                      this._keys.length--;
                      this._values.length--;
                      if (key === this._cacheKey) {
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                      }
                      return true;
                    }
                    return false;
                  };
                  Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  };
                  Map.prototype.keys = function () {
                    return new MapIterator(this._keys, this._values, getKey);
                  };
                  Map.prototype.values = function () {
                    return new MapIterator(this._keys, this._values, getValue);
                  };
                  Map.prototype.entries = function () {
                    return new MapIterator(this._keys, this._values, getEntry);
                  };
                  Map.prototype["@@iterator"] = function () {
                    return this.entries();
                  };
                  Map.prototype[iteratorSymbol] = function () {
                    return this.entries();
                  };
                  Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                      this._cacheIndex = this._keys.indexOf(
                        (this._cacheKey = key)
                      );
                    }
                    if (this._cacheIndex < 0 && insert) {
                      this._cacheIndex = this._keys.length;
                      this._keys.push(key);
                      this._values.push(undefined);
                    }
                    return this._cacheIndex;
                  };
                  return Map;
                })();
                function getKey(key, _) {
                  return key;
                }
                function getValue(_, value) {
                  return value;
                }
                function getEntry(key, value) {
                  return [key, value];
                }
              }
              // naive Set shim
              function CreateSetPolyfill() {
                return /** @class */ (function () {
                  function Set() {
                    this._map = new _Map();
                  }
                  Object.defineProperty(Set.prototype, "size", {
                    get: function () {
                      return this._map.size;
                    },
                    enumerable: true,
                    configurable: true,
                  });
                  Set.prototype.has = function (value) {
                    return this._map.has(value);
                  };
                  Set.prototype.add = function (value) {
                    return this._map.set(value, value), this;
                  };
                  Set.prototype.delete = function (value) {
                    return this._map.delete(value);
                  };
                  Set.prototype.clear = function () {
                    this._map.clear();
                  };
                  Set.prototype.keys = function () {
                    return this._map.keys();
                  };
                  Set.prototype.values = function () {
                    return this._map.values();
                  };
                  Set.prototype.entries = function () {
                    return this._map.entries();
                  };
                  Set.prototype["@@iterator"] = function () {
                    return this.keys();
                  };
                  Set.prototype[iteratorSymbol] = function () {
                    return this.keys();
                  };
                  return Set;
                })();
              }
              // naive WeakMap shim
              function CreateWeakMapPolyfill() {
                var UUID_SIZE = 16;
                var keys = HashMap.create();
                var rootKey = CreateUniqueKey();
                return /** @class */ (function () {
                  function WeakMap() {
                    this._key = CreateUniqueKey();
                  }
                  WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(
                      target,
                      /*create*/ false
                    );
                    return table !== undefined
                      ? HashMap.has(table, this._key)
                      : false;
                  };
                  WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(
                      target,
                      /*create*/ false
                    );
                    return table !== undefined
                      ? HashMap.get(table, this._key)
                      : undefined;
                  };
                  WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(
                      target,
                      /*create*/ true
                    );
                    table[this._key] = value;
                    return this;
                  };
                  WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(
                      target,
                      /*create*/ false
                    );
                    return table !== undefined
                      ? delete table[this._key]
                      : false;
                  };
                  WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                  };
                  return WeakMap;
                })();
                function CreateUniqueKey() {
                  var key;
                  do key = "@@WeakMap@@" + CreateUUID();
                  while (HashMap.has(keys, key));
                  keys[key] = true;
                  return key;
                }
                function GetOrCreateWeakMapTable(target, create) {
                  if (!hasOwn.call(target, rootKey)) {
                    if (!create) return undefined;
                    Object.defineProperty(target, rootKey, {
                      value: HashMap.create(),
                    });
                  }
                  return target[rootKey];
                }
                function FillRandomBytes(buffer, size) {
                  for (var i = 0; i < size; ++i)
                    buffer[i] = (Math.random() * 0xff) | 0;
                  return buffer;
                }
                function GenRandomBytes(size) {
                  if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                      return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                      return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                  }
                  return FillRandomBytes(new Array(size), size);
                }
                function CreateUUID() {
                  var data = GenRandomBytes(UUID_SIZE);
                  // mark as random - RFC 4122  4.4
                  data[6] = (data[6] & 0x4f) | 0x40;
                  data[8] = (data[8] & 0xbf) | 0x80;
                  var result = "";
                  for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                      result += "-";
                    if (byte < 16) result += "0";
                    result += byte.toString(16).toLowerCase();
                  }
                  return result;
                }
              }
              // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
              function MakeDictionary(obj) {
                obj.__ = undefined;
                delete obj.__;
                return obj;
              }
            });
          })(Reflect || (Reflect = {}));
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      { _process: 80 },
    ],
    101: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /* tslint:disable:no-unused-variable */
        // Subject imported before Observable to bypass circular dependency issue since
        // Subject extends Observable and Observable references Subject in it's
        // definition
        var rxjs_1 = require("rxjs");
        exports.Observable = rxjs_1.Observable;
        exports.Subject = rxjs_1.Subject;
        var internal_compatibility_1 = require("rxjs/internal-compatibility");
        exports.AnonymousSubject = internal_compatibility_1.AnonymousSubject;
        /* tslint:enable:no-unused-variable */
        var internal_compatibility_2 = require("rxjs/internal-compatibility");
        exports.config = internal_compatibility_2.config;
        // statics
        /* tslint:disable:no-use-before-declare */
        require("./add/observable/bindCallback");
        require("./add/observable/bindNodeCallback");
        require("./add/observable/combineLatest");
        require("./add/observable/concat");
        require("./add/observable/defer");
        require("./add/observable/empty");
        require("./add/observable/forkJoin");
        require("./add/observable/from");
        require("./add/observable/fromEvent");
        require("./add/observable/fromEventPattern");
        require("./add/observable/fromPromise");
        require("./add/observable/generate");
        require("./add/observable/if");
        require("./add/observable/interval");
        require("./add/observable/merge");
        require("./add/observable/race");
        require("./add/observable/never");
        require("./add/observable/of");
        require("./add/observable/onErrorResumeNext");
        require("./add/observable/pairs");
        require("./add/observable/range");
        require("./add/observable/using");
        require("./add/observable/throw");
        require("./add/observable/timer");
        require("./add/observable/zip");
        //dom
        require("./add/observable/dom/ajax");
        require("./add/observable/dom/webSocket");
        //internal/operators
        require("./add/operator/buffer");
        require("./add/operator/bufferCount");
        require("./add/operator/bufferTime");
        require("./add/operator/bufferToggle");
        require("./add/operator/bufferWhen");
        require("./add/operator/catch");
        require("./add/operator/combineAll");
        require("./add/operator/combineLatest");
        require("./add/operator/concat");
        require("./add/operator/concatAll");
        require("./add/operator/concatMap");
        require("./add/operator/concatMapTo");
        require("./add/operator/count");
        require("./add/operator/dematerialize");
        require("./add/operator/debounce");
        require("./add/operator/debounceTime");
        require("./add/operator/defaultIfEmpty");
        require("./add/operator/delay");
        require("./add/operator/delayWhen");
        require("./add/operator/distinct");
        require("./add/operator/distinctUntilChanged");
        require("./add/operator/distinctUntilKeyChanged");
        require("./add/operator/do");
        require("./add/operator/exhaust");
        require("./add/operator/exhaustMap");
        require("./add/operator/expand");
        require("./add/operator/elementAt");
        require("./add/operator/filter");
        require("./add/operator/finally");
        require("./add/operator/find");
        require("./add/operator/findIndex");
        require("./add/operator/first");
        require("./add/operator/groupBy");
        require("./add/operator/ignoreElements");
        require("./add/operator/isEmpty");
        require("./add/operator/audit");
        require("./add/operator/auditTime");
        require("./add/operator/last");
        require("./add/operator/let");
        require("./add/operator/every");
        require("./add/operator/map");
        require("./add/operator/mapTo");
        require("./add/operator/materialize");
        require("./add/operator/max");
        require("./add/operator/merge");
        require("./add/operator/mergeAll");
        require("./add/operator/mergeMap");
        require("./add/operator/mergeMapTo");
        require("./add/operator/mergeScan");
        require("./add/operator/min");
        require("./add/operator/multicast");
        require("./add/operator/observeOn");
        require("./add/operator/onErrorResumeNext");
        require("./add/operator/pairwise");
        require("./add/operator/partition");
        require("./add/operator/pluck");
        require("./add/operator/publish");
        require("./add/operator/publishBehavior");
        require("./add/operator/publishReplay");
        require("./add/operator/publishLast");
        require("./add/operator/race");
        require("./add/operator/reduce");
        require("./add/operator/repeat");
        require("./add/operator/repeatWhen");
        require("./add/operator/retry");
        require("./add/operator/retryWhen");
        require("./add/operator/sample");
        require("./add/operator/sampleTime");
        require("./add/operator/scan");
        require("./add/operator/sequenceEqual");
        require("./add/operator/share");
        require("./add/operator/shareReplay");
        require("./add/operator/single");
        require("./add/operator/skip");
        require("./add/operator/skipLast");
        require("./add/operator/skipUntil");
        require("./add/operator/skipWhile");
        require("./add/operator/startWith");
        require("./add/operator/subscribeOn");
        require("./add/operator/switch");
        require("./add/operator/switchMap");
        require("./add/operator/switchMapTo");
        require("./add/operator/take");
        require("./add/operator/takeLast");
        require("./add/operator/takeUntil");
        require("./add/operator/takeWhile");
        require("./add/operator/throttle");
        require("./add/operator/throttleTime");
        require("./add/operator/timeInterval");
        require("./add/operator/timeout");
        require("./add/operator/timeoutWith");
        require("./add/operator/timestamp");
        require("./add/operator/toArray");
        require("./add/operator/toPromise");
        require("./add/operator/window");
        require("./add/operator/windowCount");
        require("./add/operator/windowTime");
        require("./add/operator/windowToggle");
        require("./add/operator/windowWhen");
        require("./add/operator/withLatestFrom");
        require("./add/operator/zip");
        require("./add/operator/zipAll");
        /* tslint:disable:no-unused-variable */
        var rxjs_2 = require("rxjs");
        exports.Subscription = rxjs_2.Subscription;
        exports.ReplaySubject = rxjs_2.ReplaySubject;
        exports.BehaviorSubject = rxjs_2.BehaviorSubject;
        exports.Notification = rxjs_2.Notification;
        exports.EmptyError = rxjs_2.EmptyError;
        exports.ArgumentOutOfRangeError = rxjs_2.ArgumentOutOfRangeError;
        exports.ObjectUnsubscribedError = rxjs_2.ObjectUnsubscribedError;
        exports.UnsubscriptionError = rxjs_2.UnsubscriptionError;
        exports.pipe = rxjs_2.pipe;
        var testing_1 = require("rxjs/testing");
        exports.TestScheduler = testing_1.TestScheduler;
        var rxjs_3 = require("rxjs");
        exports.Subscriber = rxjs_3.Subscriber;
        exports.AsyncSubject = rxjs_3.AsyncSubject;
        exports.ConnectableObservable = rxjs_3.ConnectableObservable;
        exports.TimeoutError = rxjs_3.TimeoutError;
        exports.VirtualTimeScheduler = rxjs_3.VirtualTimeScheduler;
        var ajax_1 = require("rxjs/ajax");
        exports.AjaxResponse = ajax_1.AjaxResponse;
        exports.AjaxError = ajax_1.AjaxError;
        exports.AjaxTimeoutError = ajax_1.AjaxTimeoutError;
        var rxjs_4 = require("rxjs");
        var internal_compatibility_3 = require("rxjs/internal-compatibility");
        var internal_compatibility_4 = require("rxjs/internal-compatibility");
        exports.TimeInterval = internal_compatibility_4.TimeInterval;
        exports.Timestamp = internal_compatibility_4.Timestamp;
        var _operators = require("rxjs/operators");
        exports.operators = _operators;
        /* tslint:enable:no-unused-variable */
        /**
         * @typedef {Object} Rx.Scheduler
         * @property {Scheduler} queue Schedules on a queue in the current event frame
         * (trampoline scheduler). Use this for iteration operations.
         * @property {Scheduler} asap Schedules on the micro task queue, which is the same
         * queue used for promises. Basically after the current job, but before the next
         * job. Use this for asynchronous conversions.
         * @property {Scheduler} async Schedules work with `setInterval`. Use this for
         * time-based operations.
         * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.
         * Use this for synchronizing with the platform's painting
         */
        var Scheduler = {
          asap: rxjs_4.asapScheduler,
          queue: rxjs_4.queueScheduler,
          animationFrame: rxjs_4.animationFrameScheduler,
          async: rxjs_4.asyncScheduler,
        };
        exports.Scheduler = Scheduler;
        /**
         * @typedef {Object} Rx.Symbol
         * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
         * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
         * an object that has all of the traits of an Rx Subscriber, including the
         * ability to add and remove subscriptions to the subscription chain and
         * guarantees involving event triggering (can't "next" after unsubscription,
         * etc).
         * @property {Symbol|string} observable A symbol to use as a property name to
         * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
         * @property {Symbol|string} iterator The ES6 symbol to use as a property name
         * to retrieve an iterator from an object.
         */
        var Symbol = {
          rxSubscriber: internal_compatibility_3.rxSubscriber,
          observable: internal_compatibility_3.observable,
          iterator: internal_compatibility_3.iterator,
        };
        exports.Symbol = Symbol;
      },
      {
        "./add/observable/bindCallback": 102,
        "./add/observable/bindNodeCallback": 103,
        "./add/observable/combineLatest": 104,
        "./add/observable/concat": 105,
        "./add/observable/defer": 106,
        "./add/observable/dom/ajax": 107,
        "./add/observable/dom/webSocket": 108,
        "./add/observable/empty": 109,
        "./add/observable/forkJoin": 110,
        "./add/observable/from": 111,
        "./add/observable/fromEvent": 112,
        "./add/observable/fromEventPattern": 113,
        "./add/observable/fromPromise": 114,
        "./add/observable/generate": 115,
        "./add/observable/if": 116,
        "./add/observable/interval": 117,
        "./add/observable/merge": 118,
        "./add/observable/never": 119,
        "./add/observable/of": 120,
        "./add/observable/onErrorResumeNext": 121,
        "./add/observable/pairs": 122,
        "./add/observable/race": 123,
        "./add/observable/range": 124,
        "./add/observable/throw": 125,
        "./add/observable/timer": 126,
        "./add/observable/using": 127,
        "./add/observable/zip": 128,
        "./add/operator/audit": 129,
        "./add/operator/auditTime": 130,
        "./add/operator/buffer": 131,
        "./add/operator/bufferCount": 132,
        "./add/operator/bufferTime": 133,
        "./add/operator/bufferToggle": 134,
        "./add/operator/bufferWhen": 135,
        "./add/operator/catch": 136,
        "./add/operator/combineAll": 137,
        "./add/operator/combineLatest": 138,
        "./add/operator/concat": 139,
        "./add/operator/concatAll": 140,
        "./add/operator/concatMap": 141,
        "./add/operator/concatMapTo": 142,
        "./add/operator/count": 143,
        "./add/operator/debounce": 144,
        "./add/operator/debounceTime": 145,
        "./add/operator/defaultIfEmpty": 146,
        "./add/operator/delay": 147,
        "./add/operator/delayWhen": 148,
        "./add/operator/dematerialize": 149,
        "./add/operator/distinct": 150,
        "./add/operator/distinctUntilChanged": 151,
        "./add/operator/distinctUntilKeyChanged": 152,
        "./add/operator/do": 153,
        "./add/operator/elementAt": 154,
        "./add/operator/every": 155,
        "./add/operator/exhaust": 156,
        "./add/operator/exhaustMap": 157,
        "./add/operator/expand": 158,
        "./add/operator/filter": 159,
        "./add/operator/finally": 160,
        "./add/operator/find": 161,
        "./add/operator/findIndex": 162,
        "./add/operator/first": 163,
        "./add/operator/groupBy": 164,
        "./add/operator/ignoreElements": 165,
        "./add/operator/isEmpty": 166,
        "./add/operator/last": 167,
        "./add/operator/let": 168,
        "./add/operator/map": 169,
        "./add/operator/mapTo": 170,
        "./add/operator/materialize": 171,
        "./add/operator/max": 172,
        "./add/operator/merge": 173,
        "./add/operator/mergeAll": 174,
        "./add/operator/mergeMap": 175,
        "./add/operator/mergeMapTo": 176,
        "./add/operator/mergeScan": 177,
        "./add/operator/min": 178,
        "./add/operator/multicast": 179,
        "./add/operator/observeOn": 180,
        "./add/operator/onErrorResumeNext": 181,
        "./add/operator/pairwise": 182,
        "./add/operator/partition": 183,
        "./add/operator/pluck": 184,
        "./add/operator/publish": 185,
        "./add/operator/publishBehavior": 186,
        "./add/operator/publishLast": 187,
        "./add/operator/publishReplay": 188,
        "./add/operator/race": 189,
        "./add/operator/reduce": 190,
        "./add/operator/repeat": 191,
        "./add/operator/repeatWhen": 192,
        "./add/operator/retry": 193,
        "./add/operator/retryWhen": 194,
        "./add/operator/sample": 195,
        "./add/operator/sampleTime": 196,
        "./add/operator/scan": 197,
        "./add/operator/sequenceEqual": 198,
        "./add/operator/share": 199,
        "./add/operator/shareReplay": 200,
        "./add/operator/single": 201,
        "./add/operator/skip": 202,
        "./add/operator/skipLast": 203,
        "./add/operator/skipUntil": 204,
        "./add/operator/skipWhile": 205,
        "./add/operator/startWith": 206,
        "./add/operator/subscribeOn": 207,
        "./add/operator/switch": 208,
        "./add/operator/switchMap": 209,
        "./add/operator/switchMapTo": 210,
        "./add/operator/take": 211,
        "./add/operator/takeLast": 212,
        "./add/operator/takeUntil": 213,
        "./add/operator/takeWhile": 214,
        "./add/operator/throttle": 215,
        "./add/operator/throttleTime": 216,
        "./add/operator/timeInterval": 217,
        "./add/operator/timeout": 218,
        "./add/operator/timeoutWith": 219,
        "./add/operator/timestamp": 220,
        "./add/operator/toArray": 221,
        "./add/operator/toPromise": 222,
        "./add/operator/window": 223,
        "./add/operator/windowCount": 224,
        "./add/operator/windowTime": 225,
        "./add/operator/windowToggle": 226,
        "./add/operator/windowWhen": 227,
        "./add/operator/withLatestFrom": 228,
        "./add/operator/zip": 229,
        "./add/operator/zipAll": 230,
        rxjs: 333,
        "rxjs/ajax": 332,
        "rxjs/internal-compatibility": 334,
        "rxjs/operators": 547,
        "rxjs/testing": 548,
      },
    ],
    102: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.bindCallback = rxjs_1.bindCallback;
      },
      { rxjs: 333 },
    ],
    103: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.bindNodeCallback = rxjs_1.bindNodeCallback;
      },
      { rxjs: 333 },
    ],
    104: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.combineLatest = rxjs_1.combineLatest;
      },
      { rxjs: 333 },
    ],
    105: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.concat = rxjs_1.concat;
      },
      { rxjs: 333 },
    ],
    106: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.defer = rxjs_1.defer;
      },
      { rxjs: 333 },
    ],
    107: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var ajax_1 = require("rxjs/ajax");
        rxjs_1.Observable.ajax = ajax_1.ajax;
      },
      { rxjs: 333, "rxjs/ajax": 332 },
    ],
    108: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var webSocket_1 = require("rxjs/webSocket");
        rxjs_1.Observable.webSocket = webSocket_1.webSocket;
      },
      { rxjs: 333, "rxjs/webSocket": 549 },
    ],
    109: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.empty = rxjs_1.empty;
      },
      { rxjs: 333 },
    ],
    110: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.forkJoin = rxjs_1.forkJoin;
      },
      { rxjs: 333 },
    ],
    111: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.from = rxjs_1.from;
      },
      { rxjs: 333 },
    ],
    112: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.fromEvent = rxjs_1.fromEvent;
      },
      { rxjs: 333 },
    ],
    113: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.fromEventPattern = rxjs_1.fromEventPattern;
      },
      { rxjs: 333 },
    ],
    114: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.fromPromise = rxjs_1.from;
      },
      { rxjs: 333 },
    ],
    115: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.generate = rxjs_1.generate;
      },
      { rxjs: 333 },
    ],
    116: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.if = rxjs_1.iif;
      },
      { rxjs: 333 },
    ],
    117: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.interval = rxjs_1.interval;
      },
      { rxjs: 333 },
    ],
    118: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.merge = rxjs_1.merge;
      },
      { rxjs: 333 },
    ],
    119: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        function staticNever() {
          return rxjs_1.NEVER;
        }
        exports.staticNever = staticNever;
        rxjs_1.Observable.never = staticNever;
      },
      { rxjs: 333 },
    ],
    120: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.of = rxjs_1.of;
      },
      { rxjs: 333 },
    ],
    121: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.onErrorResumeNext = rxjs_1.onErrorResumeNext;
      },
      { rxjs: 333 },
    ],
    122: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.pairs = rxjs_1.pairs;
      },
      { rxjs: 333 },
    ],
    123: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.race = rxjs_1.race;
      },
      { rxjs: 333 },
    ],
    124: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.range = rxjs_1.range;
      },
      { rxjs: 333 },
    ],
    125: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.throw = rxjs_1.throwError;
        rxjs_1.Observable.throwError = rxjs_1.throwError;
      },
      { rxjs: 333 },
    ],
    126: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.timer = rxjs_1.timer;
      },
      { rxjs: 333 },
    ],
    127: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.using = rxjs_1.using;
      },
      { rxjs: 333 },
    ],
    128: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        rxjs_1.Observable.zip = rxjs_1.zip;
      },
      { rxjs: 333 },
    ],
    129: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var audit_1 = require("../../operator/audit");
        rxjs_1.Observable.prototype.audit = audit_1.audit;
      },
      { "../../operator/audit": 231, rxjs: 333 },
    ],
    130: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var auditTime_1 = require("../../operator/auditTime");
        rxjs_1.Observable.prototype.auditTime = auditTime_1.auditTime;
      },
      { "../../operator/auditTime": 232, rxjs: 333 },
    ],
    131: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var buffer_1 = require("../../operator/buffer");
        rxjs_1.Observable.prototype.buffer = buffer_1.buffer;
      },
      { "../../operator/buffer": 233, rxjs: 333 },
    ],
    132: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var bufferCount_1 = require("../../operator/bufferCount");
        rxjs_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;
      },
      { "../../operator/bufferCount": 234, rxjs: 333 },
    ],
    133: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var bufferTime_1 = require("../../operator/bufferTime");
        rxjs_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;
      },
      { "../../operator/bufferTime": 235, rxjs: 333 },
    ],
    134: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var bufferToggle_1 = require("../../operator/bufferToggle");
        rxjs_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;
      },
      { "../../operator/bufferToggle": 236, rxjs: 333 },
    ],
    135: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var bufferWhen_1 = require("../../operator/bufferWhen");
        rxjs_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;
      },
      { "../../operator/bufferWhen": 237, rxjs: 333 },
    ],
    136: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var catch_1 = require("../../operator/catch");
        rxjs_1.Observable.prototype.catch = catch_1._catch;
        rxjs_1.Observable.prototype._catch = catch_1._catch;
      },
      { "../../operator/catch": 238, rxjs: 333 },
    ],
    137: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var combineAll_1 = require("../../operator/combineAll");
        rxjs_1.Observable.prototype.combineAll = combineAll_1.combineAll;
      },
      { "../../operator/combineAll": 239, rxjs: 333 },
    ],
    138: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var combineLatest_1 = require("../../operator/combineLatest");
        rxjs_1.Observable.prototype.combineLatest =
          combineLatest_1.combineLatest;
      },
      { "../../operator/combineLatest": 240, rxjs: 333 },
    ],
    139: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var concat_1 = require("../../operator/concat");
        rxjs_1.Observable.prototype.concat = concat_1.concat;
      },
      { "../../operator/concat": 241, rxjs: 333 },
    ],
    140: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var concatAll_1 = require("../../operator/concatAll");
        rxjs_1.Observable.prototype.concatAll = concatAll_1.concatAll;
      },
      { "../../operator/concatAll": 242, rxjs: 333 },
    ],
    141: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var concatMap_1 = require("../../operator/concatMap");
        rxjs_1.Observable.prototype.concatMap = concatMap_1.concatMap;
      },
      { "../../operator/concatMap": 243, rxjs: 333 },
    ],
    142: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var concatMapTo_1 = require("../../operator/concatMapTo");
        rxjs_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;
      },
      { "../../operator/concatMapTo": 244, rxjs: 333 },
    ],
    143: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var count_1 = require("../../operator/count");
        rxjs_1.Observable.prototype.count = count_1.count;
      },
      { "../../operator/count": 245, rxjs: 333 },
    ],
    144: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var debounce_1 = require("../../operator/debounce");
        rxjs_1.Observable.prototype.debounce = debounce_1.debounce;
      },
      { "../../operator/debounce": 246, rxjs: 333 },
    ],
    145: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var debounceTime_1 = require("../../operator/debounceTime");
        rxjs_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
      },
      { "../../operator/debounceTime": 247, rxjs: 333 },
    ],
    146: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var defaultIfEmpty_1 = require("../../operator/defaultIfEmpty");
        rxjs_1.Observable.prototype.defaultIfEmpty =
          defaultIfEmpty_1.defaultIfEmpty;
      },
      { "../../operator/defaultIfEmpty": 248, rxjs: 333 },
    ],
    147: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var delay_1 = require("../../operator/delay");
        rxjs_1.Observable.prototype.delay = delay_1.delay;
      },
      { "../../operator/delay": 249, rxjs: 333 },
    ],
    148: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var delayWhen_1 = require("../../operator/delayWhen");
        rxjs_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;
      },
      { "../../operator/delayWhen": 250, rxjs: 333 },
    ],
    149: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var dematerialize_1 = require("../../operator/dematerialize");
        rxjs_1.Observable.prototype.dematerialize =
          dematerialize_1.dematerialize;
      },
      { "../../operator/dematerialize": 251, rxjs: 333 },
    ],
    150: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var distinct_1 = require("../../operator/distinct");
        rxjs_1.Observable.prototype.distinct = distinct_1.distinct;
      },
      { "../../operator/distinct": 252, rxjs: 333 },
    ],
    151: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var distinctUntilChanged_1 = require("../../operator/distinctUntilChanged");
        rxjs_1.Observable.prototype.distinctUntilChanged =
          distinctUntilChanged_1.distinctUntilChanged;
      },
      { "../../operator/distinctUntilChanged": 253, rxjs: 333 },
    ],
    152: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var distinctUntilKeyChanged_1 = require("../../operator/distinctUntilKeyChanged");
        rxjs_1.Observable.prototype.distinctUntilKeyChanged =
          distinctUntilKeyChanged_1.distinctUntilKeyChanged;
      },
      { "../../operator/distinctUntilKeyChanged": 254, rxjs: 333 },
    ],
    153: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var do_1 = require("../../operator/do");
        rxjs_1.Observable.prototype.do = do_1._do;
        rxjs_1.Observable.prototype._do = do_1._do;
      },
      { "../../operator/do": 255, rxjs: 333 },
    ],
    154: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var elementAt_1 = require("../../operator/elementAt");
        rxjs_1.Observable.prototype.elementAt = elementAt_1.elementAt;
      },
      { "../../operator/elementAt": 256, rxjs: 333 },
    ],
    155: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var every_1 = require("../../operator/every");
        rxjs_1.Observable.prototype.every = every_1.every;
      },
      { "../../operator/every": 257, rxjs: 333 },
    ],
    156: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var exhaust_1 = require("../../operator/exhaust");
        rxjs_1.Observable.prototype.exhaust = exhaust_1.exhaust;
      },
      { "../../operator/exhaust": 258, rxjs: 333 },
    ],
    157: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var exhaustMap_1 = require("../../operator/exhaustMap");
        rxjs_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;
      },
      { "../../operator/exhaustMap": 259, rxjs: 333 },
    ],
    158: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var expand_1 = require("../../operator/expand");
        rxjs_1.Observable.prototype.expand = expand_1.expand;
      },
      { "../../operator/expand": 260, rxjs: 333 },
    ],
    159: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var filter_1 = require("../../operator/filter");
        rxjs_1.Observable.prototype.filter = filter_1.filter;
      },
      { "../../operator/filter": 261, rxjs: 333 },
    ],
    160: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var finally_1 = require("../../operator/finally");
        rxjs_1.Observable.prototype.finally = finally_1._finally;
        rxjs_1.Observable.prototype._finally = finally_1._finally;
      },
      { "../../operator/finally": 262, rxjs: 333 },
    ],
    161: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var find_1 = require("../../operator/find");
        rxjs_1.Observable.prototype.find = find_1.find;
      },
      { "../../operator/find": 263, rxjs: 333 },
    ],
    162: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var findIndex_1 = require("../../operator/findIndex");
        rxjs_1.Observable.prototype.findIndex = findIndex_1.findIndex;
      },
      { "../../operator/findIndex": 264, rxjs: 333 },
    ],
    163: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var first_1 = require("../../operator/first");
        rxjs_1.Observable.prototype.first = first_1.first;
      },
      { "../../operator/first": 265, rxjs: 333 },
    ],
    164: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var groupBy_1 = require("../../operator/groupBy");
        rxjs_1.Observable.prototype.groupBy = groupBy_1.groupBy;
      },
      { "../../operator/groupBy": 266, rxjs: 333 },
    ],
    165: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var ignoreElements_1 = require("../../operator/ignoreElements");
        rxjs_1.Observable.prototype.ignoreElements =
          ignoreElements_1.ignoreElements;
      },
      { "../../operator/ignoreElements": 267, rxjs: 333 },
    ],
    166: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var isEmpty_1 = require("../../operator/isEmpty");
        rxjs_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;
      },
      { "../../operator/isEmpty": 268, rxjs: 333 },
    ],
    167: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var last_1 = require("../../operator/last");
        rxjs_1.Observable.prototype.last = last_1.last;
      },
      { "../../operator/last": 269, rxjs: 333 },
    ],
    168: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var let_1 = require("../../operator/let");
        rxjs_1.Observable.prototype.let = let_1.letProto;
        rxjs_1.Observable.prototype.letBind = let_1.letProto;
      },
      { "../../operator/let": 270, rxjs: 333 },
    ],
    169: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var map_1 = require("../../operator/map");
        rxjs_1.Observable.prototype.map = map_1.map;
      },
      { "../../operator/map": 271, rxjs: 333 },
    ],
    170: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var mapTo_1 = require("../../operator/mapTo");
        rxjs_1.Observable.prototype.mapTo = mapTo_1.mapTo;
      },
      { "../../operator/mapTo": 272, rxjs: 333 },
    ],
    171: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var materialize_1 = require("../../operator/materialize");
        rxjs_1.Observable.prototype.materialize = materialize_1.materialize;
      },
      { "../../operator/materialize": 273, rxjs: 333 },
    ],
    172: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var max_1 = require("../../operator/max");
        rxjs_1.Observable.prototype.max = max_1.max;
      },
      { "../../operator/max": 274, rxjs: 333 },
    ],
    173: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var merge_1 = require("../../operator/merge");
        rxjs_1.Observable.prototype.merge = merge_1.merge;
      },
      { "../../operator/merge": 275, rxjs: 333 },
    ],
    174: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var mergeAll_1 = require("../../operator/mergeAll");
        rxjs_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;
      },
      { "../../operator/mergeAll": 276, rxjs: 333 },
    ],
    175: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var mergeMap_1 = require("../../operator/mergeMap");
        rxjs_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
        rxjs_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
      },
      { "../../operator/mergeMap": 277, rxjs: 333 },
    ],
    176: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var mergeMapTo_1 = require("../../operator/mergeMapTo");
        rxjs_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;
        rxjs_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;
      },
      { "../../operator/mergeMapTo": 278, rxjs: 333 },
    ],
    177: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var mergeScan_1 = require("../../operator/mergeScan");
        rxjs_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;
      },
      { "../../operator/mergeScan": 279, rxjs: 333 },
    ],
    178: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var min_1 = require("../../operator/min");
        rxjs_1.Observable.prototype.min = min_1.min;
      },
      { "../../operator/min": 280, rxjs: 333 },
    ],
    179: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var multicast_1 = require("../../operator/multicast");
        rxjs_1.Observable.prototype.multicast = multicast_1.multicast;
      },
      { "../../operator/multicast": 281, rxjs: 333 },
    ],
    180: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var observeOn_1 = require("../../operator/observeOn");
        rxjs_1.Observable.prototype.observeOn = observeOn_1.observeOn;
      },
      { "../../operator/observeOn": 282, rxjs: 333 },
    ],
    181: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var onErrorResumeNext_1 = require("../../operator/onErrorResumeNext");
        rxjs_1.Observable.prototype.onErrorResumeNext =
          onErrorResumeNext_1.onErrorResumeNext;
      },
      { "../../operator/onErrorResumeNext": 283, rxjs: 333 },
    ],
    182: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var pairwise_1 = require("../../operator/pairwise");
        rxjs_1.Observable.prototype.pairwise = pairwise_1.pairwise;
      },
      { "../../operator/pairwise": 284, rxjs: 333 },
    ],
    183: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var partition_1 = require("../../operator/partition");
        rxjs_1.Observable.prototype.partition = partition_1.partition;
      },
      { "../../operator/partition": 285, rxjs: 333 },
    ],
    184: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var pluck_1 = require("../../operator/pluck");
        rxjs_1.Observable.prototype.pluck = pluck_1.pluck;
      },
      { "../../operator/pluck": 286, rxjs: 333 },
    ],
    185: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var publish_1 = require("../../operator/publish");
        rxjs_1.Observable.prototype.publish = publish_1.publish;
      },
      { "../../operator/publish": 287, rxjs: 333 },
    ],
    186: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var publishBehavior_1 = require("../../operator/publishBehavior");
        rxjs_1.Observable.prototype.publishBehavior =
          publishBehavior_1.publishBehavior;
      },
      { "../../operator/publishBehavior": 288, rxjs: 333 },
    ],
    187: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var publishLast_1 = require("../../operator/publishLast");
        rxjs_1.Observable.prototype.publishLast = publishLast_1.publishLast;
      },
      { "../../operator/publishLast": 289, rxjs: 333 },
    ],
    188: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var publishReplay_1 = require("../../operator/publishReplay");
        rxjs_1.Observable.prototype.publishReplay =
          publishReplay_1.publishReplay;
      },
      { "../../operator/publishReplay": 290, rxjs: 333 },
    ],
    189: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var race_1 = require("../../operator/race");
        rxjs_1.Observable.prototype.race = race_1.race;
      },
      { "../../operator/race": 291, rxjs: 333 },
    ],
    190: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var reduce_1 = require("../../operator/reduce");
        rxjs_1.Observable.prototype.reduce = reduce_1.reduce;
      },
      { "../../operator/reduce": 292, rxjs: 333 },
    ],
    191: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var repeat_1 = require("../../operator/repeat");
        rxjs_1.Observable.prototype.repeat = repeat_1.repeat;
      },
      { "../../operator/repeat": 293, rxjs: 333 },
    ],
    192: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var repeatWhen_1 = require("../../operator/repeatWhen");
        rxjs_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;
      },
      { "../../operator/repeatWhen": 294, rxjs: 333 },
    ],
    193: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var retry_1 = require("../../operator/retry");
        rxjs_1.Observable.prototype.retry = retry_1.retry;
      },
      { "../../operator/retry": 295, rxjs: 333 },
    ],
    194: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var retryWhen_1 = require("../../operator/retryWhen");
        rxjs_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;
      },
      { "../../operator/retryWhen": 296, rxjs: 333 },
    ],
    195: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var sample_1 = require("../../operator/sample");
        rxjs_1.Observable.prototype.sample = sample_1.sample;
      },
      { "../../operator/sample": 297, rxjs: 333 },
    ],
    196: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var sampleTime_1 = require("../../operator/sampleTime");
        rxjs_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;
      },
      { "../../operator/sampleTime": 298, rxjs: 333 },
    ],
    197: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var scan_1 = require("../../operator/scan");
        rxjs_1.Observable.prototype.scan = scan_1.scan;
      },
      { "../../operator/scan": 299, rxjs: 333 },
    ],
    198: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var sequenceEqual_1 = require("../../operator/sequenceEqual");
        rxjs_1.Observable.prototype.sequenceEqual =
          sequenceEqual_1.sequenceEqual;
      },
      { "../../operator/sequenceEqual": 300, rxjs: 333 },
    ],
    199: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var share_1 = require("../../operator/share");
        rxjs_1.Observable.prototype.share = share_1.share;
      },
      { "../../operator/share": 301, rxjs: 333 },
    ],
    200: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var shareReplay_1 = require("../../operator/shareReplay");
        rxjs_1.Observable.prototype.shareReplay = shareReplay_1.shareReplay;
      },
      { "../../operator/shareReplay": 302, rxjs: 333 },
    ],
    201: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var single_1 = require("../../operator/single");
        rxjs_1.Observable.prototype.single = single_1.single;
      },
      { "../../operator/single": 303, rxjs: 333 },
    ],
    202: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var skip_1 = require("../../operator/skip");
        rxjs_1.Observable.prototype.skip = skip_1.skip;
      },
      { "../../operator/skip": 304, rxjs: 333 },
    ],
    203: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var skipLast_1 = require("../../operator/skipLast");
        rxjs_1.Observable.prototype.skipLast = skipLast_1.skipLast;
      },
      { "../../operator/skipLast": 305, rxjs: 333 },
    ],
    204: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var skipUntil_1 = require("../../operator/skipUntil");
        rxjs_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;
      },
      { "../../operator/skipUntil": 306, rxjs: 333 },
    ],
    205: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var skipWhile_1 = require("../../operator/skipWhile");
        rxjs_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;
      },
      { "../../operator/skipWhile": 307, rxjs: 333 },
    ],
    206: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var startWith_1 = require("../../operator/startWith");
        rxjs_1.Observable.prototype.startWith = startWith_1.startWith;
      },
      { "../../operator/startWith": 308, rxjs: 333 },
    ],
    207: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var subscribeOn_1 = require("../../operator/subscribeOn");
        rxjs_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;
      },
      { "../../operator/subscribeOn": 309, rxjs: 333 },
    ],
    208: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var switch_1 = require("../../operator/switch");
        rxjs_1.Observable.prototype.switch = switch_1._switch;
        rxjs_1.Observable.prototype._switch = switch_1._switch;
      },
      { "../../operator/switch": 310, rxjs: 333 },
    ],
    209: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var switchMap_1 = require("../../operator/switchMap");
        rxjs_1.Observable.prototype.switchMap = switchMap_1.switchMap;
      },
      { "../../operator/switchMap": 311, rxjs: 333 },
    ],
    210: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var switchMapTo_1 = require("../../operator/switchMapTo");
        rxjs_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;
      },
      { "../../operator/switchMapTo": 312, rxjs: 333 },
    ],
    211: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var take_1 = require("../../operator/take");
        rxjs_1.Observable.prototype.take = take_1.take;
      },
      { "../../operator/take": 313, rxjs: 333 },
    ],
    212: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var takeLast_1 = require("../../operator/takeLast");
        rxjs_1.Observable.prototype.takeLast = takeLast_1.takeLast;
      },
      { "../../operator/takeLast": 314, rxjs: 333 },
    ],
    213: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var takeUntil_1 = require("../../operator/takeUntil");
        rxjs_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;
      },
      { "../../operator/takeUntil": 315, rxjs: 333 },
    ],
    214: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var takeWhile_1 = require("../../operator/takeWhile");
        rxjs_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;
      },
      { "../../operator/takeWhile": 316, rxjs: 333 },
    ],
    215: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var throttle_1 = require("../../operator/throttle");
        rxjs_1.Observable.prototype.throttle = throttle_1.throttle;
      },
      { "../../operator/throttle": 317, rxjs: 333 },
    ],
    216: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var throttleTime_1 = require("../../operator/throttleTime");
        rxjs_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;
      },
      { "../../operator/throttleTime": 318, rxjs: 333 },
    ],
    217: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var timeInterval_1 = require("../../operator/timeInterval");
        rxjs_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;
      },
      { "../../operator/timeInterval": 319, rxjs: 333 },
    ],
    218: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var timeout_1 = require("../../operator/timeout");
        rxjs_1.Observable.prototype.timeout = timeout_1.timeout;
      },
      { "../../operator/timeout": 320, rxjs: 333 },
    ],
    219: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var timeoutWith_1 = require("../../operator/timeoutWith");
        rxjs_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;
      },
      { "../../operator/timeoutWith": 321, rxjs: 333 },
    ],
    220: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var timestamp_1 = require("../../operator/timestamp");
        rxjs_1.Observable.prototype.timestamp = timestamp_1.timestamp;
      },
      { "../../operator/timestamp": 322, rxjs: 333 },
    ],
    221: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var toArray_1 = require("../../operator/toArray");
        rxjs_1.Observable.prototype.toArray = toArray_1.toArray;
      },
      { "../../operator/toArray": 323, rxjs: 333 },
    ],
    222: [
      function (require, module, exports) {
        // HACK: does nothing, because `toPromise` now lives on the `Observable` itself.
        // leaving this module here to prevent breakage.
      },
      {},
    ],
    223: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var window_1 = require("../../operator/window");
        rxjs_1.Observable.prototype.window = window_1.window;
      },
      { "../../operator/window": 324, rxjs: 333 },
    ],
    224: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var windowCount_1 = require("../../operator/windowCount");
        rxjs_1.Observable.prototype.windowCount = windowCount_1.windowCount;
      },
      { "../../operator/windowCount": 325, rxjs: 333 },
    ],
    225: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var windowTime_1 = require("../../operator/windowTime");
        rxjs_1.Observable.prototype.windowTime = windowTime_1.windowTime;
      },
      { "../../operator/windowTime": 326, rxjs: 333 },
    ],
    226: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var windowToggle_1 = require("../../operator/windowToggle");
        rxjs_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;
      },
      { "../../operator/windowToggle": 327, rxjs: 333 },
    ],
    227: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var windowWhen_1 = require("../../operator/windowWhen");
        rxjs_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;
      },
      { "../../operator/windowWhen": 328, rxjs: 333 },
    ],
    228: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var withLatestFrom_1 = require("../../operator/withLatestFrom");
        rxjs_1.Observable.prototype.withLatestFrom =
          withLatestFrom_1.withLatestFrom;
      },
      { "../../operator/withLatestFrom": 329, rxjs: 333 },
    ],
    229: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var zip_1 = require("../../operator/zip");
        rxjs_1.Observable.prototype.zip = zip_1.zipProto;
      },
      { "../../operator/zip": 330, rxjs: 333 },
    ],
    230: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var zipAll_1 = require("../../operator/zipAll");
        rxjs_1.Observable.prototype.zipAll = zipAll_1.zipAll;
      },
      { "../../operator/zipAll": 331, rxjs: 333 },
    ],
    231: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Ignores source values for a duration determined by another Observable, then
         * emits the most recent value from the source Observable, then repeats this
         * process.
         *
         * <span class="informal">It's like {@link auditTime}, but the silencing
         * duration is determined by a second Observable.</span>
         *
         * <img src="./img/audit.png" width="100%">
         *
         * `audit` is similar to `throttle`, but emits the last value from the silenced
         * time window, instead of the first value. `audit` emits the most recent value
         * from the source Observable on the output Observable as soon as its internal
         * timer becomes disabled, and ignores source values while the timer is enabled.
         * Initially, the timer is disabled. As soon as the first source value arrives,
         * the timer is enabled by calling the `durationSelector` function with the
         * source value, which returns the "duration" Observable. When the duration
         * Observable emits a value or completes, the timer is disabled, then the most
         * recent source value is emitted on the output Observable, and this process
         * repeats for the next source value.
         *
         * @example <caption>Emit clicks at a rate of at most one click per second</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.audit(ev => Rx.Observable.interval(1000));
         * result.subscribe(x => console.log(x));
         *
         * @see {@link auditTime}
         * @see {@link debounce}
         * @see {@link delayWhen}
         * @see {@link sample}
         * @see {@link throttle}
         *
         * @param {function(value: T): SubscribableOrPromise} durationSelector A function
         * that receives a value from the source Observable, for computing the silencing
         * duration, returned as an Observable or a Promise.
         * @return {Observable<T>} An Observable that performs rate-limiting of
         * emissions from the source Observable.
         * @method audit
         * @owner Observable
         */
        function audit(durationSelector) {
          return operators_1.audit(durationSelector)(this);
        }
        exports.audit = audit;
      },
      { "rxjs/operators": 547 },
    ],
    232: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var operators_1 = require("rxjs/operators");
        /**
         * Ignores source values for `duration` milliseconds, then emits the most recent
         * value from the source Observable, then repeats this process.
         *
         * <span class="informal">When it sees a source values, it ignores that plus
         * the next ones for `duration` milliseconds, and then it emits the most recent
         * value from the source.</span>
         *
         * <img src="./img/auditTime.png" width="100%">
         *
         * `auditTime` is similar to `throttleTime`, but emits the last value from the
         * silenced time window, instead of the first value. `auditTime` emits the most
         * recent value from the source Observable on the output Observable as soon as
         * its internal timer becomes disabled, and ignores source values while the
         * timer is enabled. Initially, the timer is disabled. As soon as the first
         * source value arrives, the timer is enabled. After `duration` milliseconds (or
         * the time unit determined internally by the optional `scheduler`) has passed,
         * the timer is disabled, then the most recent source value is emitted on the
         * output Observable, and this process repeats for the next source value.
         * Optionally takes a {@link IScheduler} for managing timers.
         *
         * @example <caption>Emit clicks at a rate of at most one click per second</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.auditTime(1000);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link audit}
         * @see {@link debounceTime}
         * @see {@link delay}
         * @see {@link sampleTime}
         * @see {@link throttleTime}
         *
         * @param {number} duration Time to wait before emitting the most recent source
         * value, measured in milliseconds or the time unit determined internally
         * by the optional `scheduler`.
         * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
         * managing the timers that handle the rate-limiting behavior.
         * @return {Observable<T>} An Observable that performs rate-limiting of
         * emissions from the source Observable.
         * @method auditTime
         * @owner Observable
         */
        function auditTime(duration, scheduler) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          return operators_1.auditTime(duration, scheduler)(this);
        }
        exports.auditTime = auditTime;
      },
      { rxjs: 333, "rxjs/operators": 547 },
    ],
    233: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Buffers the source Observable values until `closingNotifier` emits.
         *
         * <span class="informal">Collects values from the past as an array, and emits
         * that array only when another Observable emits.</span>
         *
         * <img src="./img/buffer.png" width="100%">
         *
         * Buffers the incoming Observable values until the given `closingNotifier`
         * Observable emits a value, at which point it emits the buffer on the output
         * Observable and starts a new buffer internally, awaiting the next time
         * `closingNotifier` emits.
         *
         * @example <caption>On every click, emit array of most recent interval events</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var interval = Rx.Observable.interval(1000);
         * var buffered = interval.buffer(clicks);
         * buffered.subscribe(x => console.log(x));
         *
         * @see {@link bufferCount}
         * @see {@link bufferTime}
         * @see {@link bufferToggle}
         * @see {@link bufferWhen}
         * @see {@link window}
         *
         * @param {Observable<any>} closingNotifier An Observable that signals the
         * buffer to be emitted on the output Observable.
         * @return {Observable<T[]>} An Observable of buffers, which are arrays of
         * values.
         * @method buffer
         * @owner Observable
         */
        function buffer(closingNotifier) {
          return operators_1.buffer(closingNotifier)(this);
        }
        exports.buffer = buffer;
      },
      { "rxjs/operators": 547 },
    ],
    234: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Buffers the source Observable values until the size hits the maximum
         * `bufferSize` given.
         *
         * <span class="informal">Collects values from the past as an array, and emits
         * that array only when its size reaches `bufferSize`.</span>
         *
         * <img src="./img/bufferCount.png" width="100%">
         *
         * Buffers a number of values from the source Observable by `bufferSize` then
         * emits the buffer and clears it, and starts a new buffer each
         * `startBufferEvery` values. If `startBufferEvery` is not provided or is
         * `null`, then new buffers are started immediately at the start of the source
         * and when each buffer closes and is emitted.
         *
         * @example <caption>Emit the last two click events as an array</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var buffered = clicks.bufferCount(2);
         * buffered.subscribe(x => console.log(x));
         *
         * @example <caption>On every click, emit the last two click events as an array</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var buffered = clicks.bufferCount(2, 1);
         * buffered.subscribe(x => console.log(x));
         *
         * @see {@link buffer}
         * @see {@link bufferTime}
         * @see {@link bufferToggle}
         * @see {@link bufferWhen}
         * @see {@link pairwise}
         * @see {@link windowCount}
         *
         * @param {number} bufferSize The maximum size of the buffer emitted.
         * @param {number} [startBufferEvery] Interval at which to start a new buffer.
         * For example if `startBufferEvery` is `2`, then a new buffer will be started
         * on every other value from the source. A new buffer is started at the
         * beginning of the source by default.
         * @return {Observable<T[]>} An Observable of arrays of buffered values.
         * @method bufferCount
         * @owner Observable
         */
        function bufferCount(bufferSize, startBufferEvery) {
          if (startBufferEvery === void 0) {
            startBufferEvery = null;
          }
          return operators_1.bufferCount(bufferSize, startBufferEvery)(this);
        }
        exports.bufferCount = bufferCount;
      },
      { "rxjs/operators": 547 },
    ],
    235: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var internal_compatibility_1 = require("rxjs/internal-compatibility");
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Buffers the source Observable values for a specific time period.
         *
         * <span class="informal">Collects values from the past as an array, and emits
         * those arrays periodically in time.</span>
         *
         * <img src="./img/bufferTime.png" width="100%">
         *
         * Buffers values from the source for a specific time duration `bufferTimeSpan`.
         * Unless the optional argument `bufferCreationInterval` is given, it emits and
         * resets the buffer every `bufferTimeSpan` milliseconds. If
         * `bufferCreationInterval` is given, this operator opens the buffer every
         * `bufferCreationInterval` milliseconds and closes (emits and resets) the
         * buffer every `bufferTimeSpan` milliseconds. When the optional argument
         * `maxBufferSize` is specified, the buffer will be closed either after
         * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
         *
         * @example <caption>Every second, emit an array of the recent click events</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var buffered = clicks.bufferTime(1000);
         * buffered.subscribe(x => console.log(x));
         *
         * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var buffered = clicks.bufferTime(2000, 5000);
         * buffered.subscribe(x => console.log(x));
         *
         * @see {@link buffer}
         * @see {@link bufferCount}
         * @see {@link bufferToggle}
         * @see {@link bufferWhen}
         * @see {@link windowTime}
         *
         * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
         * @param {number} [bufferCreationInterval] The interval at which to start new
         * buffers.
         * @param {number} [maxBufferSize] The maximum buffer size.
         * @param {Scheduler} [scheduler=asyncScheduler] The scheduler on which to schedule the
         * intervals that determine buffer boundaries.
         * @return {Observable<T[]>} An observable of arrays of buffered values.
         * @method bufferTime
         * @owner Observable
         */
        function bufferTime(bufferTimeSpan) {
          var length = arguments.length;
          var scheduler = rxjs_1.asyncScheduler;
          if (
            internal_compatibility_1.isScheduler(
              arguments[arguments.length - 1]
            )
          ) {
            scheduler = arguments[arguments.length - 1];
            length--;
          }
          var bufferCreationInterval = null;
          if (length >= 2) {
            bufferCreationInterval = arguments[1];
          }
          var maxBufferSize = Number.POSITIVE_INFINITY;
          if (length >= 3) {
            maxBufferSize = arguments[2];
          }
          return operators_1.bufferTime(
            bufferTimeSpan,
            bufferCreationInterval,
            maxBufferSize,
            scheduler
          )(this);
        }
        exports.bufferTime = bufferTime;
      },
      { rxjs: 333, "rxjs/internal-compatibility": 334, "rxjs/operators": 547 },
    ],
    236: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Buffers the source Observable values starting from an emission from
         * `openings` and ending when the output of `closingSelector` emits.
         *
         * <span class="informal">Collects values from the past as an array. Starts
         * collecting only when `opening` emits, and calls the `closingSelector`
         * function to get an Observable that tells when to close the buffer.</span>
         *
         * <img src="./img/bufferToggle.png" width="100%">
         *
         * Buffers values from the source by opening the buffer via signals from an
         * Observable provided to `openings`, and closing and sending the buffers when
         * a Subscribable or Promise returned by the `closingSelector` function emits.
         *
         * @example <caption>Every other second, emit the click events from the next 500ms</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var openings = Rx.Observable.interval(1000);
         * var buffered = clicks.bufferToggle(openings, i =>
         *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
         * );
         * buffered.subscribe(x => console.log(x));
         *
         * @see {@link buffer}
         * @see {@link bufferCount}
         * @see {@link bufferTime}
         * @see {@link bufferWhen}
         * @see {@link windowToggle}
         *
         * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
         * buffers.
         * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
         * the value emitted by the `openings` observable and returns a Subscribable or Promise,
         * which, when it emits, signals that the associated buffer should be emitted
         * and cleared.
         * @return {Observable<T[]>} An observable of arrays of buffered values.
         * @method bufferToggle
         * @owner Observable
         */
        function bufferToggle(openings, closingSelector) {
          return operators_1.bufferToggle(openings, closingSelector)(this);
        }
        exports.bufferToggle = bufferToggle;
      },
      { "rxjs/operators": 547 },
    ],
    237: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Buffers the source Observable values, using a factory function of closing
         * Observables to determine when to close, emit, and reset the buffer.
         *
         * <span class="informal">Collects values from the past as an array. When it
         * starts collecting values, it calls a function that returns an Observable that
         * tells when to close the buffer and restart collecting.</span>
         *
         * <img src="./img/bufferWhen.png" width="100%">
         *
         * Opens a buffer immediately, then closes the buffer when the observable
         * returned by calling `closingSelector` function emits a value. When it closes
         * the buffer, it immediately opens a new buffer and repeats the process.
         *
         * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var buffered = clicks.bufferWhen(() =>
         *   Rx.Observable.interval(1000 + Math.random() * 4000)
         * );
         * buffered.subscribe(x => console.log(x));
         *
         * @see {@link buffer}
         * @see {@link bufferCount}
         * @see {@link bufferTime}
         * @see {@link bufferToggle}
         * @see {@link windowWhen}
         *
         * @param {function(): Observable} closingSelector A function that takes no
         * arguments and returns an Observable that signals buffer closure.
         * @return {Observable<T[]>} An observable of arrays of buffered values.
         * @method bufferWhen
         * @owner Observable
         */
        function bufferWhen(closingSelector) {
          return operators_1.bufferWhen(closingSelector)(this);
        }
        exports.bufferWhen = bufferWhen;
      },
      { "rxjs/operators": 547 },
    ],
    238: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Catches errors on the observable to be handled by returning a new observable or throwing an error.
         *
         * <img src="./img/catch.png" width="100%">
         *
         * @example <caption>Continues with a different Observable when there's an error</caption>
         *
         * Observable.of(1, 2, 3, 4, 5)
         *   .map(n => {
         * 	   if (n == 4) {
         * 	     throw 'four!';
         *     }
         *	   return n;
         *   })
         *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
         *   .subscribe(x => console.log(x));
         *   // 1, 2, 3, I, II, III, IV, V
         *
         * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
         *
         * Observable.of(1, 2, 3, 4, 5)
         *   .map(n => {
         * 	   if (n === 4) {
         * 	     throw 'four!';
         *     }
         * 	   return n;
         *   })
         *   .catch((err, caught) => caught)
         *   .take(30)
         *   .subscribe(x => console.log(x));
         *   // 1, 2, 3, 1, 2, 3, ...
         *
         * @example <caption>Throws a new error when the source Observable throws an error</caption>
         *
         * Observable.of(1, 2, 3, 4, 5)
         *   .map(n => {
         *     if (n == 4) {
         *       throw 'four!';
         *     }
         *     return n;
         *   })
         *   .catch(err => {
         *     throw 'error in source. Details: ' + err;
         *   })
         *   .subscribe(
         *     x => console.log(x),
         *     err => console.log(err)
         *   );
         *   // 1, 2, 3, error in source. Details: four!
         *
         * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
         *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
         *  is returned by the `selector` will be used to continue the observable chain.
         * @return {Observable} An observable that originates from either the source or the observable returned by the
         *  catch `selector` function.
         * @method catch
         * @name catch
         * @owner Observable
         */
        function _catch(selector) {
          return operators_1.catchError(selector)(this);
        }
        exports._catch = _catch;
      },
      { "rxjs/operators": 547 },
    ],
    239: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Converts a higher-order Observable into a first-order Observable by waiting
         * for the outer Observable to complete, then applying {@link combineLatest}.
         *
         * <span class="informal">Flattens an Observable-of-Observables by applying
         * {@link combineLatest} when the Observable-of-Observables completes.</span>
         *
         * <img src="./img/combineAll.png" width="100%">
         *
         * Takes an Observable of Observables, and collects all Observables from it.
         * Once the outer Observable completes, it subscribes to all collected
         * Observables and combines their values using the {@link combineLatest}
         * strategy, such that:
         * - Every time an inner Observable emits, the output Observable emits.
         * - When the returned observable emits, it emits all of the latest values by:
         *   - If a `project` function is provided, it is called with each recent value
         *     from each inner Observable in whatever order they arrived, and the result
         *     of the `project` function is what is emitted by the output Observable.
         *   - If there is no `project` function, an array of all of the most recent
         *     values is emitted by the output Observable.
         *
         * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var higherOrder = clicks.map(ev =>
         *   Rx.Observable.interval(Math.random()*2000).take(3)
         * ).take(2);
         * var result = higherOrder.combineAll();
         * result.subscribe(x => console.log(x));
         *
         * @see {@link combineLatest}
         * @see {@link mergeAll}
         *
         * @param {function} [project] An optional function to map the most recent
         * values from each inner Observable into a new result. Takes each of the most
         * recent values from each collected inner Observable as arguments, in order.
         * @return {Observable} An Observable of projected results or arrays of recent
         * values.
         * @method combineAll
         * @owner Observable
         */
        function combineAll(project) {
          return operators_1.combineAll(project)(this);
        }
        exports.combineAll = combineAll;
      },
      { "rxjs/operators": 547 },
    ],
    240: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var internal_compatibility_1 = require("rxjs/internal-compatibility");
        /* tslint:enable:max-line-length */
        /**
         * Combines multiple Observables to create an Observable whose values are
         * calculated from the latest values of each of its input Observables.
         *
         * <span class="informal">Whenever any input Observable emits a value, it
         * computes a formula using the latest values from all the inputs, then emits
         * the output of that formula.</span>
         *
         * <img src="./img/combineLatest.png" width="100%">
         *
         * `combineLatest` combines the values from this Observable with values from
         * Observables passed as arguments. This is done by subscribing to each
         * Observable, in order, and collecting an array of each of the most recent
         * values any time any of the input Observables emits, then either taking that
         * array and passing it as arguments to an optional `project` function and
         * emitting the return value of that, or just emitting the array of recent
         * values directly if there is no `project` function.
         *
         * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
         * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
         * var height = Rx.Observable.of(1.76, 1.77, 1.78);
         * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
         * bmi.subscribe(x => console.log('BMI is ' + x));
         *
         * // With output to console:
         * // BMI is 24.212293388429753
         * // BMI is 23.93948099205209
         * // BMI is 23.671253629592222
         *
         * @see {@link combineAll}
         * @see {@link merge}
         * @see {@link withLatestFrom}
         *
         * @param {ObservableInput} other An input Observable to combine with the source
         * Observable. More than one input Observables may be given as argument.
         * @param {function} [project] An optional function to project the values from
         * the combined latest values into a new value on the output Observable.
         * @return {Observable} An Observable of projected values from the most recent
         * values from each input Observable, or an array of the most recent values from
         * each input Observable.
         * @method combineLatest
         * @owner Observable
         */
        function combineLatest() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          var project = null;
          if (typeof observables[observables.length - 1] === "function") {
            project = observables.pop();
          }
          // if the first and only other argument besides the resultSelector is an array
          // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
          if (
            observables.length === 1 &&
            internal_compatibility_1.isArray(observables[0])
          ) {
            observables = observables[0].slice();
          }
          return this.lift.call(
            rxjs_1.of.apply(void 0, [this].concat(observables)),
            new internal_compatibility_1.CombineLatestOperator(project)
          );
        }
        exports.combineLatest = combineLatest;
      },
      { rxjs: 333, "rxjs/internal-compatibility": 334 },
    ],
    241: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        /* tslint:enable:max-line-length */
        /**
         * Creates an output Observable which sequentially emits all values from every
         * given input Observable after the current Observable.
         *
         * <span class="informal">Concatenates multiple Observables together by
         * sequentially emitting their values, one Observable after the other.</span>
         *
         * <img src="./img/concat.png" width="100%">
         *
         * Joins this Observable with multiple other Observables by subscribing to them
         * one at a time, starting with the source, and merging their results into the
         * output Observable. Will wait for each Observable to complete before moving
         * on to the next.
         *
         * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
         * var timer = Rx.Observable.interval(1000).take(4);
         * var sequence = Rx.Observable.range(1, 10);
         * var result = timer.concat(sequence);
         * result.subscribe(x => console.log(x));
         *
         * // results in:
         * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
         *
         * @example <caption>Concatenate 3 Observables</caption>
         * var timer1 = Rx.Observable.interval(1000).take(10);
         * var timer2 = Rx.Observable.interval(2000).take(6);
         * var timer3 = Rx.Observable.interval(500).take(10);
         * var result = timer1.concat(timer2, timer3);
         * result.subscribe(x => console.log(x));
         *
         * // results in the following:
         * // (Prints to console sequentially)
         * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
         * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
         * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
         *
         * @see {@link concatAll}
         * @see {@link concatMap}
         * @see {@link concatMapTo}
         *
         * @param {ObservableInput} other An input Observable to concatenate after the source
         * Observable. More than one input Observables may be given as argument.
         * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
         * Observable subscription on.
         * @return {Observable} All values of each passed Observable merged into a
         * single Observable, in order, in serial fashion.
         * @method concat
         * @owner Observable
         */
        function concat() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return this.lift.call(
            rxjs_1.concat.apply(void 0, [this].concat(observables))
          );
        }
        exports.concat = concat;
      },
      { rxjs: 333 },
    ],
    242: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Converts a higher-order Observable into a first-order Observable by
         * concatenating the inner Observables in order.
         *
         * <span class="informal">Flattens an Observable-of-Observables by putting one
         * inner Observable after the other.</span>
         *
         * <img src="./img/concatAll.png" width="100%">
         *
         * Joins every Observable emitted by the source (a higher-order Observable), in
         * a serial fashion. It subscribes to each inner Observable only after the
         * previous inner Observable has completed, and merges all of their values into
         * the returned observable.
         *
         * __Warning:__ If the source Observable emits Observables quickly and
         * endlessly, and the inner Observables it emits generally complete slower than
         * the source emits, you can run into memory issues as the incoming Observables
         * collect in an unbounded buffer.
         *
         * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
         * to `1`.
         *
         * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
         * var firstOrder = higherOrder.concatAll();
         * firstOrder.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // (results are not concurrent)
         * // For every click on the "document" it will emit values 0 to 3 spaced
         * // on a 1000ms interval
         * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
         *
         * @see {@link combineAll}
         * @see {@link concat}
         * @see {@link concatMap}
         * @see {@link concatMapTo}
         * @see {@link exhaust}
         * @see {@link mergeAll}
         * @see {@link switch}
         * @see {@link zipAll}
         *
         * @return {Observable} An Observable emitting values from all the inner
         * Observables concatenated.
         * @method concatAll
         * @owner Observable
         */
        function concatAll() {
          return operators_1.concatAll()(this);
        }
        exports.concatAll = concatAll;
      },
      { "rxjs/operators": 547 },
    ],
    243: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Projects each source value to an Observable which is merged in the output
         * Observable, in a serialized fashion waiting for each one to complete before
         * merging the next.
         *
         * <span class="informal">Maps each value to an Observable, then flattens all of
         * these inner Observables using {@link concatAll}.</span>
         *
         * <img src="./img/concatMap.png" width="100%">
         *
         * Returns an Observable that emits items based on applying a function that you
         * supply to each item emitted by the source Observable, where that function
         * returns an (so-called "inner") Observable. Each new inner Observable is
         * concatenated with the previous inner Observable.
         *
         * __Warning:__ if source values arrive endlessly and faster than their
         * corresponding inner Observables can complete, it will result in memory issues
         * as inner Observables amass in an unbounded buffer waiting for their turn to
         * be subscribed to.
         *
         * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
         * to `1`.
         *
         * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // (results are not concurrent)
         * // For every click on the "document" it will emit values 0 to 3 spaced
         * // on a 1000ms interval
         * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
         *
         * @see {@link concat}
         * @see {@link concatAll}
         * @see {@link concatMapTo}
         * @see {@link exhaustMap}
         * @see {@link mergeMap}
         * @see {@link switchMap}
         *
         * @param {function(value: T, ?index: number): ObservableInput} project A function
         * that, when applied to an item emitted by the source Observable, returns an
         * Observable.
         * @return {Observable} An Observable that emits the result of applying the
         * projection function (and the optional `resultSelector`) to each item emitted
         * by the source Observable and taking values from each projected inner
         * Observable sequentially.
         * @method concatMap
         * @owner Observable
         */
        function concatMap(project) {
          return operators_1.concatMap(project)(this);
        }
        exports.concatMap = concatMap;
      },
      { "rxjs/operators": 547 },
    ],
    244: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Projects each source value to the same Observable which is merged multiple
         * times in a serialized fashion on the output Observable.
         *
         * <span class="informal">It's like {@link concatMap}, but maps each value
         * always to the same inner Observable.</span>
         *
         * <img src="./img/concatMapTo.png" width="100%">
         *
         * Maps each source value to the given Observable `innerObservable` regardless
         * of the source value, and then flattens those resulting Observables into one
         * single Observable, which is the output Observable. Each new `innerObservable`
         * instance emitted on the output Observable is concatenated with the previous
         * `innerObservable` instance.
         *
         * __Warning:__ if source values arrive endlessly and faster than their
         * corresponding inner Observables can complete, it will result in memory issues
         * as inner Observables amass in an unbounded buffer waiting for their turn to
         * be subscribed to.
         *
         * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
         * set to `1`.
         *
         * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // (results are not concurrent)
         * // For every click on the "document" it will emit values 0 to 3 spaced
         * // on a 1000ms interval
         * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
         *
         * @see {@link concat}
         * @see {@link concatAll}
         * @see {@link concatMap}
         * @see {@link mergeMapTo}
         * @see {@link switchMapTo}
         *
         * @param {ObservableInput} innerObservable An Observable to replace each value from
         * the source Observable.
         * @return {Observable} An observable of values merged together by joining the
         * passed observable with itself, one after the other, for each value emitted
         * from the source.
         * @method concatMapTo
         * @owner Observable
         */
        function concatMapTo(innerObservable) {
          return operators_1.concatMapTo(innerObservable)(this);
        }
        exports.concatMapTo = concatMapTo;
      },
      { "rxjs/operators": 547 },
    ],
    245: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Counts the number of emissions on the source and emits that number when the
         * source completes.
         *
         * <span class="informal">Tells how many values were emitted, when the source
         * completes.</span>
         *
         * <img src="./img/count.png" width="100%">
         *
         * `count` transforms an Observable that emits values into an Observable that
         * emits a single value that represents the number of values emitted by the
         * source Observable. If the source Observable terminates with an error, `count`
         * will pass this error notification along without emitting a value first. If
         * the source Observable does not terminate at all, `count` will neither emit
         * a value nor terminate. This operator takes an optional `predicate` function
         * as argument, in which case the output emission will represent the number of
         * source values that matched `true` with the `predicate`.
         *
         * @example <caption>Counts how many seconds have passed before the first click happened</caption>
         * var seconds = Rx.Observable.interval(1000);
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var secondsBeforeClick = seconds.takeUntil(clicks);
         * var result = secondsBeforeClick.count();
         * result.subscribe(x => console.log(x));
         *
         * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
         * var numbers = Rx.Observable.range(1, 7);
         * var result = numbers.count(i => i % 2 === 1);
         * result.subscribe(x => console.log(x));
         *
         * // Results in:
         * // 4
         *
         * @see {@link max}
         * @see {@link min}
         * @see {@link reduce}
         *
         * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
         * boolean function to select what values are to be counted. It is provided with
         * arguments of:
         * - `value`: the value from the source Observable.
         * - `index`: the (zero-based) "index" of the value from the source Observable.
         * - `source`: the source Observable instance itself.
         * @return {Observable} An Observable of one number that represents the count as
         * described above.
         * @method count
         * @owner Observable
         */
        function count(predicate) {
          return operators_1.count(predicate)(this);
        }
        exports.count = count;
      },
      { "rxjs/operators": 547 },
    ],
    246: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits a value from the source Observable only after a particular time span
         * determined by another Observable has passed without another source emission.
         *
         * <span class="informal">It's like {@link debounceTime}, but the time span of
         * emission silence is determined by a second Observable.</span>
         *
         * <img src="./img/debounce.png" width="100%">
         *
         * `debounce` delays values emitted by the source Observable, but drops previous
         * pending delayed emissions if a new value arrives on the source Observable.
         * This operator keeps track of the most recent value from the source
         * Observable, and spawns a duration Observable by calling the
         * `durationSelector` function. The value is emitted only when the duration
         * Observable emits a value or completes, and if no other value was emitted on
         * the source Observable since the duration Observable was spawned. If a new
         * value appears before the duration Observable emits, the previous value will
         * be dropped and will not be emitted on the output Observable.
         *
         * Like {@link debounceTime}, this is a rate-limiting operator, and also a
         * delay-like operator since output emissions do not necessarily occur at the
         * same time as they did on the source Observable.
         *
         * @example <caption>Emit the most recent click after a burst of clicks</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.debounce(() => Rx.Observable.interval(1000));
         * result.subscribe(x => console.log(x));
         *
         * @see {@link audit}
         * @see {@link debounceTime}
         * @see {@link delayWhen}
         * @see {@link throttle}
         *
         * @param {function(value: T): SubscribableOrPromise} durationSelector A function
         * that receives a value from the source Observable, for computing the timeout
         * duration for each source value, returned as an Observable or a Promise.
         * @return {Observable} An Observable that delays the emissions of the source
         * Observable by the specified duration Observable returned by
         * `durationSelector`, and may drop some values if they occur too frequently.
         * @method debounce
         * @owner Observable
         */
        function debounce(durationSelector) {
          return operators_1.debounce(durationSelector)(this);
        }
        exports.debounce = debounce;
      },
      { "rxjs/operators": 547 },
    ],
    247: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var operators_1 = require("rxjs/operators");
        /**
         * Emits a value from the source Observable only after a particular time span
         * has passed without another source emission.
         *
         * <span class="informal">It's like {@link delay}, but passes only the most
         * recent value from each burst of emissions.</span>
         *
         * <img src="./img/debounceTime.png" width="100%">
         *
         * `debounceTime` delays values emitted by the source Observable, but drops
         * previous pending delayed emissions if a new value arrives on the source
         * Observable. This operator keeps track of the most recent value from the
         * source Observable, and emits that only when `dueTime` enough time has passed
         * without any other value appearing on the source Observable. If a new value
         * appears before `dueTime` silence occurs, the previous value will be dropped
         * and will not be emitted on the output Observable.
         *
         * This is a rate-limiting operator, because it is impossible for more than one
         * value to be emitted in any time window of duration `dueTime`, but it is also
         * a delay-like operator since output emissions do not occur at the same time as
         * they did on the source Observable. Optionally takes a {@link IScheduler} for
         * managing timers.
         *
         * @example <caption>Emit the most recent click after a burst of clicks</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.debounceTime(1000);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link auditTime}
         * @see {@link debounce}
         * @see {@link delay}
         * @see {@link sampleTime}
         * @see {@link throttleTime}
         *
         * @param {number} dueTime The timeout duration in milliseconds (or the time
         * unit determined internally by the optional `scheduler`) for the window of
         * time required to wait for emission silence before emitting the most recent
         * source value.
         * @param {Scheduler} [scheduler=asyncScheduler] The {@link SchedulerLike} to use for
         * managing the timers that handle the timeout for each value.
         * @return {Observable} An Observable that delays the emissions of the source
         * Observable by the specified `dueTime`, and may drop some values if they occur
         * too frequently.
         * @method debounceTime
         * @owner Observable
         */
        function debounceTime(dueTime, scheduler) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          return operators_1.debounceTime(dueTime, scheduler)(this);
        }
        exports.debounceTime = debounceTime;
      },
      { rxjs: 333, "rxjs/operators": 547 },
    ],
    248: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Emits a given value if the source Observable completes without emitting any
         * `next` value, otherwise mirrors the source Observable.
         *
         * <span class="informal">If the source Observable turns out to be empty, then
         * this operator will emit a default value.</span>
         *
         * <img src="./img/defaultIfEmpty.png" width="100%">
         *
         * `defaultIfEmpty` emits the values emitted by the source Observable or a
         * specified default value if the source Observable is empty (completes without
         * having emitted any `next` value).
         *
         * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
         * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
         * result.subscribe(x => console.log(x));
         *
         * @see {@link empty}
         * @see {@link last}
         *
         * @param {any} [defaultValue=null] The default value used if the source
         * Observable is empty.
         * @return {Observable} An Observable that emits either the specified
         * `defaultValue` if the source Observable emits no items, or the values emitted
         * by the source Observable.
         * @method defaultIfEmpty
         * @owner Observable
         */
        function defaultIfEmpty(defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = null;
          }
          return operators_1.defaultIfEmpty(defaultValue)(this);
        }
        exports.defaultIfEmpty = defaultIfEmpty;
      },
      { "rxjs/operators": 547 },
    ],
    249: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var operators_1 = require("rxjs/operators");
        /**
         * Delays the emission of items from the source Observable by a given timeout or
         * until a given Date.
         *
         * <span class="informal">Time shifts each item by some specified amount of
         * milliseconds.</span>
         *
         * <img src="./img/delay.png" width="100%">
         *
         * If the delay argument is a Number, this operator time shifts the source
         * Observable by that amount of time expressed in milliseconds. The relative
         * time intervals between the values are preserved.
         *
         * If the delay argument is a Date, this operator time shifts the start of the
         * Observable execution until the given date occurs.
         *
         * @example <caption>Delay each click by one second</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
         * delayedClicks.subscribe(x => console.log(x));
         *
         * @example <caption>Delay all clicks until a future date happens</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var date = new Date('March 15, 2050 12:00:00'); // in the future
         * var delayedClicks = clicks.delay(date); // click emitted only after that date
         * delayedClicks.subscribe(x => console.log(x));
         *
         * @see {@link debounceTime}
         * @see {@link delayWhen}
         *
         * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
         * a `Date` until which the emission of the source items is delayed.
         * @param {Scheduler} [scheduler=asyncScheduler] The SchedulerLike to use for
         * managing the timers that handle the time-shift for each item.
         * @return {Observable} An Observable that delays the emissions of the source
         * Observable by the specified timeout or Date.
         * @method delay
         * @owner Observable
         */
        function delay(delay, scheduler) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          return operators_1.delay(delay, scheduler)(this);
        }
        exports.delay = delay;
      },
      { rxjs: 333, "rxjs/operators": 547 },
    ],
    250: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Delays the emission of items from the source Observable by a given time span
         * determined by the emissions of another Observable.
         *
         * <span class="informal">It's like {@link delay}, but the time span of the
         * delay duration is determined by a second Observable.</span>
         *
         * <img src="./img/delayWhen.png" width="100%">
         *
         * `delayWhen` time shifts each emitted value from the source Observable by a
         * time span determined by another Observable. When the source emits a value,
         * the `delayDurationSelector` function is called with the source value as
         * argument, and should return an Observable, called the "duration" Observable.
         * The source value is emitted on the output Observable only when the duration
         * Observable emits a value or completes.
         *
         * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
         * is an Observable. When `subscriptionDelay` emits its first value or
         * completes, the source Observable is subscribed to and starts behaving like
         * described in the previous paragraph. If `subscriptionDelay` is not provided,
         * `delayWhen` will subscribe to the source Observable as soon as the output
         * Observable is subscribed.
         *
         * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var delayedClicks = clicks.delayWhen(event =>
         *   Rx.Observable.interval(Math.random() * 5000)
         * );
         * delayedClicks.subscribe(x => console.log(x));
         *
         * @see {@link debounce}
         * @see {@link delay}
         *
         * @param {function(value: T): Observable} delayDurationSelector A function that
         * returns an Observable for each value emitted by the source Observable, which
         * is then used to delay the emission of that item on the output Observable
         * until the Observable returned from this function emits a value.
         * @param {Observable} subscriptionDelay An Observable that triggers the
         * subscription to the source Observable once it emits any value.
         * @return {Observable} An Observable that delays the emissions of the source
         * Observable by an amount of time specified by the Observable returned by
         * `delayDurationSelector`.
         * @method delayWhen
         * @owner Observable
         */
        function delayWhen(delayDurationSelector, subscriptionDelay) {
          return operators_1.delayWhen(
            delayDurationSelector,
            subscriptionDelay
          )(this);
        }
        exports.delayWhen = delayWhen;
      },
      { "rxjs/operators": 547 },
    ],
    251: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Converts an Observable of {@link Notification} objects into the emissions
         * that they represent.
         *
         * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
         * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
         *
         * <img src="./img/dematerialize.png" width="100%">
         *
         * `dematerialize` is assumed to operate an Observable that only emits
         * {@link Notification} objects as `next` emissions, and does not emit any
         * `error`. Such Observable is the output of a `materialize` operation. Those
         * notifications are then unwrapped using the metadata they contain, and emitted
         * as `next`, `error`, and `complete` on the output Observable.
         *
         * Use this operator in conjunction with {@link materialize}.
         *
         * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
         * var notifA = new Rx.Notification('N', 'A');
         * var notifB = new Rx.Notification('N', 'B');
         * var notifE = new Rx.Notification('E', void 0,
         *   new TypeError('x.toUpperCase is not a function')
         * );
         * var materialized = Rx.Observable.of(notifA, notifB, notifE);
         * var upperCase = materialized.dematerialize();
         * upperCase.subscribe(x => console.log(x), e => console.error(e));
         *
         * // Results in:
         * // A
         * // B
         * // TypeError: x.toUpperCase is not a function
         *
         * @see {@link Notification}
         * @see {@link materialize}
         *
         * @return {Observable} An Observable that emits items and notifications
         * embedded in Notification objects emitted by the source Observable.
         * @method dematerialize
         * @owner Observable
         */
        function dematerialize() {
          return operators_1.dematerialize()(this);
        }
        exports.dematerialize = dematerialize;
      },
      { "rxjs/operators": 547 },
    ],
    252: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
         *
         * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
         * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
         * source observable directly with an equality check against previous values.
         *
         * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
         *
         * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
         * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
         * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
         * that the internal `Set` can be "flushed", basically clearing it of values.
         *
         * @example <caption>A simple example with numbers</caption>
         * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
         *   .distinct()
         *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
         *
         * @example <caption>An example using a keySelector function</caption>
         * interface Person {
         *    age: number,
         *    name: string
         * }
         *
         * Observable.of<Person>(
         *     { age: 4, name: 'Foo'},
         *     { age: 7, name: 'Bar'},
         *     { age: 5, name: 'Foo'})
         *     .distinct((p: Person) => p.name)
         *     .subscribe(x => console.log(x));
         *
         * // displays:
         * // { age: 4, name: 'Foo' }
         * // { age: 7, name: 'Bar' }
         *
         * @see {@link distinctUntilChanged}
         * @see {@link distinctUntilKeyChanged}
         *
         * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
         * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
         * @return {Observable} An Observable that emits items from the source Observable with distinct values.
         * @method distinct
         * @owner Observable
         */
        function distinct(keySelector, flushes) {
          return operators_1.distinct(keySelector, flushes)(this);
        }
        exports.distinct = distinct;
      },
      { "rxjs/operators": 547 },
    ],
    253: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
         *
         * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
         *
         * If a comparator function is not provided, an equality check is used by default.
         *
         * @example <caption>A simple example with numbers</caption>
         * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
         *   .distinctUntilChanged()
         *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
         *
         * @example <caption>An example using a compare function</caption>
         * interface Person {
         *    age: number,
         *    name: string
         * }
         *
         * Observable.of<Person>(
         *     { age: 4, name: 'Foo'},
         *     { age: 7, name: 'Bar'},
         *     { age: 5, name: 'Foo'},
         *     { age: 6, name: 'Foo'})
         *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
         *     .subscribe(x => console.log(x));
         *
         * // displays:
         * // { age: 4, name: 'Foo' }
         * // { age: 7, name: 'Bar' }
         * // { age: 5, name: 'Foo' }
         *
         * @see {@link distinct}
         * @see {@link distinctUntilKeyChanged}
         *
         * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
         * @return {Observable} An Observable that emits items from the source Observable with distinct values.
         * @method distinctUntilChanged
         * @owner Observable
         */
        function distinctUntilChanged(compare, keySelector) {
          return operators_1.distinctUntilChanged(compare, keySelector)(this);
        }
        exports.distinctUntilChanged = distinctUntilChanged;
      },
      { "rxjs/operators": 547 },
    ],
    254: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
         * using a property accessed by using the key provided to check if the two items are distinct.
         *
         * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
         *
         * If a comparator function is not provided, an equality check is used by default.
         *
         * @example <caption>An example comparing the name of persons</caption>
         *
         *  interface Person {
         *     age: number,
         *     name: string
         *  }
         *
         * Observable.of<Person>(
         *     { age: 4, name: 'Foo'},
         *     { age: 7, name: 'Bar'},
         *     { age: 5, name: 'Foo'},
         *     { age: 6, name: 'Foo'})
         *     .distinctUntilKeyChanged('name')
         *     .subscribe(x => console.log(x));
         *
         * // displays:
         * // { age: 4, name: 'Foo' }
         * // { age: 7, name: 'Bar' }
         * // { age: 5, name: 'Foo' }
         *
         * @example <caption>An example comparing the first letters of the name</caption>
         *
         * interface Person {
         *     age: number,
         *     name: string
         *  }
         *
         * Observable.of<Person>(
         *     { age: 4, name: 'Foo1'},
         *     { age: 7, name: 'Bar'},
         *     { age: 5, name: 'Foo2'},
         *     { age: 6, name: 'Foo3'})
         *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
         *     .subscribe(x => console.log(x));
         *
         * // displays:
         * // { age: 4, name: 'Foo1' }
         * // { age: 7, name: 'Bar' }
         * // { age: 5, name: 'Foo2' }
         *
         * @see {@link distinct}
         * @see {@link distinctUntilChanged}
         *
         * @param {string} key String key for object property lookup on each item.
         * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
         * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
         * @method distinctUntilKeyChanged
         * @owner Observable
         */
        // tslint:disable-next-line:max-line-length
        function distinctUntilKeyChanged(key, compare) {
          return operators_1.distinctUntilKeyChanged(key, compare)(this);
        }
        exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
      },
      { "rxjs/operators": 547 },
    ],
    255: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Perform a side effect for every emission on the source Observable, but return
         * an Observable that is identical to the source.
         *
         * <span class="informal">Intercepts each emission on the source and runs a
         * function, but returns an output which is identical to the source as long as errors don't occur.</span>
         *
         * <img src="./img/do.png" width="100%">
         *
         * Returns a mirrored Observable of the source Observable, but modified so that
         * the provided Observer is called to perform a side effect for every value,
         * error, and completion emitted by the source. Any errors that are thrown in
         * the aforementioned Observer or handlers are safely sent down the error path
         * of the output Observable.
         *
         * This operator is useful for debugging your Observables for the correct values
         * or performing other side effects.
         *
         * Note: this is different to a `subscribe` on the Observable. If the Observable
         * returned by `do` is not subscribed, the side effects specified by the
         * Observer will never happen. `do` therefore simply spies on existing
         * execution, it does not trigger an execution to happen like `subscribe` does.
         *
         * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var positions = clicks
         *   .do(ev => console.log(ev))
         *   .map(ev => ev.clientX);
         * positions.subscribe(x => console.log(x));
         *
         * @see {@link map}
         * @see {@link subscribe}
         *
         * @param {Observer|function} [nextOrObserver] A normal Observer object or a
         * callback for `next`.
         * @param {function} [error] Callback for errors in the source.
         * @param {function} [complete] Callback for the completion of the source.
         * @return {Observable} An Observable identical to the source, but runs the
         * specified Observer or callback(s) for each item.
         * @method do
         * @name do
         * @owner Observable
         */
        function _do(nextOrObserver, error, complete) {
          return operators_1.tap(nextOrObserver, error, complete)(this);
        }
        exports._do = _do;
      },
      { "rxjs/operators": 547 },
    ],
    256: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits the single value at the specified `index` in a sequence of emissions
         * from the source Observable.
         *
         * <span class="informal">Emits only the i-th value, then completes.</span>
         *
         * <img src="./img/elementAt.png" width="100%">
         *
         * `elementAt` returns an Observable that emits the item at the specified
         * `index` in the source Observable, or a default value if that `index` is out
         * of range and the `default` argument is provided. If the `default` argument is
         * not given and the `index` is out of range, the output Observable will emit an
         * `ArgumentOutOfRangeError` error.
         *
         * @example <caption>Emit only the third click event</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.elementAt(2);
         * result.subscribe(x => console.log(x));
         *
         * // Results in:
         * // click 1 = nothing
         * // click 2 = nothing
         * // click 3 = MouseEvent object logged to console
         *
         * @see {@link first}
         * @see {@link last}
         * @see {@link skip}
         * @see {@link single}
         * @see {@link take}
         *
         * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
         * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
         * Observable has completed before emitting the i-th `next` notification.
         *
         * @param {number} index Is the number `i` for the i-th source emission that has
         * happened since the subscription, starting from the number `0`.
         * @param {T} [defaultValue] The default value returned for missing indices.
         * @return {Observable} An Observable that emits a single item, if it is found.
         * Otherwise, will emit the default value if given. If not, then emits an error.
         * @method elementAt
         * @owner Observable
         */
        function elementAt(index, defaultValue) {
          return operators_1.elementAt.apply(undefined, arguments)(this);
        }
        exports.elementAt = elementAt;
      },
      { "rxjs/operators": 547 },
    ],
    257: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
         *
         * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
         *  Observable.of(1, 2, 3, 4, 5, 6)
         *     .every(x => x < 5)
         *     .subscribe(x => console.log(x)); // -> false
         *
         * @param {function} predicate A function for determining if an item meets a specified condition.
         * @param {any} [thisArg] Optional object to use for `this` in the callback.
         * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
         * @method every
         * @owner Observable
         */
        function every(predicate, thisArg) {
          return operators_1.every(predicate, thisArg)(this);
        }
        exports.every = every;
      },
      { "rxjs/operators": 547 },
    ],
    258: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Converts a higher-order Observable into a first-order Observable by dropping
         * inner Observables while the previous inner Observable has not yet completed.
         *
         * <span class="informal">Flattens an Observable-of-Observables by dropping the
         * next inner Observables while the current inner is still executing.</span>
         *
         * <img src="./img/exhaust.png" width="100%">
         *
         * `exhaust` subscribes to an Observable that emits Observables, also known as a
         * higher-order Observable. Each time it observes one of these emitted inner
         * Observables, the output Observable begins emitting the items emitted by that
         * inner Observable. So far, it behaves like {@link mergeAll}. However,
         * `exhaust` ignores every new inner Observable if the previous Observable has
         * not yet completed. Once that one completes, it will accept and flatten the
         * next inner Observable and repeat this process.
         *
         * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));
         * var result = higherOrder.exhaust();
         * result.subscribe(x => console.log(x));
         *
         * @see {@link combineAll}
         * @see {@link concatAll}
         * @see {@link switch}
         * @see {@link mergeAll}
         * @see {@link exhaustMap}
         * @see {@link zipAll}
         *
         * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
         * exclusively until it completes before subscribing to the next.
         */
        function exhaust() {
          return operators_1.exhaust()(this);
        }
        exports.exhaust = exhaust;
      },
      { "rxjs/operators": 547 },
    ],
    259: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Projects each source value to an Observable which is merged in the output
         * Observable only if the previous projected Observable has completed.
         *
         * <span class="informal">Maps each value to an Observable, then flattens all of
         * these inner Observables using {@link exhaust}.</span>
         *
         * <img src="./img/exhaustMap.png" width="100%">
         *
         * Returns an Observable that emits items based on applying a function that you
         * supply to each item emitted by the source Observable, where that function
         * returns an (so-called "inner") Observable. When it projects a source value to
         * an Observable, the output Observable begins emitting the items emitted by
         * that projected Observable. However, `exhaustMap` ignores every new projected
         * Observable if the previous projected Observable has not yet completed. Once
         * that one completes, it will accept and flatten the next projected Observable
         * and repeat this process.
         *
         * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
         * var clicks = fromEvent(document, 'click');
         * var result = clicks.pipe(exhaustMap((ev) => Rx.Observable.interval(1000).take(5)));
         * result.subscribe(x => console.log(x));
         *
         * @see {@link concatMap}
         * @see {@link exhaust}
         * @see {@link mergeMap}
         * @see {@link switchMap}
         *
         * @param {function(value: T, ?index: number): ObservableInput} project A function
         * that, when applied to an item emitted by the source Observable, returns an
         * Observable.
         * @return {Observable} An Observable containing projected Observables
         * of each item of the source, ignoring projected Observables that start before
         * their preceding Observable has completed.
         */
        function exhaustMap(project) {
          return operators_1.exhaustMap(project)(this);
        }
        exports.exhaustMap = exhaustMap;
      },
      { "rxjs/operators": 547 },
    ],
    260: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Recursively projects each source value to an Observable which is merged in
         * the output Observable.
         *
         * <span class="informal">It's similar to {@link mergeMap}, but applies the
         * projection function to every source value as well as every output value.
         * It's recursive.</span>
         *
         * <img src="./img/expand.png" width="100%">
         *
         * Returns an Observable that emits items based on applying a function that you
         * supply to each item emitted by the source Observable, where that function
         * returns an Observable, and then merging those resulting Observables and
         * emitting the results of this merger. *Expand* will re-emit on the output
         * Observable every source value. Then, each output value is given to the
         * `project` function which returns an inner Observable to be merged on the
         * output Observable. Those output values resulting from the projection are also
         * given to the `project` function to produce new output values. This is how
         * *expand* behaves recursively.
         *
         * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var powersOfTwo = clicks
         *   .mapTo(1)
         *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
         *   .take(10);
         * powersOfTwo.subscribe(x => console.log(x));
         *
         * @see {@link mergeMap}
         * @see {@link mergeScan}
         *
         * @param {function(value: T, index: number) => Observable} project A function
         * that, when applied to an item emitted by the source or the output Observable,
         * returns an Observable.
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
         * Observables being subscribed to concurrently.
         * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
         * each projected inner Observable.
         * @return {Observable} An Observable that emits the source values and also
         * result of applying the projection function to each value emitted on the
         * output Observable and and merging the results of the Observables obtained
         * from this transformation.
         * @method expand
         * @owner Observable
         */
        function expand(project, concurrent, scheduler) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          if (scheduler === void 0) {
            scheduler = undefined;
          }
          concurrent =
            (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
          return operators_1.expand(project, concurrent, scheduler)(this);
        }
        exports.expand = expand;
      },
      { "rxjs/operators": 547 },
    ],
    261: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Filter items emitted by the source Observable by only emitting those that
         * satisfy a specified predicate.
         *
         * <span class="informal">Like
         * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
         * it only emits a value from the source if it passes a criterion function.</span>
         *
         * <img src="./img/filter.png" width="100%">
         *
         * Similar to the well-known `Array.prototype.filter` method, this operator
         * takes values from the source Observable, passes them through a `predicate`
         * function and only emits those values that yielded `true`.
         *
         * @example <caption>Emit only click events whose target was a DIV element</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
         * clicksOnDivs.subscribe(x => console.log(x));
         *
         * @see {@link distinct}
         * @see {@link distinctUntilChanged}
         * @see {@link distinctUntilKeyChanged}
         * @see {@link ignoreElements}
         * @see {@link partition}
         * @see {@link skip}
         *
         * @param {function(value: T, index: number): boolean} predicate A function that
         * evaluates each value emitted by the source Observable. If it returns `true`,
         * the value is emitted, if `false` the value is not passed to the output
         * Observable. The `index` parameter is the number `i` for the i-th source
         * emission that has happened since the subscription, starting from the number
         * `0`.
         * @param {any} [thisArg] An optional argument to determine the value of `this`
         * in the `predicate` function.
         * @return {Observable} An Observable of values from the source that were
         * allowed by the `predicate` function.
         * @method filter
         * @owner Observable
         */
        function filter(predicate, thisArg) {
          return operators_1.filter(predicate, thisArg)(this);
        }
        exports.filter = filter;
      },
      { "rxjs/operators": 547 },
    ],
    262: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that mirrors the source Observable, but will call a specified function when
         * the source terminates on complete, error or unsubscribe.
         *
         * <span class="informal">Ensure a given function will be called when a stream ends, no matter why it ended.</span>
         *
         * `finally` method accepts as a single parameter a function. This function does not accept any parameters and
         * should not return anything. It will be called whenever source Observable completes, errors or is unsubscribed,
         * which makes it good candidate to perform any necessary clean up or side effects when Observable terminates,
         * no matter how or why it terminated.
         *
         * Observable returned by `finally` will simply mirror source Observable - each time it is subscribed, source
         * Observable will be subscribed underneath.
         *
         * Note that behavior of `finally` will be repeated per every subscription, so if resulting Observable has
         * many subscribers, function passed to `finally` might be potentially called multiple times.
         *
         * Remember also that `finally` differs quite a lot from passing complete or error handler to {@link subscribe}. It will
         * return an Observable which can be further chained, while `subscribe` returns Subscription, basically ending Observable
         * chain. Function passed to `finally` will be called also when consumer of resulting Observable unsubscribes from it,
         * while handlers passed to `subscribe` will not (even complete handler). But most importantly, `finally` does not start
         * an execution of source Observable, like `subscribe` does, allowing you to set up all necessary hooks before
         * passing Observable further, even without specific knowledge how or when it will be used.
         *
         *
         * @example <caption>Call finally after complete notification</caption>
         * Rx.Observable.of(1, 2, 3)
         * .finally(() => console.log('I was finalized!'))
         * .map(x => x * 2) // `finally` returns an Observable, so we still can chain operators.
         * .subscribe(
         *   val => console.log(val),
         *   err => {},
         *   () => console.log('I completed!')
         * );
         *
         * // Logs:
         * // 1
         * // 2
         * // 3
         * // "I completed!"
         * // "I was finalized!"
         *
         *
         *
         * @example <caption>Call finally after consumer unsubscribes</caption>
         * const o = Rx.Observable.interval(1000)
         * .finally(() => console.log('Timer stopped'));
         *
         * const subscription = o.subscribe(
         *   val => console.log(val),
         *   err => {},
         *   () => console.log('Complete!') // Will not be called, since complete handler
         * );                               // does not react to unsubscription, just to
         *                                  // complete notification sent by the Observable itself.
         *
         * setTimeout(() => subscription.unsubscribe(), 2500);
         *
         * // Logs:
         * // 0 after 1s
         * // 1 after 2s
         * // "Timer stopped" after 2.5s
         *
         * @see {@link using}
         *
         * @param {function} callback Function to be called when source terminates (completes, errors or is unsubscribed).
         * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
         * @method finally
         * @name finally
         * @owner Observable
         */
        function _finally(callback) {
          return operators_1.finalize(callback)(this);
        }
        exports._finally = _finally;
      },
      { "rxjs/operators": 547 },
    ],
    263: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Emits only the first value emitted by the source Observable that meets some
         * condition.
         *
         * <span class="informal">Finds the first value that passes some test and emits
         * that.</span>
         *
         * <img src="./img/find.png" width="100%">
         *
         * `find` searches for the first item in the source Observable that matches the
         * specified condition embodied by the `predicate`, and returns the first
         * occurrence in the source. Unlike {@link first}, the `predicate` is required
         * in `find`, and does not emit an error if a valid value is not found.
         *
         * @example <caption>Find and emit the first click that happens on a DIV element</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.find(ev => ev.target.tagName === 'DIV');
         * result.subscribe(x => console.log(x));
         *
         * @see {@link filter}
         * @see {@link first}
         * @see {@link findIndex}
         * @see {@link take}
         *
         * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
         * A function called with each item to test for condition matching.
         * @param {any} [thisArg] An optional argument to determine the value of `this`
         * in the `predicate` function.
         * @return {Observable<T>} An Observable of the first item that matches the
         * condition.
         * @method find
         * @owner Observable
         */
        function find(predicate, thisArg) {
          return operators_1.find(predicate, thisArg)(this);
        }
        exports.find = find;
      },
      { "rxjs/operators": 547 },
    ],
    264: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits only the index of the first value emitted by the source Observable that
         * meets some condition.
         *
         * <span class="informal">It's like {@link find}, but emits the index of the
         * found value, not the value itself.</span>
         *
         * <img src="./img/findIndex.png" width="100%">
         *
         * `findIndex` searches for the first item in the source Observable that matches
         * the specified condition embodied by the `predicate`, and returns the
         * (zero-based) index of the first occurrence in the source. Unlike
         * {@link first}, the `predicate` is required in `findIndex`, and does not emit
         * an error if a valid value is not found.
         *
         * @example <caption>Emit the index of first click that happens on a DIV element</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
         * result.subscribe(x => console.log(x));
         *
         * @see {@link filter}
         * @see {@link find}
         * @see {@link first}
         * @see {@link take}
         *
         * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
         * A function called with each item to test for condition matching.
         * @param {any} [thisArg] An optional argument to determine the value of `this`
         * in the `predicate` function.
         * @return {Observable} An Observable of the index of the first item that
         * matches the condition.
         * @method find
         * @owner Observable
         */
        function findIndex(predicate, thisArg) {
          return operators_1.findIndex(predicate, thisArg)(this);
        }
        exports.findIndex = findIndex;
      },
      { "rxjs/operators": 547 },
    ],
    265: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Emits only the first value (or the first value that meets some condition)
         * emitted by the source Observable.
         *
         * <span class="informal">Emits only the first value. Or emits only the first
         * value that passes some test.</span>
         *
         * <img src="./img/first.png" width="100%">
         *
         * If called with no arguments, `first` emits the first value of the source
         * Observable, then completes. If called with a `predicate` function, `first`
         * emits the first value of the source that matches the specified condition. It
         * may also take a `resultSelector` function to produce the output value from
         * the input value, and a `defaultValue` to emit in case the source completes
         * before it is able to emit a valid value. Throws an error if `defaultValue`
         * was not provided and a matching element is not found.
         *
         * @example <caption>Emit only the first click that happens on the DOM</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.first();
         * result.subscribe(x => console.log(x));
         *
         * @example <caption>Emits the first click that happens on a DIV</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.first(ev => ev.target.tagName === 'DIV');
         * result.subscribe(x => console.log(x));
         *
         * @see {@link filter}
         * @see {@link find}
         * @see {@link take}
         *
         * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
         * callback if the Observable completes before any `next` notification was sent.
         *
         * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
         * An optional function called with each item to test for condition matching.
         * @param {T} [defaultValue] The default value emitted in case no valid value
         * was found on the source.
         * @return {Observable<T>} An Observable of the first item that matches the
         * condition.
         * @method first
         * @owner Observable
         */
        function first() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return operators_1.first.apply(void 0, args)(this);
        }
        exports.first = first;
      },
      { "rxjs/operators": 547 },
    ],
    266: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Groups the items emitted by an Observable according to a specified criterion,
         * and emits these grouped items as `GroupedObservables`, one
         * {@link GroupedObservable} per group.
         *
         * <img src="./img/groupBy.png" width="100%">
         *
         * @example <caption>Group objects by id and return as array</caption>
         * Observable.of<Obj>({id: 1, name: 'aze1'},
         *                    {id: 2, name: 'sf2'},
         *                    {id: 2, name: 'dg2'},
         *                    {id: 1, name: 'erg1'},
         *                    {id: 1, name: 'df1'},
         *                    {id: 2, name: 'sfqfb2'},
         *                    {id: 3, name: 'qfs3'},
         *                    {id: 2, name: 'qsgqsfg2'}
         *     )
         *     .groupBy(p => p.id)
         *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
         *     .subscribe(p => console.log(p));
         *
         * // displays:
         * // [ { id: 1, name: 'aze1' },
         * //   { id: 1, name: 'erg1' },
         * //   { id: 1, name: 'df1' } ]
         * //
         * // [ { id: 2, name: 'sf2' },
         * //   { id: 2, name: 'dg2' },
         * //   { id: 2, name: 'sfqfb2' },
         * //   { id: 2, name: 'qsgqsfg2' } ]
         * //
         * // [ { id: 3, name: 'qfs3' } ]
         *
         * @example <caption>Pivot data on the id field</caption>
         * Observable.of<Obj>({id: 1, name: 'aze1'},
         *                    {id: 2, name: 'sf2'},
         *                    {id: 2, name: 'dg2'},
         *                    {id: 1, name: 'erg1'},
         *                    {id: 1, name: 'df1'},
         *                    {id: 2, name: 'sfqfb2'},
         *                    {id: 3, name: 'qfs1'},
         *                    {id: 2, name: 'qsgqsfg2'}
         *                   )
         *     .groupBy(p => p.id, p => p.name)
         *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
         *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
         *     .subscribe(p => console.log(p));
         *
         * // displays:
         * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
         * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
         * // { id: 3, values: [ 'qfs1' ] }
         *
         * @param {function(value: T): K} keySelector A function that extracts the key
         * for each item.
         * @param {function(value: T): R} [elementSelector] A function that extracts the
         * return element for each item.
         * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
         * A function that returns an Observable to determine how long each group should
         * exist.
         * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
         * GroupedObservables, each of which corresponds to a unique key value and each
         * of which emits those items from the source Observable that share that key
         * value.
         * @method groupBy
         * @owner Observable
         */
        function groupBy(
          keySelector,
          elementSelector,
          durationSelector,
          subjectSelector
        ) {
          return operators_1.groupBy(
            keySelector,
            elementSelector,
            durationSelector,
            subjectSelector
          )(this);
        }
        exports.groupBy = groupBy;
      },
      { "rxjs/operators": 547 },
    ],
    267: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
         *
         * <img src="./img/ignoreElements.png" width="100%">
         *
         * @return {Observable} An empty Observable that only calls `complete`
         * or `error`, based on which one is called by the source Observable.
         * @method ignoreElements
         * @owner Observable
         */
        function ignoreElements() {
          return operators_1.ignoreElements()(this);
        }
        exports.ignoreElements = ignoreElements;
      },
      { "rxjs/operators": 547 },
    ],
    268: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.
         *
         * <img src="./img/isEmpty.png" width="100%">
         *
         * @return {Observable} An Observable that emits a Boolean.
         * @method isEmpty
         * @owner Observable
         */
        function isEmpty() {
          return operators_1.isEmpty()(this);
        }
        exports.isEmpty = isEmpty;
      },
      { "rxjs/operators": 547 },
    ],
    269: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Returns an Observable that emits only the last item emitted by the source Observable.
         * It optionally takes a predicate function as a parameter, in which case, rather than emitting
         * the last item from the source Observable, the resulting Observable will emit the last item
         * from the source Observable that satisfies the predicate.
         *
         * <img src="./img/last.png" width="100%">
         *
         * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
         * callback if the Observable completes before any `next` notification was sent.
         * @param {function} [predicate] - The condition any source emitted item has to satisfy.
         * @param {any} [defaultValue] - The default value to use if the predicate isn't
         * satisfied, or no values were emitted (if no predicate).
         * @return {Observable} An Observable that emits only the last item satisfying the given condition
         * from the source, or an NoSuchElementException if no such items are emitted.
         * @throws - Throws if no items that match the predicate are emitted by the source Observable.
         * @method last
         * @owner Observable
         */
        function last() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return operators_1.last.apply(void 0, args)(this);
        }
        exports.last = last;
      },
      { "rxjs/operators": 547 },
    ],
    270: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * @param func
         * @return {Observable<R>}
         * @method let
         * @owner Observable
         */
        function letProto(func) {
          return func(this);
        }
        exports.letProto = letProto;
      },
      {},
    ],
    271: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Applies a given `project` function to each value emitted by the source
         * Observable, and emits the resulting values as an Observable.
         *
         * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
         * it passes each source value through a transformation function to get
         * corresponding output values.</span>
         *
         * <img src="./img/map.png" width="100%">
         *
         * Similar to the well known `Array.prototype.map` function, this operator
         * applies a projection to each value and emits that projection in the output
         * Observable.
         *
         * @example <caption>Map every click to the clientX position of that click</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var positions = clicks.map(ev => ev.clientX);
         * positions.subscribe(x => console.log(x));
         *
         * @see {@link mapTo}
         * @see {@link pluck}
         *
         * @param {function(value: T, index: number): R} project The function to apply
         * to each `value` emitted by the source Observable. The `index` parameter is
         * the number `i` for the i-th emission that has happened since the
         * subscription, starting from the number `0`.
         * @param {any} [thisArg] An optional argument to define what `this` is in the
         * `project` function.
         * @return {Observable<R>} An Observable that emits the values from the source
         * Observable transformed by the given `project` function.
         * @method map
         * @owner Observable
         */
        function map(project, thisArg) {
          return operators_1.map(project, thisArg)(this);
        }
        exports.map = map;
      },
      { "rxjs/operators": 547 },
    ],
    272: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits the given constant value on the output Observable every time the source
         * Observable emits a value.
         *
         * <span class="informal">Like {@link map}, but it maps every source value to
         * the same output value every time.</span>
         *
         * <img src="./img/mapTo.png" width="100%">
         *
         * Takes a constant `value` as argument, and emits that whenever the source
         * Observable emits a value. In other words, ignores the actual source value,
         * and simply uses the emission moment to know when to emit the given `value`.
         *
         * @example <caption>Map every click to the string 'Hi'</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var greetings = clicks.mapTo('Hi');
         * greetings.subscribe(x => console.log(x));
         *
         * @see {@link map}
         *
         * @param {any} value The value to map each source value to.
         * @return {Observable} An Observable that emits the given `value` every time
         * the source Observable emits something.
         * @method mapTo
         * @owner Observable
         */
        function mapTo(value) {
          return operators_1.mapTo(value)(this);
        }
        exports.mapTo = mapTo;
      },
      { "rxjs/operators": 547 },
    ],
    273: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Represents all of the notifications from the source Observable as `next`
         * emissions marked with their original types within {@link Notification}
         * objects.
         *
         * <span class="informal">Wraps `next`, `error` and `complete` emissions in
         * {@link Notification} objects, emitted as `next` on the output Observable.
         * </span>
         *
         * <img src="./img/materialize.png" width="100%">
         *
         * `materialize` returns an Observable that emits a `next` notification for each
         * `next`, `error`, or `complete` emission of the source Observable. When the
         * source Observable emits `complete`, the output Observable will emit `next` as
         * a Notification of type "complete", and then it will emit `complete` as well.
         * When the source Observable emits `error`, the output will emit `next` as a
         * Notification of type "error", and then `complete`.
         *
         * This operator is useful for producing metadata of the source Observable, to
         * be consumed as `next` emissions. Use it in conjunction with
         * {@link dematerialize}.
         *
         * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
         * var letters = Rx.Observable.of('a', 'b', 13, 'd');
         * var upperCase = letters.map(x => x.toUpperCase());
         * var materialized = upperCase.materialize();
         * materialized.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
         * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
         * // - Notification {kind: "E", value: undefined, error: TypeError:
         * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
         * //   [as project] (http://1, hasValue: false}
         *
         * @see {@link Notification}
         * @see {@link dematerialize}
         *
         * @return {Observable<Notification<T>>} An Observable that emits
         * {@link Notification} objects that wrap the original emissions from the source
         * Observable with metadata.
         * @method materialize
         * @owner Observable
         */
        function materialize() {
          return operators_1.materialize()(this);
        }
        exports.materialize = materialize;
      },
      { "rxjs/operators": 547 },
    ],
    274: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
         * and when source Observable completes it emits a single item: the item with the largest value.
         *
         * <img src="./img/max.png" width="100%">
         *
         * @example <caption>Get the maximal value of a series of numbers</caption>
         * Rx.Observable.of(5, 4, 7, 2, 8)
         *   .max()
         *   .subscribe(x => console.log(x)); // -> 8
         *
         * @example <caption>Use a comparer function to get the maximal item</caption>
         * interface Person {
         *   age: number,
         *   name: string
         * }
         * Observable.of<Person>({age: 7, name: 'Foo'},
         *                       {age: 5, name: 'Bar'},
         *                       {age: 9, name: 'Beer'})
         *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
         *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
         * }
         *
         * @see {@link min}
         *
         * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
         * value of two items.
         * @return {Observable} An Observable that emits item with the largest value.
         * @method max
         * @owner Observable
         */
        function max(comparer) {
          return operators_1.max(comparer)(this);
        }
        exports.max = max;
      },
      { "rxjs/operators": 547 },
    ],
    275: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        /* tslint:enable:max-line-length */
        /**
         * Creates an output Observable which concurrently emits all values from every
         * given input Observable.
         *
         * <span class="informal">Flattens multiple Observables together by blending
         * their values into one Observable.</span>
         *
         * <img src="./img/merge.png" width="100%">
         *
         * `merge` subscribes to each given input Observable (either the source or an
         * Observable given as argument), and simply forwards (without doing any
         * transformation) all the values from all the input Observables to the output
         * Observable. The output Observable only completes once all input Observables
         * have completed. Any error delivered by an input Observable will be immediately
         * emitted on the output Observable.
         *
         * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var timer = Rx.Observable.interval(1000);
         * var clicksOrTimer = clicks.merge(timer);
         * clicksOrTimer.subscribe(x => console.log(x));
         *
         * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
         * var timer1 = Rx.Observable.interval(1000).take(10);
         * var timer2 = Rx.Observable.interval(2000).take(6);
         * var timer3 = Rx.Observable.interval(500).take(10);
         * var concurrent = 2; // the argument
         * var merged = timer1.merge(timer2, timer3, concurrent);
         * merged.subscribe(x => console.log(x));
         *
         * @see {@link mergeAll}
         * @see {@link mergeMap}
         * @see {@link mergeMapTo}
         * @see {@link mergeScan}
         *
         * @param {ObservableInput} other An input Observable to merge with the source
         * Observable. More than one input Observables may be given as argument.
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
         * Observables being subscribed to concurrently.
         * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
         * concurrency of input Observables.
         * @return {Observable} An Observable that emits items that are the result of
         * every input Observable.
         * @method merge
         * @owner Observable
         */
        function merge() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return this.lift.call(
            rxjs_1.merge.apply(void 0, [this].concat(observables))
          );
        }
        exports.merge = merge;
      },
      { rxjs: 333 },
    ],
    276: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Converts a higher-order Observable into a first-order Observable which
         * concurrently delivers all values that are emitted on the inner Observables.
         *
         * <span class="informal">Flattens an Observable-of-Observables.</span>
         *
         * <img src="./img/mergeAll.png" width="100%">
         *
         * `mergeAll` subscribes to an Observable that emits Observables, also known as
         * a higher-order Observable. Each time it observes one of these emitted inner
         * Observables, it subscribes to that and delivers all the values from the
         * inner Observable on the output Observable. The output Observable only
         * completes once all inner Observables have completed. Any error delivered by
         * a inner Observable will be immediately emitted on the output Observable.
         *
         * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
         * var firstOrder = higherOrder.mergeAll();
         * firstOrder.subscribe(x => console.log(x));
         *
         * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
         * var firstOrder = higherOrder.mergeAll(2);
         * firstOrder.subscribe(x => console.log(x));
         *
         * @see {@link combineAll}
         * @see {@link concatAll}
         * @see {@link exhaust}
         * @see {@link merge}
         * @see {@link mergeMap}
         * @see {@link mergeMapTo}
         * @see {@link mergeScan}
         * @see {@link switch}
         * @see {@link zipAll}
         *
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
         * Observables being subscribed to concurrently.
         * @return {Observable} An Observable that emits values coming from all the
         * inner Observables emitted by the source Observable.
         * @method mergeAll
         * @owner Observable
         */
        function mergeAll(concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          return operators_1.mergeAll(concurrent)(this);
        }
        exports.mergeAll = mergeAll;
      },
      { "rxjs/operators": 547 },
    ],
    277: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Projects each source value to an Observable which is merged in the output
         * Observable.
         *
         * <span class="informal">Maps each value to an Observable, then flattens all of
         * these inner Observables using {@link mergeAll}.</span>
         *
         * <img src="./img/mergeMap.png" width="100%">
         *
         * Returns an Observable that emits items based on applying a function that you
         * supply to each item emitted by the source Observable, where that function
         * returns an Observable, and then merging those resulting Observables and
         * emitting the results of this merger.
         *
         * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
         * var letters = Rx.Observable.of('a', 'b', 'c');
         * var result = letters.mergeMap(x =>
         *   Rx.Observable.interval(1000).map(i => x+i)
         * );
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // a0
         * // b0
         * // c0
         * // a1
         * // b1
         * // c1
         * // continues to list a,b,c with respective ascending integers
         *
         * @see {@link concatMap}
         * @see {@link exhaustMap}
         * @see {@link merge}
         * @see {@link mergeAll}
         * @see {@link mergeMapTo}
         * @see {@link mergeScan}
         * @see {@link switchMap}
         *
         * @param {function(value: T, ?index: number): ObservableInput} project A function
         * that, when applied to an item emitted by the source Observable, returns an
         * Observable.
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
         * Observables being subscribed to concurrently.
         * @return {Observable} An Observable that emits the result of applying the
         * projection function (and the optional `resultSelector`) to each item emitted
         * by the source Observable and merging the results of the Observables obtained
         * from this transformation.
         * @method mergeMap
         * @owner Observable
         */
        function mergeMap(project, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          return operators_1.mergeMap(project, concurrent)(this);
        }
        exports.mergeMap = mergeMap;
      },
      { "rxjs/operators": 547 },
    ],
    278: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Projects each source value to the same Observable which is merged multiple
         * times in the output Observable.
         *
         * <span class="informal">It's like {@link mergeMap}, but maps each value always
         * to the same inner Observable.</span>
         *
         * <img src="./img/mergeMapTo.png" width="100%">
         *
         * Maps each source value to the given Observable `innerObservable` regardless
         * of the source value, and then merges those resulting Observables into one
         * single Observable, which is the output Observable.
         *
         * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
         * result.subscribe(x => console.log(x));
         *
         * @see {@link concatMapTo}
         * @see {@link merge}
         * @see {@link mergeAll}
         * @see {@link mergeMap}
         * @see {@link mergeScan}
         * @see {@link switchMapTo}
         *
         * @param {ObservableInput} innerObservable An Observable to replace each value from
         * the source Observable.
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
         * Observables being subscribed to concurrently.
         * @return {Observable} An Observable that emits items from the given
         * `innerObservable`.
         * @method mergeMapTo
         * @owner Observable
         */
        function mergeMapTo(innerObservable, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          return operators_1.mergeMapTo(innerObservable, concurrent)(this);
        }
        exports.mergeMapTo = mergeMapTo;
      },
      { "rxjs/operators": 547 },
    ],
    279: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Applies an accumulator function over the source Observable where the
         * accumulator function itself returns an Observable, then each intermediate
         * Observable returned is merged into the output Observable.
         *
         * <span class="informal">It's like {@link scan}, but the Observables returned
         * by the accumulator are merged into the outer Observable.</span>
         *
         * @example <caption>Count the number of click events</caption>
         * const click$ = Rx.Observable.fromEvent(document, 'click');
         * const one$ = click$.mapTo(1);
         * const seed = 0;
         * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
         * count$.subscribe(x => console.log(x));
         *
         * // Results:
         * 1
         * 2
         * 3
         * 4
         * // ...and so on for each click
         *
         * @param {function(acc: R, value: T): Observable<R>} accumulator
         * The accumulator function called on each source value.
         * @param seed The initial accumulation value.
         * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
         * input Observables being subscribed to concurrently.
         * @return {Observable<R>} An observable of the accumulated values.
         * @method mergeScan
         * @owner Observable
         */
        function mergeScan(accumulator, seed, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          return operators_1.mergeScan(accumulator, seed, concurrent)(this);
        }
        exports.mergeScan = mergeScan;
      },
      { "rxjs/operators": 547 },
    ],
    280: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
         * and when source Observable completes it emits a single item: the item with the smallest value.
         *
         * <img src="./img/min.png" width="100%">
         *
         * @example <caption>Get the minimal value of a series of numbers</caption>
         * Rx.Observable.of(5, 4, 7, 2, 8)
         *   .min()
         *   .subscribe(x => console.log(x)); // -> 2
         *
         * @example <caption>Use a comparer function to get the minimal item</caption>
         * interface Person {
         *   age: number,
         *   name: string
         * }
         * Observable.of<Person>({age: 7, name: 'Foo'},
         *                       {age: 5, name: 'Bar'},
         *                       {age: 9, name: 'Beer'})
         *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
         *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
         * }
         *
         * @see {@link max}
         *
         * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
         * value of two items.
         * @return {Observable<R>} An Observable that emits item with the smallest value.
         * @method min
         * @owner Observable
         */
        function min(comparer) {
          return operators_1.min(comparer)(this);
        }
        exports.min = min;
      },
      { "rxjs/operators": 547 },
    ],
    281: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Allows source Observable to be subscribed only once with a Subject of choice,
         * while still sharing its values between multiple subscribers.
         *
         * <span class="informal">Subscribe to Observable once, but send its values to multiple subscribers.</span>
         *
         * <img src="./img/multicast.png" width="100%">
         *
         * `multicast` is an operator that works in two modes.
         *
         * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject
         * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be
         * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that
         * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when
         * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription
         * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,
         * even though usually it would send a request per every subscriber. Since it sends a request at the moment of
         * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.
         *
         * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,
         * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source
         * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,
         * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count
         * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least
         * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a
         * ConnectableObservable, use `refCount`.
         *
         * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.
         * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable
         * as well, which should be the input stream modified by any operators you want. Note that in this
         * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If
         * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.
         * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,
         * if inside the selector function you subscribe to the input Observable multiple times, actual source stream
         * will be subscribed only once. So if you have a chain of operators that use some Observable many times,
         * but you want to subscribe to that Observable only once, this is the mode you would use.
         *
         * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the
         * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject
         * has some special properties, Observable returned by `multicast` will have them as well. If you want to use
         * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},
         * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},
         * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually
         * just wrappers around `multicast`, with a specific Subject hardcoded inside.
         *
         * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,
         * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.
         *
         * @example <caption>Use ConnectableObservable</caption>
         * const seconds = Rx.Observable.interval(1000);
         * const connectableSeconds = seconds.multicast(new Subject());
         *
         * connectableSeconds.subscribe(value => console.log('first: ' + value));
         * connectableSeconds.subscribe(value => console.log('second: ' + value));
         *
         * // At this point still nothing happens, even though we subscribed twice.
         *
         * connectableSeconds.connect();
         *
         * // From now on `seconds` are being logged to the console,
         * // twice per every second. `seconds` Observable was however only subscribed once,
         * // so under the hood Observable.interval had only one clock started.
         *
         * @example <caption>Use selector</caption>
         * const seconds = Rx.Observable.interval(1000);
         *
         * seconds
         *     .multicast(
         *         () => new Subject(),
         *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.
         *                                         // Because we are inside selector, `seconds` is subscribed once,
         *     )                                   // thus starting only one clock used internally by Observable.interval.
         *     .subscribe();
         *
         * @see {@link publish}
         * @see {@link publishLast}
         * @see {@link publishBehavior}
         * @see {@link publishReplay}
         * @see {@link share}
         * @see {@link shareReplay}
         *
         * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through
         * which the source sequence's elements will be multicast to the selector function input Observable or
         * ConnectableObservable returned by the operator.
         * @param {Function} [selector] - Optional selector function that can use the input stream
         * as many times as needed, without causing multiple subscriptions to the source stream.
         * Subscribers to the input source will receive all notifications of the source from the
         * time of the subscription forward.
         * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector
         * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.
         *
         * @method multicast
         * @owner Observable
         */
        function multicast(subjectOrSubjectFactory, selector) {
          return operators_1.multicast(subjectOrSubjectFactory, selector)(this);
        }
        exports.multicast = multicast;
      },
      { "rxjs/operators": 547 },
    ],
    282: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         *
         * Re-emits all notifications from source Observable with specified scheduler.
         *
         * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
         *
         * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
         * notifications emitted by the source Observable. It might be useful, if you do not have control over
         * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
         *
         * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
         * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
         * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
         * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
         * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
         * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
         * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
         * little bit more, to ensure that they are emitted at expected moments.
         *
         * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
         * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
         * will delay all notifications - including error notifications - while `delay` will pass through error
         * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
         * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
         * for notification emissions in general.
         *
         * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
         * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
         *                                               // with async scheduler by default...
         *
         * intervals
         * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
         * .subscribe(val => {                           // scheduler to ensure smooth animation.
         *   someDiv.style.height = val + 'px';
         * });
         *
         * @see {@link delay}
         *
         * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.
         * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
         * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
         * but with provided scheduler.
         *
         * @method observeOn
         * @owner Observable
         */
        function observeOn(scheduler, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return operators_1.observeOn(scheduler, delay)(this);
        }
        exports.observeOn = observeOn;
      },
      { "rxjs/operators": 547 },
    ],
    283: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
 *
 * <img src="./img/onErrorResumeNext.png" width="100%">
 *
 * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
 * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
 * as the source.
 *
 * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
 * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
 * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
 * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
 * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
 * be happening until there is no more Observables left in the series, at which point returned Observable will
 * complete - even if the last subscribed stream ended with an error.
 *
 * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive
 * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
 * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
 * an error.
 *
 * Note that you do not get any access to errors emitted by the Observables. In particular do not
 * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take
 * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.
 *
 *
 * @example <caption>Subscribe to the next Observable after map fails</caption>
 * Rx.Observable.of(1, 2, 3, 0)
 *   .map(x => {
 *       if (x === 0) { throw Error(); }
         return 10 / x;
 *   })
 *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))
 *   .subscribe(
 *     val => console.log(val),
 *     err => console.log(err),          // Will never be called.
 *     () => console.log('that\'s it!')
 *   );
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // "that's it!"
 *
 * @see {@link concat}
 * @see {@link catch}
 *
 * @param {...ObservableInput} observables Observables passed either directly or as an array.
 * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes
 * to the next passed Observable and so on, until it completes or runs out of Observables.
 * @method onErrorResumeNext
 * @owner Observable
 */
        function onErrorResumeNext() {
          var nextSources = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            nextSources[_i] = arguments[_i];
          }
          return operators_1.onErrorResumeNext.apply(void 0, nextSources)(this);
        }
        exports.onErrorResumeNext = onErrorResumeNext;
      },
      { "rxjs/operators": 547 },
    ],
    284: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Groups pairs of consecutive emissions together and emits them as an array of
         * two values.
         *
         * <span class="informal">Puts the current value and previous value together as
         * an array, and emits that.</span>
         *
         * <img src="./img/pairwise.png" width="100%">
         *
         * The Nth emission from the source Observable will cause the output Observable
         * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
         * pair. For this reason, `pairwise` emits on the second and subsequent
         * emissions from the source Observable, but not on the first emission, because
         * there is no previous value in that case.
         *
         * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var pairs = clicks.pairwise();
         * var distance = pairs.map(pair => {
         *   var x0 = pair[0].clientX;
         *   var y0 = pair[0].clientY;
         *   var x1 = pair[1].clientX;
         *   var y1 = pair[1].clientY;
         *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
         * });
         * distance.subscribe(x => console.log(x));
         *
         * @see {@link buffer}
         * @see {@link bufferCount}
         *
         * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
         * consecutive values from the source Observable.
         * @method pairwise
         * @owner Observable
         */
        function pairwise() {
          return operators_1.pairwise()(this);
        }
        exports.pairwise = pairwise;
      },
      { "rxjs/operators": 547 },
    ],
    285: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Splits the source Observable into two, one with values that satisfy a
         * predicate, and another with values that don't satisfy the predicate.
         *
         * <span class="informal">It's like {@link filter}, but returns two Observables:
         * one like the output of {@link filter}, and the other with values that did not
         * pass the condition.</span>
         *
         * <img src="./img/partition.png" width="100%">
         *
         * `partition` outputs an array with two Observables that partition the values
         * from the source Observable through the given `predicate` function. The first
         * Observable in that array emits source values for which the predicate argument
         * returns true. The second Observable emits source values for which the
         * predicate returns false. The first behaves like {@link filter} and the second
         * behaves like {@link filter} with the predicate negated.
         *
         * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
         * var clicksOnDivs = parts[0];
         * var clicksElsewhere = parts[1];
         * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
         * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
         *
         * @see {@link filter}
         *
         * @param {function(value: T, index: number): boolean} predicate A function that
         * evaluates each value emitted by the source Observable. If it returns `true`,
         * the value is emitted on the first Observable in the returned array, if
         * `false` the value is emitted on the second Observable in the array. The
         * `index` parameter is the number `i` for the i-th source emission that has
         * happened since the subscription, starting from the number `0`.
         * @param {any} [thisArg] An optional argument to determine the value of `this`
         * in the `predicate` function.
         * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
         * with values that passed the predicate, and another with values that did not
         * pass the predicate.
         * @method partition
         * @owner Observable
         */
        function partition(predicate, thisArg) {
          return operators_1.partition(predicate, thisArg)(this);
        }
        exports.partition = partition;
      },
      { "rxjs/operators": 547 },
    ],
    286: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Maps each source value (an object) to its specified nested property.
         *
         * <span class="informal">Like {@link map}, but meant only for picking one of
         * the nested properties of every emitted object.</span>
         *
         * <img src="./img/pluck.png" width="100%">
         *
         * Given a list of strings describing a path to an object property, retrieves
         * the value of a specified nested property from all values in the source
         * Observable. If a property can't be resolved, it will return `undefined` for
         * that value.
         *
         * @example <caption>Map every click to the tagName of the clicked target element</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var tagNames = clicks.pluck('target', 'tagName');
         * tagNames.subscribe(x => console.log(x));
         *
         * @see {@link map}
         *
         * @param {...string} properties The nested properties to pluck from each source
         * value (an object).
         * @return {Observable} A new Observable of property values from the source values.
         * @method pluck
         * @owner Observable
         */
        function pluck() {
          var properties = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
          }
          return operators_1.pluck.apply(void 0, properties)(this);
        }
        exports.pluck = pluck;
      },
      { "rxjs/operators": 547 },
    ],
    287: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
         * before it begins emitting items to those Observers that have subscribed to it.
         *
         * <img src="./img/publish.png" width="100%">
         *
         * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
         * as needed, without causing multiple subscriptions to the source sequence.
         * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
         * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
         * @method publish
         * @owner Observable
         */
        function publish(selector) {
          return operators_1.publish(selector)(this);
        }
        exports.publish = publish;
      },
      { "rxjs/operators": 547 },
    ],
    288: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * @param value
         * @return {ConnectableObservable<T>}
         * @method publishBehavior
         * @owner Observable
         */
        function publishBehavior(value) {
          return operators_1.publishBehavior(value)(this);
        }
        exports.publishBehavior = publishBehavior;
      },
      { "rxjs/operators": 547 },
    ],
    289: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * @return {ConnectableObservable<T>}
         * @method publishLast
         * @owner Observable
         */
        function publishLast() {
          //TODO(benlesh): correct type-flow through here.
          return operators_1.publishLast()(this);
        }
        exports.publishLast = publishLast;
      },
      { "rxjs/operators": 547 },
    ],
    290: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * @param bufferSize
         * @param windowTime
         * @param selectorOrScheduler
         * @param scheduler
         * @return {Observable<T> | ConnectableObservable<T>}
         * @method publishReplay
         * @owner Observable
         */
        function publishReplay(
          bufferSize,
          windowTime,
          selectorOrScheduler,
          scheduler
        ) {
          return operators_1.publishReplay(
            bufferSize,
            windowTime,
            selectorOrScheduler,
            scheduler
          )(this);
        }
        exports.publishReplay = publishReplay;
      },
      { "rxjs/operators": 547 },
    ],
    291: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Returns an Observable that mirrors the first source Observable to emit an item
         * from the combination of this Observable and supplied Observables.
         * @param {...Observables} ...observables Sources used to race for which Observable emits first.
         * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
         * @method race
         * @owner Observable
         */
        function race() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return operators_1.race.apply(void 0, observables)(this);
        }
        exports.race = race;
      },
      { "rxjs/operators": 547 },
    ],
    292: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Applies an accumulator function over the source Observable, and returns the
         * accumulated result when the source completes, given an optional seed value.
         *
         * <span class="informal">Combines together all values emitted on the source,
         * using an accumulator function that knows how to join a new source value into
         * the accumulation from the past.</span>
         *
         * <img src="./img/reduce.png" width="100%">
         *
         * Like
         * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
         * `reduce` applies an `accumulator` function against an accumulation and each
         * value of the source Observable (from the past) to reduce it to a single
         * value, emitted on the output Observable. Note that `reduce` will only emit
         * one value, only when the source Observable completes. It is equivalent to
         * applying operator {@link scan} followed by operator {@link last}.
         *
         * Returns an Observable that applies a specified `accumulator` function to each
         * item emitted by the source Observable. If a `seed` value is specified, then
         * that value will be used as the initial value for the accumulator. If no seed
         * value is specified, the first item of the source is used as the seed.
         *
         * @example <caption>Count the number of click events that happened in 5 seconds</caption>
         * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
         *   .takeUntil(Rx.Observable.interval(5000));
         * var ones = clicksInFiveSeconds.mapTo(1);
         * var seed = 0;
         * var count = ones.reduce((acc, one) => acc + one, seed);
         * count.subscribe(x => console.log(x));
         *
         * @see {@link count}
         * @see {@link expand}
         * @see {@link mergeScan}
         * @see {@link scan}
         *
         * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
         * called on each source value.
         * @param {R} [seed] The initial accumulation value.
         * @return {Observable<R>} An Observable that emits a single value that is the
         * result of accumulating the values emitted by the source Observable.
         * @method reduce
         * @owner Observable
         */
        function reduce(accumulator, seed) {
          // providing a seed of `undefined` *should* be valid and trigger
          // hasSeed! so don't use `seed !== undefined` checks!
          // For this reason, we have to check it here at the original call site
          // otherwise inside Operator/Subscriber we won't know if `undefined`
          // means they didn't provide anything or if they literally provided `undefined`
          if (arguments.length >= 2) {
            return operators_1.reduce(accumulator, seed)(this);
          }
          return operators_1.reduce(accumulator)(this);
        }
        exports.reduce = reduce;
      },
      { "rxjs/operators": 547 },
    ],
    293: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
         *
         * <img src="./img/repeat.png" width="100%">
         *
         * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
         * an empty Observable.
         * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
         * count times.
         * @method repeat
         * @owner Observable
         */
        function repeat(count) {
          if (count === void 0) {
            count = -1;
          }
          return operators_1.repeat(count)(this);
        }
        exports.repeat = repeat;
      },
      { "rxjs/operators": 547 },
    ],
    294: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
         * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
         * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
         * this method will resubscribe to the source Observable.
         *
         * <img src="./img/repeatWhen.png" width="100%">
         *
         * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
         * which a user can `complete` or `error`, aborting the repetition.
         * @return {Observable} The source Observable modified with repeat logic.
         * @method repeatWhen
         * @owner Observable
         */
        function repeatWhen(notifier) {
          return operators_1.repeatWhen(notifier)(this);
        }
        exports.repeatWhen = repeatWhen;
      },
      { "rxjs/operators": 547 },
    ],
    295: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
         * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
         * as a number parameter) rather than propagating the `error` call.
         *
         * <img src="./img/retry.png" width="100%">
         *
         * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
         * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
         * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
         * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
         * @param {number} count - Number of retry attempts before failing.
         * @return {Observable} The source Observable modified with the retry logic.
         * @method retry
         * @owner Observable
         */
        function retry(count) {
          if (count === void 0) {
            count = -1;
          }
          return operators_1.retry(count)(this);
        }
        exports.retry = retry;
      },
      { "rxjs/operators": 547 },
    ],
    296: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
         * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
         * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
         * subscription. Otherwise this method will resubscribe to the source Observable.
         *
         * <img src="./img/retryWhen.png" width="100%">
         *
         * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
         * user can `complete` or `error`, aborting the retry.
         * @return {Observable} The source Observable modified with retry logic.
         * @method retryWhen
         * @owner Observable
         */
        function retryWhen(notifier) {
          return operators_1.retryWhen(notifier)(this);
        }
        exports.retryWhen = retryWhen;
      },
      { "rxjs/operators": 547 },
    ],
    297: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits the most recently emitted value from the source Observable whenever
         * another Observable, the `notifier`, emits.
         *
         * <span class="informal">It's like {@link sampleTime}, but samples whenever
         * the `notifier` Observable emits something.</span>
         *
         * <img src="./img/sample.png" width="100%">
         *
         * Whenever the `notifier` Observable emits a value or completes, `sample`
         * looks at the source Observable and emits whichever value it has most recently
         * emitted since the previous sampling, unless the source has not emitted
         * anything since the previous sampling. The `notifier` is subscribed to as soon
         * as the output Observable is subscribed.
         *
         * @example <caption>On every click, sample the most recent "seconds" timer</caption>
         * var seconds = Rx.Observable.interval(1000);
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = seconds.sample(clicks);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link audit}
         * @see {@link debounce}
         * @see {@link sampleTime}
         * @see {@link throttle}
         *
         * @param {Observable<any>} notifier The Observable to use for sampling the
         * source Observable.
         * @return {Observable<T>} An Observable that emits the results of sampling the
         * values emitted by the source Observable whenever the notifier Observable
         * emits value or completes.
         * @method sample
         * @owner Observable
         */
        function sample(notifier) {
          return operators_1.sample(notifier)(this);
        }
        exports.sample = sample;
      },
      { "rxjs/operators": 547 },
    ],
    298: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var operators_1 = require("rxjs/operators");
        /**
         * Emits the most recently emitted value from the source Observable within
         * periodic time intervals.
         *
         * <span class="informal">Samples the source Observable at periodic time
         * intervals, emitting what it samples.</span>
         *
         * <img src="./img/sampleTime.png" width="100%">
         *
         * `sampleTime` periodically looks at the source Observable and emits whichever
         * value it has most recently emitted since the previous sampling, unless the
         * source has not emitted anything since the previous sampling. The sampling
         * happens periodically in time every `period` milliseconds (or the time unit
         * defined by the optional `scheduler` argument). The sampling starts as soon as
         * the output Observable is subscribed.
         *
         * @example <caption>Every second, emit the most recent click at most once</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.sampleTime(1000);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link auditTime}
         * @see {@link debounceTime}
         * @see {@link delay}
         * @see {@link sample}
         * @see {@link throttleTime}
         *
         * @param {number} period The sampling period expressed in milliseconds or the
         * time unit determined internally by the optional `scheduler`.
         * @param {Scheduler} [scheduler=asyncScheduler] The {@link SchedulerLike} to use for
         * managing the timers that handle the sampling.
         * @return {Observable<T>} An Observable that emits the results of sampling the
         * values emitted by the source Observable at the specified time interval.
         * @method sampleTime
         * @owner Observable
         */
        function sampleTime(period, scheduler) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          return operators_1.sampleTime(period, scheduler)(this);
        }
        exports.sampleTime = sampleTime;
      },
      { rxjs: 333, "rxjs/operators": 547 },
    ],
    299: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Applies an accumulator function over the source Observable, and returns each
         * intermediate result, with an optional seed value.
         *
         * <span class="informal">It's like {@link reduce}, but emits the current
         * accumulation whenever the source emits a value.</span>
         *
         * <img src="./img/scan.png" width="100%">
         *
         * Combines together all values emitted on the source, using an accumulator
         * function that knows how to join a new source value into the accumulation from
         * the past. Is similar to {@link reduce}, but emits the intermediate
         * accumulations.
         *
         * Returns an Observable that applies a specified `accumulator` function to each
         * item emitted by the source Observable. If a `seed` value is specified, then
         * that value will be used as the initial value for the accumulator. If no seed
         * value is specified, the first item of the source is used as the seed.
         *
         * @example <caption>Count the number of click events</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var ones = clicks.mapTo(1);
         * var seed = 0;
         * var count = ones.scan((acc, one) => acc + one, seed);
         * count.subscribe(x => console.log(x));
         *
         * @see {@link expand}
         * @see {@link mergeScan}
         * @see {@link reduce}
         *
         * @param {function(acc: R, value: T, index: number): R} accumulator
         * The accumulator function called on each source value.
         * @param {T|R} [seed] The initial accumulation value.
         * @return {Observable<R>} An observable of the accumulated values.
         * @method scan
         * @owner Observable
         */
        function scan(accumulator, seed) {
          if (arguments.length >= 2) {
            return operators_1.scan(accumulator, seed)(this);
          }
          return operators_1.scan(accumulator)(this);
        }
        exports.scan = scan;
      },
      { "rxjs/operators": 547 },
    ],
    300: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Compares all values of two observables in sequence using an optional comparor function
         * and returns an observable of a single boolean value representing whether or not the two sequences
         * are equal.
         *
         * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
         *
         * <img src="./img/sequenceEqual.png" width="100%">
         *
         * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
         * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
         * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
         * observables completes, the operator will wait for the other observable to complete; If the other
         * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
         * completes or emits after the other complets, the returned observable will never complete.
         *
         * @example <caption>figure out if the Konami code matches</caption>
         * var code = Rx.Observable.from([
         *  "ArrowUp",
         *  "ArrowUp",
         *  "ArrowDown",
         *  "ArrowDown",
         *  "ArrowLeft",
         *  "ArrowRight",
         *  "ArrowLeft",
         *  "ArrowRight",
         *  "KeyB",
         *  "KeyA",
         *  "Enter" // no start key, clearly.
         * ]);
         *
         * var keys = Rx.Observable.fromEvent(document, 'keyup')
         *  .map(e => e.code);
         * var matches = keys.bufferCount(11, 1)
         *  .mergeMap(
         *    last11 =>
         *      Rx.Observable.from(last11)
         *        .sequenceEqual(code)
         *   );
         * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
         *
         * @see {@link combineLatest}
         * @see {@link zip}
         * @see {@link withLatestFrom}
         *
         * @param {Observable} compareTo The observable sequence to compare the source sequence to.
         * @param {function} [comparor] An optional function to compare each value pair
         * @return {Observable} An Observable of a single boolean value representing whether or not
         * the values emitted by both observables were equal in sequence.
         * @method sequenceEqual
         * @owner Observable
         */
        function sequenceEqual(compareTo, comparor) {
          return operators_1.sequenceEqual(compareTo, comparor)(this);
        }
        exports.sequenceEqual = sequenceEqual;
      },
      { "rxjs/operators": 547 },
    ],
    301: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
         * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
         * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
         *
         * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.
         * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.
         * Observable.of("test").publish().refCount() will not re-emit "test" on new subscriptions, Observable.of("test").share() will
         * re-emit "test" to new subscriptions.
         *
         * <img src="./img/share.png" width="100%">
         *
         * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
         * @method share
         * @owner Observable
         */
        function share() {
          return operators_1.share()(this);
        }
        exports.share = share;
      },
      { "rxjs/operators": 547 },
    ],
    302: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        function shareReplay(configOrBufferSize, windowTime, scheduler) {
          if (configOrBufferSize && typeof configOrBufferSize === "object") {
            return operators_1.shareReplay(configOrBufferSize)(this);
          }
          return operators_1.shareReplay(
            configOrBufferSize,
            windowTime,
            scheduler
          )(this);
        }
        exports.shareReplay = shareReplay;
      },
      { "rxjs/operators": 547 },
    ],
    303: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
 *
 * <img src="./img/single.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
 * the predicate.
 .
 * @method single
 * @owner Observable
 */
        function single(predicate) {
          return operators_1.single(predicate)(this);
        }
        exports.single = single;
      },
      { "rxjs/operators": 547 },
    ],
    304: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that skips the first `count` items emitted by the source Observable.
         *
         * <img src="./img/skip.png" width="100%">
         *
         * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
         * @return {Observable} An Observable that skips values emitted by the source Observable.
         *
         * @method skip
         * @owner Observable
         */
        function skip(count) {
          return operators_1.skip(count)(this);
        }
        exports.skip = skip;
      },
      { "rxjs/operators": 547 },
    ],
    305: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Skip the last `count` values emitted by the source Observable.
         *
         * <img src="./img/skipLast.png" width="100%">
         *
         * `skipLast` returns an Observable that accumulates a queue with a length
         * enough to store the first `count` values. As more values are received,
         * values are taken from the front of the queue and produced on the result
         * sequence. This causes values to be delayed.
         *
         * @example <caption>Skip the last 2 values of an Observable with many values</caption>
         * var many = Rx.Observable.range(1, 5);
         * var skipLastTwo = many.skipLast(2);
         * skipLastTwo.subscribe(x => console.log(x));
         *
         * // Results in:
         * // 1 2 3
         *
         * @see {@link skip}
         * @see {@link skipUntil}
         * @see {@link skipWhile}
         * @see {@link take}
         *
         * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws
         * ArgumentOutOrRangeError if `i < 0`.
         *
         * @param {number} count Number of elements to skip from the end of the source Observable.
         * @returns {Observable<T>} An Observable that skips the last count values
         * emitted by the source Observable.
         * @method skipLast
         * @owner Observable
         */
        function skipLast(count) {
          return operators_1.skipLast(count)(this);
        }
        exports.skipLast = skipLast;
      },
      { "rxjs/operators": 547 },
    ],
    306: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
         *
         * <img src="./img/skipUntil.png" width="100%">
         *
         * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
         * be mirrored by the resulting Observable.
         * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
         * an item, then emits the remaining items.
         * @method skipUntil
         * @owner Observable
         */
        function skipUntil(notifier) {
          return operators_1.skipUntil(notifier)(this);
        }
        exports.skipUntil = skipUntil;
      },
      { "rxjs/operators": 547 },
    ],
    307: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
         * true, but emits all further source items as soon as the condition becomes false.
         *
         * <img src="./img/skipWhile.png" width="100%">
         *
         * @param {Function} predicate - A function to test each item emitted from the source Observable.
         * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
         * specified predicate becomes false.
         * @method skipWhile
         * @owner Observable
         */
        function skipWhile(predicate) {
          return operators_1.skipWhile(predicate)(this);
        }
        exports.skipWhile = skipWhile;
      },
      { "rxjs/operators": 547 },
    ],
    308: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Returns an Observable that emits the items you specify as arguments before it begins to emit
         * items emitted by the source Observable.
         *
         * <img src="./img/startWith.png" width="100%">
         *
         * @param {...T} values - Items you want the modified Observable to emit first.
         * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
         * the emissions of the `next` notifications.
         * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
         * emitted by the source Observable.
         * @method startWith
         * @owner Observable
         */
        function startWith() {
          var array = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
          }
          return operators_1.startWith.apply(void 0, array)(this);
        }
        exports.startWith = startWith;
      },
      { "rxjs/operators": 547 },
    ],
    309: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
 * Asynchronously subscribes Observers to this Observable on the specified IScheduler.
 *
 * <img src="./img/subscribeOn.png" width="100%">
 *
 * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.
 * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.
 .
 * @method subscribeOn
 * @owner Observable
 */
        function subscribeOn(scheduler, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return operators_1.subscribeOn(scheduler, delay)(this);
        }
        exports.subscribeOn = subscribeOn;
      },
      { "rxjs/operators": 547 },
    ],
    310: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Converts a higher-order Observable into a first-order Observable by
         * subscribing to only the most recently emitted of those inner Observables.
         *
         * <span class="informal">Flattens an Observable-of-Observables by dropping the
         * previous inner Observable once a new one appears.</span>
         *
         * <img src="./img/switch.png" width="100%">
         *
         * `switch` subscribes to an Observable that emits Observables, also known as a
         * higher-order Observable. Each time it observes one of these emitted inner
         * Observables, the output Observable subscribes to the inner Observable and
         * begins emitting the items emitted by that. So far, it behaves
         * like {@link mergeAll}. However, when a new inner Observable is emitted,
         * `switch` unsubscribes from the earlier-emitted inner Observable and
         * subscribes to the new inner Observable and begins emitting items from it. It
         * continues to behave like this for subsequent inner Observables.
         *
         * @example <caption>Rerun an interval Observable on every click event</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * // Each click event is mapped to an Observable that ticks every second
         * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
         * var switched = higherOrder.switch();
         * // The outcome is that `switched` is essentially a timer that restarts
         * // on every click. The interval Observables from older clicks do not merge
         * // with the current interval Observable.
         * switched.subscribe(x => console.log(x));
         *
         * @see {@link combineAll}
         * @see {@link concatAll}
         * @see {@link exhaust}
         * @see {@link mergeAll}
         * @see {@link switchMap}
         * @see {@link switchMapTo}
         * @see {@link zipAll}
         *
         * @return {Observable<T>} An Observable that emits the items emitted by the
         * Observable most recently emitted by the source Observable.
         * @method switch
         * @name switch
         * @owner Observable
         */
        function _switch() {
          return operators_1.switchAll()(this);
        }
        exports._switch = _switch;
      },
      { "rxjs/operators": 547 },
    ],
    311: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Projects each source value to an Observable which is merged in the output
         * Observable, emitting values only from the most recently projected Observable.
         *
         * <span class="informal">Maps each value to an Observable, then flattens all of
         * these inner Observables using {@link switch}.</span>
         *
         * <img src="./img/switchMap.png" width="100%">
         *
         * Returns an Observable that emits items based on applying a function that you
         * supply to each item emitted by the source Observable, where that function
         * returns an (so-called "inner") Observable. Each time it observes one of these
         * inner Observables, the output Observable begins emitting the items emitted by
         * that inner Observable. When a new inner Observable is emitted, `switchMap`
         * stops emitting items from the earlier-emitted inner Observable and begins
         * emitting items from the new one. It continues to behave like this for
         * subsequent inner Observables.
         *
         * @example <caption>Rerun an interval Observable on every click event</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
         * result.subscribe(x => console.log(x));
         *
         * @see {@link concatMap}
         * @see {@link exhaustMap}
         * @see {@link mergeMap}
         * @see {@link switch}
         * @see {@link switchMapTo}
         *
         * @param {function(value: T, ?index: number): ObservableInput} project A function
         * that, when applied to an item emitted by the source Observable, returns an
         * Observable.
         * @return {Observable} An Observable that emits the result of applying the
         * projection function (and the optional `resultSelector`) to each item emitted
         * by the source Observable and taking only the values from the most recently
         * projected inner Observable.
         * @method switchMap
         * @owner Observable
         */
        function switchMap(project) {
          return operators_1.switchMap(project)(this);
        }
        exports.switchMap = switchMap;
      },
      { "rxjs/operators": 547 },
    ],
    312: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Projects each source value to the same Observable which is flattened multiple
         * times with {@link switch} in the output Observable.
         *
         * <span class="informal">It's like {@link switchMap}, but maps each value
         * always to the same inner Observable.</span>
         *
         * <img src="./img/switchMapTo.png" width="100%">
         *
         * Maps each source value to the given Observable `innerObservable` regardless
         * of the source value, and then flattens those resulting Observables into one
         * single Observable, which is the output Observable. The output Observables
         * emits values only from the most recently emitted instance of
         * `innerObservable`.
         *
         * @example <caption>Rerun an interval Observable on every click event</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
         * result.subscribe(x => console.log(x));
         *
         * @see {@link concatMapTo}
         * @see {@link switch}
         * @see {@link switchMap}
         * @see {@link mergeMapTo}
         *
         * @param {ObservableInput} innerObservable An Observable to replace each value from
         * the source Observable.
         * @return {Observable} An Observable that emits items from the given
         * `innerObservable` (and optionally transformed through `resultSelector`) every
         * time a value is emitted on the source Observable, and taking only the values
         * from the most recently projected inner Observable.
         * @method switchMapTo
         * @owner Observable
         */
        function switchMapTo(innerObservable) {
          return operators_1.switchMapTo(innerObservable)(this);
        }
        exports.switchMapTo = switchMapTo;
      },
      { "rxjs/operators": 547 },
    ],
    313: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits only the first `count` values emitted by the source Observable.
         *
         * <span class="informal">Takes the first `count` values from the source, then
         * completes.</span>
         *
         * <img src="./img/take.png" width="100%">
         *
         * `take` returns an Observable that emits only the first `count` values emitted
         * by the source Observable. If the source emits fewer than `count` values then
         * all of its values are emitted. After that, it completes, regardless if the
         * source completes.
         *
         * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
         * var interval = Rx.Observable.interval(1000);
         * var five = interval.take(5);
         * five.subscribe(x => console.log(x));
         *
         * @see {@link takeLast}
         * @see {@link takeUntil}
         * @see {@link takeWhile}
         * @see {@link skip}
         *
         * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
         * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
         *
         * @param {number} count The maximum number of `next` values to emit.
         * @return {Observable<T>} An Observable that emits only the first `count`
         * values emitted by the source Observable, or all of the values from the source
         * if the source emits fewer than `count` values.
         * @method take
         * @owner Observable
         */
        function take(count) {
          return operators_1.take(count)(this);
        }
        exports.take = take;
      },
      { "rxjs/operators": 547 },
    ],
    314: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits only the last `count` values emitted by the source Observable.
         *
         * <span class="informal">Remembers the latest `count` values, then emits those
         * only when the source completes.</span>
         *
         * <img src="./img/takeLast.png" width="100%">
         *
         * `takeLast` returns an Observable that emits at most the last `count` values
         * emitted by the source Observable. If the source emits fewer than `count`
         * values then all of its values are emitted. This operator must wait until the
         * `complete` notification emission from the source in order to emit the `next`
         * values on the output Observable, because otherwise it is impossible to know
         * whether or not more values will be emitted on the source. For this reason,
         * all values are emitted synchronously, followed by the complete notification.
         *
         * @example <caption>Take the last 3 values of an Observable with many values</caption>
         * var many = Rx.Observable.range(1, 100);
         * var lastThree = many.takeLast(3);
         * lastThree.subscribe(x => console.log(x));
         *
         * @see {@link take}
         * @see {@link takeUntil}
         * @see {@link takeWhile}
         * @see {@link skip}
         *
         * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
         * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
         *
         * @param {number} count The maximum number of values to emit from the end of
         * the sequence of values emitted by the source Observable.
         * @return {Observable<T>} An Observable that emits at most the last count
         * values emitted by the source Observable.
         * @method takeLast
         * @owner Observable
         */
        function takeLast(count) {
          return operators_1.takeLast(count)(this);
        }
        exports.takeLast = takeLast;
      },
      { "rxjs/operators": 547 },
    ],
    315: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits the values emitted by the source Observable until a `notifier`
         * Observable emits a value.
         *
         * <span class="informal">Lets values pass until a second Observable,
         * `notifier`, emits a value. Then, it completes.</span>
         *
         * <img src="./img/takeUntil.png" width="100%">
         *
         * `takeUntil` subscribes and begins mirroring the source Observable. It also
         * monitors a second Observable, `notifier` that you provide. If the `notifier`
         * emits a value, the output Observable stops mirroring the source Observable
         * and completes. If the `notifier` doesn't emit any value and completes
         * then `takeUntil` will pass all values.
         *
         * @example <caption>Tick every second until the first click happens</caption>
         * var interval = Rx.Observable.interval(1000);
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = interval.takeUntil(clicks);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link take}
         * @see {@link takeLast}
         * @see {@link takeWhile}
         * @see {@link skip}
         *
         * @param {Observable} notifier The Observable whose first emitted value will
         * cause the output Observable of `takeUntil` to stop emitting values from the
         * source Observable.
         * @return {Observable<T>} An Observable that emits the values from the source
         * Observable until such time as `notifier` emits its first value.
         * @method takeUntil
         * @owner Observable
         */
        function takeUntil(notifier) {
          return operators_1.takeUntil(notifier)(this);
        }
        exports.takeUntil = takeUntil;
      },
      { "rxjs/operators": 547 },
    ],
    316: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Emits values emitted by the source Observable so long as each value satisfies
         * the given `predicate`, and then completes as soon as this `predicate` is not
         * satisfied.
         *
         * <span class="informal">Takes values from the source only while they pass the
         * condition given. When the first value does not satisfy, it completes.</span>
         *
         * <img src="./img/takeWhile.png" width="100%">
         *
         * `takeWhile` subscribes and begins mirroring the source Observable. Each value
         * emitted on the source is given to the `predicate` function which returns a
         * boolean, representing a condition to be satisfied by the source values. The
         * output Observable emits the source values until such time as the `predicate`
         * returns false, at which point `takeWhile` stops mirroring the source
         * Observable and completes the output Observable.
         *
         * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.takeWhile(ev => ev.clientX > 200);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link take}
         * @see {@link takeLast}
         * @see {@link takeUntil}
         * @see {@link skip}
         *
         * @param {function(value: T, index: number): boolean} predicate A function that
         * evaluates a value emitted by the source Observable and returns a boolean.
         * Also takes the (zero-based) index as the second argument.
         * @return {Observable<T>} An Observable that emits the values from the source
         * Observable so long as each value satisfies the condition defined by the
         * `predicate`, then completes.
         * @method takeWhile
         * @owner Observable
         */
        function takeWhile(predicate) {
          return operators_1.takeWhile(predicate)(this);
        }
        exports.takeWhile = takeWhile;
      },
      { "rxjs/operators": 547 },
    ],
    317: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        var internal_compatibility_1 = require("rxjs/internal-compatibility");
        /**
         * Emits a value from the source Observable, then ignores subsequent source
         * values for a duration determined by another Observable, then repeats this
         * process.
         *
         * <span class="informal">It's like {@link throttleTime}, but the silencing
         * duration is determined by a second Observable.</span>
         *
         * <img src="./img/throttle.png" width="100%">
         *
         * `throttle` emits the source Observable values on the output Observable
         * when its internal timer is disabled, and ignores source values when the timer
         * is enabled. Initially, the timer is disabled. As soon as the first source
         * value arrives, it is forwarded to the output Observable, and then the timer
         * is enabled by calling the `durationSelector` function with the source value,
         * which returns the "duration" Observable. When the duration Observable emits a
         * value or completes, the timer is disabled, and this process repeats for the
         * next source value.
         *
         * @example <caption>Emit clicks at a rate of at most one click per second</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
         * result.subscribe(x => console.log(x));
         *
         * @see {@link audit}
         * @see {@link debounce}
         * @see {@link delayWhen}
         * @see {@link sample}
         * @see {@link throttleTime}
         *
         * @param {function(value: T): SubscribableOrPromise} durationSelector A function
         * that receives a value from the source Observable, for computing the silencing
         * duration for each source value, returned as an Observable or a Promise.
         * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
         * to `{ leading: true, trailing: false }`.
         * @return {Observable<T>} An Observable that performs the throttle operation to
         * limit the rate of emissions from the source.
         * @method throttle
         * @owner Observable
         */
        function throttle(durationSelector, config) {
          if (config === void 0) {
            config = internal_compatibility_1.defaultThrottleConfig;
          }
          return operators_1.throttle(durationSelector, config)(this);
        }
        exports.throttle = throttle;
      },
      { "rxjs/internal-compatibility": 334, "rxjs/operators": 547 },
    ],
    318: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var internal_compatibility_1 = require("rxjs/internal-compatibility");
        var operators_1 = require("rxjs/operators");
        /**
         * Emits a value from the source Observable, then ignores subsequent source
         * values for `duration` milliseconds, then repeats this process.
         *
         * <span class="informal">Lets a value pass, then ignores source values for the
         * next `duration` milliseconds.</span>
         *
         * <img src="./img/throttleTime.png" width="100%">
         *
         * `throttleTime` emits the source Observable values on the output Observable
         * when its internal timer is disabled, and ignores source values when the timer
         * is enabled. Initially, the timer is disabled. As soon as the first source
         * value arrives, it is forwarded to the output Observable, and then the timer
         * is enabled. After `duration` milliseconds (or the time unit determined
         * internally by the optional `scheduler`) has passed, the timer is disabled,
         * and this process repeats for the next source value. Optionally takes a
         * {@link IScheduler} for managing timers.
         *
         * @example <caption>Emit clicks at a rate of at most one click per second</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.throttleTime(1000);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link auditTime}
         * @see {@link debounceTime}
         * @see {@link delay}
         * @see {@link sampleTime}
         * @see {@link throttle}
         *
         * @param {number} duration Time to wait before emitting another value after
         * emitting the last value, measured in milliseconds or the time unit determined
         * internally by the optional `scheduler`.
         * @param {Scheduler} [scheduler=asyncScheduler] The {@link SchedulerLike} to use for
         * managing the timers that handle the throttling.
         * @return {Observable<T>} An Observable that performs the throttle operation to
         * limit the rate of emissions from the source.
         * @method throttleTime
         * @owner Observable
         */
        function throttleTime(duration, scheduler, config) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          if (config === void 0) {
            config = internal_compatibility_1.defaultThrottleConfig;
          }
          return operators_1.throttleTime(duration, scheduler, config)(this);
        }
        exports.throttleTime = throttleTime;
      },
      { rxjs: 333, "rxjs/internal-compatibility": 334, "rxjs/operators": 547 },
    ],
    319: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var operators_1 = require("rxjs/operators");
        /**
         * @param scheduler
         * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}
         * @method timeInterval
         * @owner Observable
         */
        function timeInterval(scheduler) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          return operators_1.timeInterval(scheduler)(this);
        }
        exports.timeInterval = timeInterval;
      },
      { rxjs: 333, "rxjs/operators": 547 },
    ],
    320: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var operators_1 = require("rxjs/operators");
        /**
         *
         * Errors if Observable does not emit a value in given time span.
         *
         * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
         *
         * <img src="./img/timeout.png" width="100%">
         *
         * `timeout` operator accepts as an argument either a number or a Date.
         *
         * If number was provided, it returns an Observable that behaves like a source
         * Observable, unless there is a period of time where there is no value emitted.
         * So if you provide `100` as argument and first value comes after 50ms from
         * the moment of subscription, this value will be simply re-emitted by the resulting
         * Observable. If however after that 100ms passes without a second value being emitted,
         * stream will end with an error and source Observable will be unsubscribed.
         * These checks are performed throughout whole lifecycle of Observable - from the moment
         * it was subscribed to, until it completes or errors itself. Thus every value must be
         * emitted within specified period since previous value.
         *
         * If provided argument was Date, returned Observable behaves differently. It throws
         * if Observable did not complete before provided Date. This means that periods between
         * emission of particular values do not matter in this case. If Observable did not complete
         * before provided Date, source Observable will be unsubscribed. Other than that, resulting
         * stream behaves just as source Observable.
         *
         * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
         * when returned Observable will check if source stream emitted value or completed.
         *
         * @example <caption>Check if ticks are emitted within certain timespan</caption>
         * const seconds = Rx.Observable.interval(1000);
         *
         * seconds.timeout(1100) // Let's use bigger timespan to be safe,
         *                       // since `interval` might fire a bit later then scheduled.
         * .subscribe(
         *     value => console.log(value), // Will emit numbers just as regular `interval` would.
         *     err => console.log(err) // Will never be called.
         * );
         *
         * seconds.timeout(900).subscribe(
         *     value => console.log(value), // Will never be called.
         *     err => console.log(err) // Will emit error before even first value is emitted,
         *                             // since it did not arrive within 900ms period.
         * );
         *
         * @example <caption>Use Date to check if Observable completed</caption>
         * const seconds = Rx.Observable.interval(1000);
         *
         * seconds.timeout(new Date("December 17, 2020 03:24:00"))
         * .subscribe(
         *     value => console.log(value), // Will emit values as regular `interval` would
         *                                  // until December 17, 2020 at 03:24:00.
         *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
         *                             // since Observable did not complete by then.
         * );
         *
         * @see {@link timeoutWith}
         *
         * @param {number|Date} due Number specifying period within which Observable must emit values
         *                          or Date specifying before when Observable should complete
         * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
         * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
         * @method timeout
         * @owner Observable
         */
        function timeout(due, scheduler) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          return operators_1.timeout(due, scheduler)(this);
        }
        exports.timeout = timeout;
      },
      { rxjs: 333, "rxjs/operators": 547 },
    ],
    321: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         *
         * Errors if Observable does not emit a value in given time span, in case of which
         * subscribes to the second Observable.
         *
         * <span class="informal">It's a version of `timeout` operator that let's you specify fallback Observable.</span>
         *
         * <img src="./img/timeoutWith.png" width="100%">
         *
         * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,
         * still accepting as a first argument either a number or a Date, which control - respectively -
         * when values of source Observable should be emitted or when it should complete.
         *
         * The only difference is that it accepts a second, required parameter. This parameter
         * should be an Observable which will be subscribed when source Observable fails any timeout check.
         * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting
         * values from second Observable. Note that this fallback Observable is not checked for timeouts
         * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second
         * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that
         * stream completes, it completes as well.
         *
         * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided
         * here - as a third, optional parameter. It still is used to schedule timeout checks and -
         * as a consequence - when second Observable will be subscribed, since subscription happens
         * immediately after failing check.
         *
         * @example <caption>Add fallback observable</caption>
         * const seconds = Rx.Observable.interval(1000);
         * const minutes = Rx.Observable.interval(60 * 1000);
         *
         * seconds.timeoutWith(900, minutes)
         *     .subscribe(
         *         value => console.log(value), // After 900ms, will start emitting `minutes`,
         *                                      // since first value of `seconds` will not arrive fast enough.
         *         err => console.log(err) // Would be called after 900ms in case of `timeout`,
         *                                 // but here will never be called.
         *     );
         *
         * @param {number|Date} due Number specifying period within which Observable must emit values
         *                          or Date specifying before when Observable should complete
         * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.
         * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
         * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable
         *                          passed as a second parameter.
         * @method timeoutWith
         * @owner Observable
         */
        function timeoutWith(due, withObservable, scheduler) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          return operators_1.timeoutWith(due, withObservable, scheduler)(this);
        }
        exports.timeoutWith = timeoutWith;
      },
      { rxjs: 333, "rxjs/operators": 547 },
    ],
    322: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var operators_1 = require("rxjs/operators");
        /**
         * @param scheduler
         * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
         * @method timestamp
         * @owner Observable
         */
        function timestamp(scheduler) {
          if (scheduler === void 0) {
            scheduler = rxjs_1.asyncScheduler;
          }
          return operators_1.timestamp(scheduler)(this);
        }
        exports.timestamp = timestamp;
      },
      { rxjs: 333, "rxjs/operators": 547 },
    ],
    323: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Collects all source emissions and emits them as an array when the source completes.
         *
         * <span class="informal">Get all values inside an array when the source completes</span>
         *
         * <img src="./img/toArray.png" width="100%">
         *
         * `toArray` will wait until the source Observable completes
         * before emitting the array containing all emissions.
         * When the source Observable errors no array will be emitted.
         *
         * @example <caption>Create array from input</caption>
         * const input = Rx.Observable.interval(100).take(4);
         *
         * input.toArray()
         *   .subscribe(arr => console.log(arr)); // [0,1,2,3]
         *
         * @see {@link buffer}
         *
         * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
         * @method toArray
         * @owner Observable
         */
        function toArray() {
          return operators_1.toArray()(this);
        }
        exports.toArray = toArray;
      },
      { "rxjs/operators": 547 },
    ],
    324: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Branch out the source Observable values as a nested Observable whenever
         * `windowBoundaries` emits.
         *
         * <span class="informal">It's like {@link buffer}, but emits a nested Observable
         * instead of an array.</span>
         *
         * <img src="./img/window.png" width="100%">
         *
         * Returns an Observable that emits windows of items it collects from the source
         * Observable. The output Observable emits connected, non-overlapping
         * windows. It emits the current window and opens a new one whenever the
         * Observable `windowBoundaries` emits an item. Because each window is an
         * Observable, the output is a higher-order Observable.
         *
         * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var interval = Rx.Observable.interval(1000);
         * var result = clicks.window(interval)
         *   .map(win => win.take(2)) // each window has at most 2 emissions
         *   .mergeAll(); // flatten the Observable-of-Observables
         * result.subscribe(x => console.log(x));
         *
         * @see {@link windowCount}
         * @see {@link windowTime}
         * @see {@link windowToggle}
         * @see {@link windowWhen}
         * @see {@link buffer}
         *
         * @param {Observable<any>} windowBoundaries An Observable that completes the
         * previous window and starts a new window.
         * @return {Observable<Observable<T>>} An Observable of windows, which are
         * Observables emitting values of the source Observable.
         * @method window
         * @owner Observable
         */
        function window(windowBoundaries) {
          return operators_1.window(windowBoundaries)(this);
        }
        exports.window = window;
      },
      { "rxjs/operators": 547 },
    ],
    325: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Branch out the source Observable values as a nested Observable with each
         * nested Observable emitting at most `windowSize` values.
         *
         * <span class="informal">It's like {@link bufferCount}, but emits a nested
         * Observable instead of an array.</span>
         *
         * <img src="./img/windowCount.png" width="100%">
         *
         * Returns an Observable that emits windows of items it collects from the source
         * Observable. The output Observable emits windows every `startWindowEvery`
         * items, each containing no more than `windowSize` items. When the source
         * Observable completes or encounters an error, the output Observable emits
         * the current window and propagates the notification from the source
         * Observable. If `startWindowEvery` is not provided, then new windows are
         * started immediately at the start of the source and when each window completes
         * with size `windowSize`.
         *
         * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.windowCount(3)
         *   .map(win => win.skip(1)) // skip first of every 3 clicks
         *   .mergeAll(); // flatten the Observable-of-Observables
         * result.subscribe(x => console.log(x));
         *
         * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks.windowCount(2, 3)
         *   .mergeAll(); // flatten the Observable-of-Observables
         * result.subscribe(x => console.log(x));
         *
         * @see {@link window}
         * @see {@link windowTime}
         * @see {@link windowToggle}
         * @see {@link windowWhen}
         * @see {@link bufferCount}
         *
         * @param {number} windowSize The maximum number of values emitted by each
         * window.
         * @param {number} [startWindowEvery] Interval at which to start a new window.
         * For example if `startWindowEvery` is `2`, then a new window will be started
         * on every other value from the source. A new window is started at the
         * beginning of the source by default.
         * @return {Observable<Observable<T>>} An Observable of windows, which in turn
         * are Observable of values.
         * @method windowCount
         * @owner Observable
         */
        function windowCount(windowSize, startWindowEvery) {
          if (startWindowEvery === void 0) {
            startWindowEvery = 0;
          }
          return operators_1.windowCount(windowSize, startWindowEvery)(this);
        }
        exports.windowCount = windowCount;
      },
      { "rxjs/operators": 547 },
    ],
    326: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        var internal_compatibility_1 = require("rxjs/internal-compatibility");
        var operators_1 = require("rxjs/operators");
        function windowTime(windowTimeSpan) {
          var scheduler = rxjs_1.asyncScheduler;
          var windowCreationInterval = null;
          var maxWindowSize = Number.POSITIVE_INFINITY;
          if (internal_compatibility_1.isScheduler(arguments[3])) {
            scheduler = arguments[3];
          }
          if (internal_compatibility_1.isScheduler(arguments[2])) {
            scheduler = arguments[2];
          } else if (internal_compatibility_1.isNumeric(arguments[2])) {
            maxWindowSize = arguments[2];
          }
          if (internal_compatibility_1.isScheduler(arguments[1])) {
            scheduler = arguments[1];
          } else if (internal_compatibility_1.isNumeric(arguments[1])) {
            windowCreationInterval = arguments[1];
          }
          return operators_1.windowTime(
            windowTimeSpan,
            windowCreationInterval,
            maxWindowSize,
            scheduler
          )(this);
        }
        exports.windowTime = windowTime;
      },
      { rxjs: 333, "rxjs/internal-compatibility": 334, "rxjs/operators": 547 },
    ],
    327: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Branch out the source Observable values as a nested Observable starting from
         * an emission from `openings` and ending when the output of `closingSelector`
         * emits.
         *
         * <span class="informal">It's like {@link bufferToggle}, but emits a nested
         * Observable instead of an array.</span>
         *
         * <img src="./img/windowToggle.png" width="100%">
         *
         * Returns an Observable that emits windows of items it collects from the source
         * Observable. The output Observable emits windows that contain those items
         * emitted by the source Observable between the time when the `openings`
         * Observable emits an item and when the Observable returned by
         * `closingSelector` emits an item.
         *
         * @example <caption>Every other second, emit the click events from the next 500ms</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var openings = Rx.Observable.interval(1000);
         * var result = clicks.windowToggle(openings, i =>
         *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
         * ).mergeAll();
         * result.subscribe(x => console.log(x));
         *
         * @see {@link window}
         * @see {@link windowCount}
         * @see {@link windowTime}
         * @see {@link windowWhen}
         * @see {@link bufferToggle}
         *
         * @param {Observable<O>} openings An observable of notifications to start new
         * windows.
         * @param {function(value: O): Observable} closingSelector A function that takes
         * the value emitted by the `openings` observable and returns an Observable,
         * which, when it emits (either `next` or `complete`), signals that the
         * associated window should complete.
         * @return {Observable<Observable<T>>} An observable of windows, which in turn
         * are Observables.
         * @method windowToggle
         * @owner Observable
         */
        function windowToggle(openings, closingSelector) {
          return operators_1.windowToggle(openings, closingSelector)(this);
        }
        exports.windowToggle = windowToggle;
      },
      { "rxjs/operators": 547 },
    ],
    328: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * Branch out the source Observable values as a nested Observable using a
         * factory function of closing Observables to determine when to start a new
         * window.
         *
         * <span class="informal">It's like {@link bufferWhen}, but emits a nested
         * Observable instead of an array.</span>
         *
         * <img src="./img/windowWhen.png" width="100%">
         *
         * Returns an Observable that emits windows of items it collects from the source
         * Observable. The output Observable emits connected, non-overlapping windows.
         * It emits the current window and opens a new one whenever the Observable
         * produced by the specified `closingSelector` function emits an item. The first
         * window is opened immediately when subscribing to the output Observable.
         *
         * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var result = clicks
         *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
         *   .map(win => win.take(2)) // each window has at most 2 emissions
         *   .mergeAll(); // flatten the Observable-of-Observables
         * result.subscribe(x => console.log(x));
         *
         * @see {@link window}
         * @see {@link windowCount}
         * @see {@link windowTime}
         * @see {@link windowToggle}
         * @see {@link bufferWhen}
         *
         * @param {function(): Observable} closingSelector A function that takes no
         * arguments and returns an Observable that signals (on either `next` or
         * `complete`) when to close the previous window and start a new one.
         * @return {Observable<Observable<T>>} An observable of windows, which in turn
         * are Observables.
         * @method windowWhen
         * @owner Observable
         */
        function windowWhen(closingSelector) {
          return operators_1.windowWhen(closingSelector)(this);
        }
        exports.windowWhen = windowWhen;
      },
      { "rxjs/operators": 547 },
    ],
    329: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /* tslint:enable:max-line-length */
        /**
         * Combines the source Observable with other Observables to create an Observable
         * whose values are calculated from the latest values of each, only when the
         * source emits.
         *
         * <span class="informal">Whenever the source Observable emits a value, it
         * computes a formula using that value plus the latest values from other input
         * Observables, then emits the output of that formula.</span>
         *
         * <img src="./img/withLatestFrom.png" width="100%">
         *
         * `withLatestFrom` combines each value from the source Observable (the
         * instance) with the latest values from the other input Observables only when
         * the source emits a value, optionally using a `project` function to determine
         * the value to be emitted on the output Observable. All input Observables must
         * emit at least one value before the output Observable will emit a value.
         *
         * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * var timer = Rx.Observable.interval(1000);
         * var result = clicks.withLatestFrom(timer);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link combineLatest}
         *
         * @param {ObservableInput} other An input Observable to combine with the source
         * Observable. More than one input Observables may be given as argument.
         * @param {Function} [project] Projection function for combining values
         * together. Receives all values in order of the Observables passed, where the
         * first parameter is a value from the source Observable. (e.g.
         * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
         * passed, arrays will be emitted on the output Observable.
         * @return {Observable} An Observable of projected values from the most recent
         * values from each input Observable, or an array of the most recent values from
         * each input Observable.
         * @method withLatestFrom
         * @owner Observable
         */
        function withLatestFrom() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return operators_1.withLatestFrom.apply(void 0, args)(this);
        }
        exports.withLatestFrom = withLatestFrom;
      },
      { "rxjs/operators": 547 },
    ],
    330: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var rxjs_1 = require("rxjs");
        /* tslint:enable:max-line-length */
        /**
         * @param observables
         * @return {Observable<R>}
         * @method zip
         * @owner Observable
         */
        function zipProto() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return this.lift.call(
            rxjs_1.zip.apply(void 0, [this].concat(observables))
          );
        }
        exports.zipProto = zipProto;
      },
      { rxjs: 333 },
    ],
    331: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var operators_1 = require("rxjs/operators");
        /**
         * @param project
         * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
         * @method zipAll
         * @owner Observable
         */
        function zipAll(project) {
          return operators_1.zipAll(project)(this);
        }
        exports.zipAll = zipAll;
      },
      { "rxjs/operators": 547 },
    ],
    332: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ajax_1 = require("../internal/observable/dom/ajax");
        exports.ajax = ajax_1.ajax;
        var AjaxObservable_1 = require("../internal/observable/dom/AjaxObservable");
        exports.AjaxResponse = AjaxObservable_1.AjaxResponse;
        exports.AjaxError = AjaxObservable_1.AjaxError;
        exports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;
      },
      {
        "../internal/observable/dom/AjaxObservable": 356,
        "../internal/observable/dom/ajax": 358,
      },
    ],
    333: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("./internal/Observable");
        exports.Observable = Observable_1.Observable;
        var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
        exports.ConnectableObservable =
          ConnectableObservable_1.ConnectableObservable;
        var groupBy_1 = require("./internal/operators/groupBy");
        exports.GroupedObservable = groupBy_1.GroupedObservable;
        var observable_1 = require("./internal/symbol/observable");
        exports.observable = observable_1.observable;
        var Subject_1 = require("./internal/Subject");
        exports.Subject = Subject_1.Subject;
        var BehaviorSubject_1 = require("./internal/BehaviorSubject");
        exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
        var ReplaySubject_1 = require("./internal/ReplaySubject");
        exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
        var AsyncSubject_1 = require("./internal/AsyncSubject");
        exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
        var asap_1 = require("./internal/scheduler/asap");
        exports.asapScheduler = asap_1.asap;
        var async_1 = require("./internal/scheduler/async");
        exports.asyncScheduler = async_1.async;
        var queue_1 = require("./internal/scheduler/queue");
        exports.queueScheduler = queue_1.queue;
        var animationFrame_1 = require("./internal/scheduler/animationFrame");
        exports.animationFrameScheduler = animationFrame_1.animationFrame;
        var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
        exports.VirtualTimeScheduler =
          VirtualTimeScheduler_1.VirtualTimeScheduler;
        exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;
        var Scheduler_1 = require("./internal/Scheduler");
        exports.Scheduler = Scheduler_1.Scheduler;
        var Subscription_1 = require("./internal/Subscription");
        exports.Subscription = Subscription_1.Subscription;
        var Subscriber_1 = require("./internal/Subscriber");
        exports.Subscriber = Subscriber_1.Subscriber;
        var Notification_1 = require("./internal/Notification");
        exports.Notification = Notification_1.Notification;
        exports.NotificationKind = Notification_1.NotificationKind;
        var pipe_1 = require("./internal/util/pipe");
        exports.pipe = pipe_1.pipe;
        var noop_1 = require("./internal/util/noop");
        exports.noop = noop_1.noop;
        var identity_1 = require("./internal/util/identity");
        exports.identity = identity_1.identity;
        var isObservable_1 = require("./internal/util/isObservable");
        exports.isObservable = isObservable_1.isObservable;
        var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
        exports.ArgumentOutOfRangeError =
          ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        var EmptyError_1 = require("./internal/util/EmptyError");
        exports.EmptyError = EmptyError_1.EmptyError;
        var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
        exports.ObjectUnsubscribedError =
          ObjectUnsubscribedError_1.ObjectUnsubscribedError;
        var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
        exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
        var TimeoutError_1 = require("./internal/util/TimeoutError");
        exports.TimeoutError = TimeoutError_1.TimeoutError;
        var bindCallback_1 = require("./internal/observable/bindCallback");
        exports.bindCallback = bindCallback_1.bindCallback;
        var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
        exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
        var combineLatest_1 = require("./internal/observable/combineLatest");
        exports.combineLatest = combineLatest_1.combineLatest;
        var concat_1 = require("./internal/observable/concat");
        exports.concat = concat_1.concat;
        var defer_1 = require("./internal/observable/defer");
        exports.defer = defer_1.defer;
        var empty_1 = require("./internal/observable/empty");
        exports.empty = empty_1.empty;
        var forkJoin_1 = require("./internal/observable/forkJoin");
        exports.forkJoin = forkJoin_1.forkJoin;
        var from_1 = require("./internal/observable/from");
        exports.from = from_1.from;
        var fromEvent_1 = require("./internal/observable/fromEvent");
        exports.fromEvent = fromEvent_1.fromEvent;
        var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
        exports.fromEventPattern = fromEventPattern_1.fromEventPattern;
        var generate_1 = require("./internal/observable/generate");
        exports.generate = generate_1.generate;
        var iif_1 = require("./internal/observable/iif");
        exports.iif = iif_1.iif;
        var interval_1 = require("./internal/observable/interval");
        exports.interval = interval_1.interval;
        var merge_1 = require("./internal/observable/merge");
        exports.merge = merge_1.merge;
        var never_1 = require("./internal/observable/never");
        exports.never = never_1.never;
        var of_1 = require("./internal/observable/of");
        exports.of = of_1.of;
        var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
        exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
        var pairs_1 = require("./internal/observable/pairs");
        exports.pairs = pairs_1.pairs;
        var partition_1 = require("./internal/observable/partition");
        exports.partition = partition_1.partition;
        var race_1 = require("./internal/observable/race");
        exports.race = race_1.race;
        var range_1 = require("./internal/observable/range");
        exports.range = range_1.range;
        var throwError_1 = require("./internal/observable/throwError");
        exports.throwError = throwError_1.throwError;
        var timer_1 = require("./internal/observable/timer");
        exports.timer = timer_1.timer;
        var using_1 = require("./internal/observable/using");
        exports.using = using_1.using;
        var zip_1 = require("./internal/observable/zip");
        exports.zip = zip_1.zip;
        var scheduled_1 = require("./internal/scheduled/scheduled");
        exports.scheduled = scheduled_1.scheduled;
        var empty_2 = require("./internal/observable/empty");
        exports.EMPTY = empty_2.EMPTY;
        var never_2 = require("./internal/observable/never");
        exports.NEVER = never_2.NEVER;
        var config_1 = require("./internal/config");
        exports.config = config_1.config;
      },
      {
        "./internal/AsyncSubject": 335,
        "./internal/BehaviorSubject": 336,
        "./internal/Notification": 338,
        "./internal/Observable": 339,
        "./internal/ReplaySubject": 342,
        "./internal/Scheduler": 343,
        "./internal/Subject": 344,
        "./internal/Subscriber": 346,
        "./internal/Subscription": 347,
        "./internal/config": 348,
        "./internal/observable/ConnectableObservable": 349,
        "./internal/observable/bindCallback": 351,
        "./internal/observable/bindNodeCallback": 352,
        "./internal/observable/combineLatest": 353,
        "./internal/observable/concat": 354,
        "./internal/observable/defer": 355,
        "./internal/observable/empty": 360,
        "./internal/observable/forkJoin": 361,
        "./internal/observable/from": 362,
        "./internal/observable/fromEvent": 364,
        "./internal/observable/fromEventPattern": 365,
        "./internal/observable/generate": 368,
        "./internal/observable/iif": 369,
        "./internal/observable/interval": 370,
        "./internal/observable/merge": 371,
        "./internal/observable/never": 372,
        "./internal/observable/of": 373,
        "./internal/observable/onErrorResumeNext": 374,
        "./internal/observable/pairs": 375,
        "./internal/observable/partition": 376,
        "./internal/observable/race": 377,
        "./internal/observable/range": 378,
        "./internal/observable/throwError": 379,
        "./internal/observable/timer": 380,
        "./internal/observable/using": 381,
        "./internal/observable/zip": 382,
        "./internal/operators/groupBy": 418,
        "./internal/scheduled/scheduled": 490,
        "./internal/scheduler/VirtualTimeScheduler": 500,
        "./internal/scheduler/animationFrame": 501,
        "./internal/scheduler/asap": 502,
        "./internal/scheduler/async": 503,
        "./internal/scheduler/queue": 504,
        "./internal/symbol/observable": 506,
        "./internal/util/ArgumentOutOfRangeError": 513,
        "./internal/util/EmptyError": 514,
        "./internal/util/ObjectUnsubscribedError": 516,
        "./internal/util/TimeoutError": 517,
        "./internal/util/UnsubscriptionError": 518,
        "./internal/util/identity": 523,
        "./internal/util/isObservable": 532,
        "./internal/util/noop": 535,
        "./internal/util/pipe": 537,
      },
    ],
    334: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var config_1 = require("../internal/config");
        exports.config = config_1.config;
        var InnerSubscriber_1 = require("../internal/InnerSubscriber");
        exports.InnerSubscriber = InnerSubscriber_1.InnerSubscriber;
        var OuterSubscriber_1 = require("../internal/OuterSubscriber");
        exports.OuterSubscriber = OuterSubscriber_1.OuterSubscriber;
        var Scheduler_1 = require("../internal/Scheduler");
        exports.Scheduler = Scheduler_1.Scheduler;
        var Subject_1 = require("../internal/Subject");
        exports.AnonymousSubject = Subject_1.AnonymousSubject;
        var SubjectSubscription_1 = require("../internal/SubjectSubscription");
        exports.SubjectSubscription = SubjectSubscription_1.SubjectSubscription;
        var Subscriber_1 = require("../internal/Subscriber");
        exports.Subscriber = Subscriber_1.Subscriber;
        var fromPromise_1 = require("../internal/observable/fromPromise");
        exports.fromPromise = fromPromise_1.fromPromise;
        var fromIterable_1 = require("../internal/observable/fromIterable");
        exports.fromIterable = fromIterable_1.fromIterable;
        var ajax_1 = require("../internal/observable/dom/ajax");
        exports.ajax = ajax_1.ajax;
        var webSocket_1 = require("../internal/observable/dom/webSocket");
        exports.webSocket = webSocket_1.webSocket;
        var AjaxObservable_1 = require("../internal/observable/dom/AjaxObservable");
        exports.ajaxGet = AjaxObservable_1.ajaxGet;
        exports.ajaxPost = AjaxObservable_1.ajaxPost;
        exports.ajaxDelete = AjaxObservable_1.ajaxDelete;
        exports.ajaxPut = AjaxObservable_1.ajaxPut;
        exports.ajaxPatch = AjaxObservable_1.ajaxPatch;
        exports.ajaxGetJSON = AjaxObservable_1.ajaxGetJSON;
        exports.AjaxObservable = AjaxObservable_1.AjaxObservable;
        exports.AjaxSubscriber = AjaxObservable_1.AjaxSubscriber;
        exports.AjaxResponse = AjaxObservable_1.AjaxResponse;
        exports.AjaxError = AjaxObservable_1.AjaxError;
        exports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;
        var WebSocketSubject_1 = require("../internal/observable/dom/WebSocketSubject");
        exports.WebSocketSubject = WebSocketSubject_1.WebSocketSubject;
        var combineLatest_1 = require("../internal/observable/combineLatest");
        exports.CombineLatestOperator = combineLatest_1.CombineLatestOperator;
        var range_1 = require("../internal/observable/range");
        exports.dispatch = range_1.dispatch;
        var SubscribeOnObservable_1 = require("../internal/observable/SubscribeOnObservable");
        exports.SubscribeOnObservable =
          SubscribeOnObservable_1.SubscribeOnObservable;
        var timestamp_1 = require("../internal/operators/timestamp");
        exports.Timestamp = timestamp_1.Timestamp;
        var timeInterval_1 = require("../internal/operators/timeInterval");
        exports.TimeInterval = timeInterval_1.TimeInterval;
        var groupBy_1 = require("../internal/operators/groupBy");
        exports.GroupedObservable = groupBy_1.GroupedObservable;
        var throttle_1 = require("../internal/operators/throttle");
        exports.defaultThrottleConfig = throttle_1.defaultThrottleConfig;
        var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
        exports.rxSubscriber = rxSubscriber_1.rxSubscriber;
        var iterator_1 = require("../internal/symbol/iterator");
        exports.iterator = iterator_1.iterator;
        var observable_1 = require("../internal/symbol/observable");
        exports.observable = observable_1.observable;
        var ArgumentOutOfRangeError_1 = require("../internal/util/ArgumentOutOfRangeError");
        exports.ArgumentOutOfRangeError =
          ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        var EmptyError_1 = require("../internal/util/EmptyError");
        exports.EmptyError = EmptyError_1.EmptyError;
        var Immediate_1 = require("../internal/util/Immediate");
        exports.Immediate = Immediate_1.Immediate;
        var ObjectUnsubscribedError_1 = require("../internal/util/ObjectUnsubscribedError");
        exports.ObjectUnsubscribedError =
          ObjectUnsubscribedError_1.ObjectUnsubscribedError;
        var TimeoutError_1 = require("../internal/util/TimeoutError");
        exports.TimeoutError = TimeoutError_1.TimeoutError;
        var UnsubscriptionError_1 = require("../internal/util/UnsubscriptionError");
        exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
        var applyMixins_1 = require("../internal/util/applyMixins");
        exports.applyMixins = applyMixins_1.applyMixins;
        var errorObject_1 = require("../internal/util/errorObject");
        exports.errorObject = errorObject_1.errorObject;
        var hostReportError_1 = require("../internal/util/hostReportError");
        exports.hostReportError = hostReportError_1.hostReportError;
        var identity_1 = require("../internal/util/identity");
        exports.identity = identity_1.identity;
        var isArray_1 = require("../internal/util/isArray");
        exports.isArray = isArray_1.isArray;
        var isArrayLike_1 = require("../internal/util/isArrayLike");
        exports.isArrayLike = isArrayLike_1.isArrayLike;
        var isDate_1 = require("../internal/util/isDate");
        exports.isDate = isDate_1.isDate;
        var isFunction_1 = require("../internal/util/isFunction");
        exports.isFunction = isFunction_1.isFunction;
        var isIterable_1 = require("../internal/util/isIterable");
        exports.isIterable = isIterable_1.isIterable;
        var isNumeric_1 = require("../internal/util/isNumeric");
        exports.isNumeric = isNumeric_1.isNumeric;
        var isObject_1 = require("../internal/util/isObject");
        exports.isObject = isObject_1.isObject;
        var isInteropObservable_1 = require("../internal/util/isInteropObservable");
        exports.isObservable = isInteropObservable_1.isInteropObservable;
        var isPromise_1 = require("../internal/util/isPromise");
        exports.isPromise = isPromise_1.isPromise;
        var isScheduler_1 = require("../internal/util/isScheduler");
        exports.isScheduler = isScheduler_1.isScheduler;
        var noop_1 = require("../internal/util/noop");
        exports.noop = noop_1.noop;
        var not_1 = require("../internal/util/not");
        exports.not = not_1.not;
        var pipe_1 = require("../internal/util/pipe");
        exports.pipe = pipe_1.pipe;
        var root_1 = require("../internal/util/root");
        exports.root = root_1.root;
        var subscribeTo_1 = require("../internal/util/subscribeTo");
        exports.subscribeTo = subscribeTo_1.subscribeTo;
        var subscribeToArray_1 = require("../internal/util/subscribeToArray");
        exports.subscribeToArray = subscribeToArray_1.subscribeToArray;
        var subscribeToIterable_1 = require("../internal/util/subscribeToIterable");
        exports.subscribeToIterable = subscribeToIterable_1.subscribeToIterable;
        var subscribeToObservable_1 = require("../internal/util/subscribeToObservable");
        exports.subscribeToObservable =
          subscribeToObservable_1.subscribeToObservable;
        var subscribeToPromise_1 = require("../internal/util/subscribeToPromise");
        exports.subscribeToPromise = subscribeToPromise_1.subscribeToPromise;
        var subscribeToResult_1 = require("../internal/util/subscribeToResult");
        exports.subscribeToResult = subscribeToResult_1.subscribeToResult;
        var toSubscriber_1 = require("../internal/util/toSubscriber");
        exports.toSubscriber = toSubscriber_1.toSubscriber;
        var tryCatch_1 = require("../internal/util/tryCatch");
        exports.tryCatch = tryCatch_1.tryCatch;
      },
      {
        "../internal/InnerSubscriber": 337,
        "../internal/OuterSubscriber": 341,
        "../internal/Scheduler": 343,
        "../internal/Subject": 344,
        "../internal/SubjectSubscription": 345,
        "../internal/Subscriber": 346,
        "../internal/config": 348,
        "../internal/observable/SubscribeOnObservable": 350,
        "../internal/observable/combineLatest": 353,
        "../internal/observable/dom/AjaxObservable": 356,
        "../internal/observable/dom/WebSocketSubject": 357,
        "../internal/observable/dom/ajax": 358,
        "../internal/observable/dom/webSocket": 359,
        "../internal/observable/fromIterable": 366,
        "../internal/observable/fromPromise": 367,
        "../internal/observable/range": 378,
        "../internal/operators/groupBy": 418,
        "../internal/operators/throttle": 470,
        "../internal/operators/timeInterval": 473,
        "../internal/operators/timestamp": 476,
        "../internal/symbol/iterator": 505,
        "../internal/symbol/observable": 506,
        "../internal/symbol/rxSubscriber": 507,
        "../internal/util/ArgumentOutOfRangeError": 513,
        "../internal/util/EmptyError": 514,
        "../internal/util/Immediate": 515,
        "../internal/util/ObjectUnsubscribedError": 516,
        "../internal/util/TimeoutError": 517,
        "../internal/util/UnsubscriptionError": 518,
        "../internal/util/applyMixins": 519,
        "../internal/util/errorObject": 521,
        "../internal/util/hostReportError": 522,
        "../internal/util/identity": 523,
        "../internal/util/isArray": 524,
        "../internal/util/isArrayLike": 525,
        "../internal/util/isDate": 526,
        "../internal/util/isFunction": 527,
        "../internal/util/isInteropObservable": 528,
        "../internal/util/isIterable": 529,
        "../internal/util/isNumeric": 530,
        "../internal/util/isObject": 531,
        "../internal/util/isPromise": 533,
        "../internal/util/isScheduler": 534,
        "../internal/util/noop": 535,
        "../internal/util/not": 536,
        "../internal/util/pipe": 537,
        "../internal/util/root": 538,
        "../internal/util/subscribeTo": 539,
        "../internal/util/subscribeToArray": 540,
        "../internal/util/subscribeToIterable": 541,
        "../internal/util/subscribeToObservable": 542,
        "../internal/util/subscribeToPromise": 543,
        "../internal/util/subscribeToResult": 544,
        "../internal/util/toSubscriber": 545,
        "../internal/util/tryCatch": 546,
      },
    ],
    335: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("./Subject");
        var Subscription_1 = require("./Subscription");
        var AsyncSubject = (function (_super) {
          __extends(AsyncSubject, _super);
          function AsyncSubject() {
            var _this =
              (_super !== null && _super.apply(this, arguments)) || this;
            _this.value = null;
            _this.hasNext = false;
            _this.hasCompleted = false;
            return _this;
          }
          AsyncSubject.prototype._subscribe = function (subscriber) {
            if (this.hasError) {
              subscriber.error(this.thrownError);
              return Subscription_1.Subscription.EMPTY;
            } else if (this.hasCompleted && this.hasNext) {
              subscriber.next(this.value);
              subscriber.complete();
              return Subscription_1.Subscription.EMPTY;
            }
            return _super.prototype._subscribe.call(this, subscriber);
          };
          AsyncSubject.prototype.next = function (value) {
            if (!this.hasCompleted) {
              this.value = value;
              this.hasNext = true;
            }
          };
          AsyncSubject.prototype.error = function (error) {
            if (!this.hasCompleted) {
              _super.prototype.error.call(this, error);
            }
          };
          AsyncSubject.prototype.complete = function () {
            this.hasCompleted = true;
            if (this.hasNext) {
              _super.prototype.next.call(this, this.value);
            }
            _super.prototype.complete.call(this);
          };
          return AsyncSubject;
        })(Subject_1.Subject);
        exports.AsyncSubject = AsyncSubject;
      },
      { "./Subject": 344, "./Subscription": 347 },
    ],
    336: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("./Subject");
        var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
        var BehaviorSubject = (function (_super) {
          __extends(BehaviorSubject, _super);
          function BehaviorSubject(_value) {
            var _this = _super.call(this) || this;
            _this._value = _value;
            return _this;
          }
          Object.defineProperty(BehaviorSubject.prototype, "value", {
            get: function () {
              return this.getValue();
            },
            enumerable: true,
            configurable: true,
          });
          BehaviorSubject.prototype._subscribe = function (subscriber) {
            var subscription = _super.prototype._subscribe.call(
              this,
              subscriber
            );
            if (subscription && !subscription.closed) {
              subscriber.next(this._value);
            }
            return subscription;
          };
          BehaviorSubject.prototype.getValue = function () {
            if (this.hasError) {
              throw this.thrownError;
            } else if (this.closed) {
              throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            } else {
              return this._value;
            }
          };
          BehaviorSubject.prototype.next = function (value) {
            _super.prototype.next.call(this, (this._value = value));
          };
          return BehaviorSubject;
        })(Subject_1.Subject);
        exports.BehaviorSubject = BehaviorSubject;
      },
      { "./Subject": 344, "./util/ObjectUnsubscribedError": 516 },
    ],
    337: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("./Subscriber");
        var InnerSubscriber = (function (_super) {
          __extends(InnerSubscriber, _super);
          function InnerSubscriber(parent, outerValue, outerIndex) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            _this.outerValue = outerValue;
            _this.outerIndex = outerIndex;
            _this.index = 0;
            return _this;
          }
          InnerSubscriber.prototype._next = function (value) {
            this.parent.notifyNext(
              this.outerValue,
              value,
              this.outerIndex,
              this.index++,
              this
            );
          };
          InnerSubscriber.prototype._error = function (error) {
            this.parent.notifyError(error, this);
            this.unsubscribe();
          };
          InnerSubscriber.prototype._complete = function () {
            this.parent.notifyComplete(this);
            this.unsubscribe();
          };
          return InnerSubscriber;
        })(Subscriber_1.Subscriber);
        exports.InnerSubscriber = InnerSubscriber;
      },
      { "./Subscriber": 346 },
    ],
    338: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var empty_1 = require("./observable/empty");
        var of_1 = require("./observable/of");
        var throwError_1 = require("./observable/throwError");
        var NotificationKind;
        (function (NotificationKind) {
          NotificationKind["NEXT"] = "N";
          NotificationKind["ERROR"] = "E";
          NotificationKind["COMPLETE"] = "C";
        })(
          (NotificationKind =
            exports.NotificationKind || (exports.NotificationKind = {}))
        );
        var Notification = (function () {
          function Notification(kind, value, error) {
            this.kind = kind;
            this.value = value;
            this.error = error;
            this.hasValue = kind === "N";
          }
          Notification.prototype.observe = function (observer) {
            switch (this.kind) {
              case "N":
                return observer.next && observer.next(this.value);
              case "E":
                return observer.error && observer.error(this.error);
              case "C":
                return observer.complete && observer.complete();
            }
          };
          Notification.prototype.do = function (next, error, complete) {
            var kind = this.kind;
            switch (kind) {
              case "N":
                return next && next(this.value);
              case "E":
                return error && error(this.error);
              case "C":
                return complete && complete();
            }
          };
          Notification.prototype.accept = function (
            nextOrObserver,
            error,
            complete
          ) {
            if (nextOrObserver && typeof nextOrObserver.next === "function") {
              return this.observe(nextOrObserver);
            } else {
              return this.do(nextOrObserver, error, complete);
            }
          };
          Notification.prototype.toObservable = function () {
            var kind = this.kind;
            switch (kind) {
              case "N":
                return of_1.of(this.value);
              case "E":
                return throwError_1.throwError(this.error);
              case "C":
                return empty_1.empty();
            }
            throw new Error("unexpected notification kind value");
          };
          Notification.createNext = function (value) {
            if (typeof value !== "undefined") {
              return new Notification("N", value);
            }
            return Notification.undefinedValueNotification;
          };
          Notification.createError = function (err) {
            return new Notification("E", undefined, err);
          };
          Notification.createComplete = function () {
            return Notification.completeNotification;
          };
          Notification.completeNotification = new Notification("C");
          Notification.undefinedValueNotification = new Notification(
            "N",
            undefined
          );
          return Notification;
        })();
        exports.Notification = Notification;
      },
      {
        "./observable/empty": 360,
        "./observable/of": 373,
        "./observable/throwError": 379,
      },
    ],
    339: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var canReportError_1 = require("./util/canReportError");
        var toSubscriber_1 = require("./util/toSubscriber");
        var observable_1 = require("./symbol/observable");
        var pipe_1 = require("./util/pipe");
        var config_1 = require("./config");
        var Observable = (function () {
          function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
              this._subscribe = subscribe;
            }
          }
          Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
          };
          Observable.prototype.subscribe = function (
            observerOrNext,
            error,
            complete
          ) {
            var operator = this.operator;
            var sink = toSubscriber_1.toSubscriber(
              observerOrNext,
              error,
              complete
            );
            if (operator) {
              sink.add(operator.call(sink, this.source));
            } else {
              sink.add(
                this.source ||
                  (config_1.config.useDeprecatedSynchronousErrorHandling &&
                    !sink.syncErrorThrowable)
                  ? this._subscribe(sink)
                  : this._trySubscribe(sink)
              );
            }
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
              if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                  throw sink.syncErrorValue;
                }
              }
            }
            return sink;
          };
          Observable.prototype._trySubscribe = function (sink) {
            try {
              return this._subscribe(sink);
            } catch (err) {
              if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
              }
              if (canReportError_1.canReportError(sink)) {
                sink.error(err);
              } else {
                console.warn(err);
              }
            }
          };
          Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
              var subscription;
              subscription = _this.subscribe(
                function (value) {
                  try {
                    next(value);
                  } catch (err) {
                    reject(err);
                    if (subscription) {
                      subscription.unsubscribe();
                    }
                  }
                },
                reject,
                resolve
              );
            });
          };
          Observable.prototype._subscribe = function (subscriber) {
            var source = this.source;
            return source && source.subscribe(subscriber);
          };
          Observable.prototype[observable_1.observable] = function () {
            return this;
          };
          Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              operations[_i] = arguments[_i];
            }
            if (operations.length === 0) {
              return this;
            }
            return pipe_1.pipeFromArray(operations)(this);
          };
          Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
              var value;
              _this.subscribe(
                function (x) {
                  return (value = x);
                },
                function (err) {
                  return reject(err);
                },
                function () {
                  return resolve(value);
                }
              );
            });
          };
          Observable.create = function (subscribe) {
            return new Observable(subscribe);
          };
          return Observable;
        })();
        exports.Observable = Observable;
        function getPromiseCtor(promiseCtor) {
          if (!promiseCtor) {
            promiseCtor = config_1.config.Promise || Promise;
          }
          if (!promiseCtor) {
            throw new Error("no Promise impl found");
          }
          return promiseCtor;
        }
      },
      {
        "./config": 348,
        "./symbol/observable": 506,
        "./util/canReportError": 520,
        "./util/pipe": 537,
        "./util/toSubscriber": 545,
      },
    ],
    340: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var config_1 = require("./config");
        var hostReportError_1 = require("./util/hostReportError");
        exports.empty = {
          closed: true,
          next: function (value) {},
          error: function (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
              throw err;
            } else {
              hostReportError_1.hostReportError(err);
            }
          },
          complete: function () {},
        };
      },
      { "./config": 348, "./util/hostReportError": 522 },
    ],
    341: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("./Subscriber");
        var OuterSubscriber = (function (_super) {
          __extends(OuterSubscriber, _super);
          function OuterSubscriber() {
            return (_super !== null && _super.apply(this, arguments)) || this;
          }
          OuterSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.destination.next(innerValue);
          };
          OuterSubscriber.prototype.notifyError = function (error, innerSub) {
            this.destination.error(error);
          };
          OuterSubscriber.prototype.notifyComplete = function (innerSub) {
            this.destination.complete();
          };
          return OuterSubscriber;
        })(Subscriber_1.Subscriber);
        exports.OuterSubscriber = OuterSubscriber;
      },
      { "./Subscriber": 346 },
    ],
    342: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("./Subject");
        var queue_1 = require("./scheduler/queue");
        var Subscription_1 = require("./Subscription");
        var observeOn_1 = require("./operators/observeOn");
        var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
        var SubjectSubscription_1 = require("./SubjectSubscription");
        var ReplaySubject = (function (_super) {
          __extends(ReplaySubject, _super);
          function ReplaySubject(bufferSize, windowTime, scheduler) {
            if (bufferSize === void 0) {
              bufferSize = Number.POSITIVE_INFINITY;
            }
            if (windowTime === void 0) {
              windowTime = Number.POSITIVE_INFINITY;
            }
            var _this = _super.call(this) || this;
            _this.scheduler = scheduler;
            _this._events = [];
            _this._infiniteTimeWindow = false;
            _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
            _this._windowTime = windowTime < 1 ? 1 : windowTime;
            if (windowTime === Number.POSITIVE_INFINITY) {
              _this._infiniteTimeWindow = true;
              _this.next = _this.nextInfiniteTimeWindow;
            } else {
              _this.next = _this.nextTimeWindow;
            }
            return _this;
          }
          ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
            var _events = this._events;
            _events.push(value);
            if (_events.length > this._bufferSize) {
              _events.shift();
            }
            _super.prototype.next.call(this, value);
          };
          ReplaySubject.prototype.nextTimeWindow = function (value) {
            this._events.push(new ReplayEvent(this._getNow(), value));
            this._trimBufferThenGetEvents();
            _super.prototype.next.call(this, value);
          };
          ReplaySubject.prototype._subscribe = function (subscriber) {
            var _infiniteTimeWindow = this._infiniteTimeWindow;
            var _events = _infiniteTimeWindow
              ? this._events
              : this._trimBufferThenGetEvents();
            var scheduler = this.scheduler;
            var len = _events.length;
            var subscription;
            if (this.closed) {
              throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            } else if (this.isStopped || this.hasError) {
              subscription = Subscription_1.Subscription.EMPTY;
            } else {
              this.observers.push(subscriber);
              subscription = new SubjectSubscription_1.SubjectSubscription(
                this,
                subscriber
              );
            }
            if (scheduler) {
              subscriber.add(
                (subscriber = new observeOn_1.ObserveOnSubscriber(
                  subscriber,
                  scheduler
                ))
              );
            }
            if (_infiniteTimeWindow) {
              for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
              }
            } else {
              for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
              }
            }
            if (this.hasError) {
              subscriber.error(this.thrownError);
            } else if (this.isStopped) {
              subscriber.complete();
            }
            return subscription;
          };
          ReplaySubject.prototype._getNow = function () {
            return (this.scheduler || queue_1.queue).now();
          };
          ReplaySubject.prototype._trimBufferThenGetEvents = function () {
            var now = this._getNow();
            var _bufferSize = this._bufferSize;
            var _windowTime = this._windowTime;
            var _events = this._events;
            var eventsCount = _events.length;
            var spliceCount = 0;
            while (spliceCount < eventsCount) {
              if (now - _events[spliceCount].time < _windowTime) {
                break;
              }
              spliceCount++;
            }
            if (eventsCount > _bufferSize) {
              spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
            }
            if (spliceCount > 0) {
              _events.splice(0, spliceCount);
            }
            return _events;
          };
          return ReplaySubject;
        })(Subject_1.Subject);
        exports.ReplaySubject = ReplaySubject;
        var ReplayEvent = (function () {
          function ReplayEvent(time, value) {
            this.time = time;
            this.value = value;
          }
          return ReplayEvent;
        })();
      },
      {
        "./Subject": 344,
        "./SubjectSubscription": 345,
        "./Subscription": 347,
        "./operators/observeOn": 433,
        "./scheduler/queue": 504,
        "./util/ObjectUnsubscribedError": 516,
      },
    ],
    343: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Scheduler = (function () {
          function Scheduler(SchedulerAction, now) {
            if (now === void 0) {
              now = Scheduler.now;
            }
            this.SchedulerAction = SchedulerAction;
            this.now = now;
          }
          Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) {
              delay = 0;
            }
            return new this.SchedulerAction(this, work).schedule(state, delay);
          };
          Scheduler.now = function () {
            return Date.now();
          };
          return Scheduler;
        })();
        exports.Scheduler = Scheduler;
      },
      {},
    ],
    344: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("./Observable");
        var Subscriber_1 = require("./Subscriber");
        var Subscription_1 = require("./Subscription");
        var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
        var SubjectSubscription_1 = require("./SubjectSubscription");
        var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
        var SubjectSubscriber = (function (_super) {
          __extends(SubjectSubscriber, _super);
          function SubjectSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            return _this;
          }
          return SubjectSubscriber;
        })(Subscriber_1.Subscriber);
        exports.SubjectSubscriber = SubjectSubscriber;
        var Subject = (function (_super) {
          __extends(Subject, _super);
          function Subject() {
            var _this = _super.call(this) || this;
            _this.observers = [];
            _this.closed = false;
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
          }
          Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
            return new SubjectSubscriber(this);
          };
          Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
          };
          Subject.prototype.next = function (value) {
            if (this.closed) {
              throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            if (!this.isStopped) {
              var observers = this.observers;
              var len = observers.length;
              var copy = observers.slice();
              for (var i = 0; i < len; i++) {
                copy[i].next(value);
              }
            }
          };
          Subject.prototype.error = function (err) {
            if (this.closed) {
              throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            this.hasError = true;
            this.thrownError = err;
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
              copy[i].error(err);
            }
            this.observers.length = 0;
          };
          Subject.prototype.complete = function () {
            if (this.closed) {
              throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
              copy[i].complete();
            }
            this.observers.length = 0;
          };
          Subject.prototype.unsubscribe = function () {
            this.isStopped = true;
            this.closed = true;
            this.observers = null;
          };
          Subject.prototype._trySubscribe = function (subscriber) {
            if (this.closed) {
              throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            } else {
              return _super.prototype._trySubscribe.call(this, subscriber);
            }
          };
          Subject.prototype._subscribe = function (subscriber) {
            if (this.closed) {
              throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            } else if (this.hasError) {
              subscriber.error(this.thrownError);
              return Subscription_1.Subscription.EMPTY;
            } else if (this.isStopped) {
              subscriber.complete();
              return Subscription_1.Subscription.EMPTY;
            } else {
              this.observers.push(subscriber);
              return new SubjectSubscription_1.SubjectSubscription(
                this,
                subscriber
              );
            }
          };
          Subject.prototype.asObservable = function () {
            var observable = new Observable_1.Observable();
            observable.source = this;
            return observable;
          };
          Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
          };
          return Subject;
        })(Observable_1.Observable);
        exports.Subject = Subject;
        var AnonymousSubject = (function (_super) {
          __extends(AnonymousSubject, _super);
          function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
          }
          AnonymousSubject.prototype.next = function (value) {
            var destination = this.destination;
            if (destination && destination.next) {
              destination.next(value);
            }
          };
          AnonymousSubject.prototype.error = function (err) {
            var destination = this.destination;
            if (destination && destination.error) {
              this.destination.error(err);
            }
          };
          AnonymousSubject.prototype.complete = function () {
            var destination = this.destination;
            if (destination && destination.complete) {
              this.destination.complete();
            }
          };
          AnonymousSubject.prototype._subscribe = function (subscriber) {
            var source = this.source;
            if (source) {
              return this.source.subscribe(subscriber);
            } else {
              return Subscription_1.Subscription.EMPTY;
            }
          };
          return AnonymousSubject;
        })(Subject);
        exports.AnonymousSubject = AnonymousSubject;
      },
      {
        "../internal/symbol/rxSubscriber": 507,
        "./Observable": 339,
        "./SubjectSubscription": 345,
        "./Subscriber": 346,
        "./Subscription": 347,
        "./util/ObjectUnsubscribedError": 516,
      },
    ],
    345: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscription_1 = require("./Subscription");
        var SubjectSubscription = (function (_super) {
          __extends(SubjectSubscription, _super);
          function SubjectSubscription(subject, subscriber) {
            var _this = _super.call(this) || this;
            _this.subject = subject;
            _this.subscriber = subscriber;
            _this.closed = false;
            return _this;
          }
          SubjectSubscription.prototype.unsubscribe = function () {
            if (this.closed) {
              return;
            }
            this.closed = true;
            var subject = this.subject;
            var observers = subject.observers;
            this.subject = null;
            if (
              !observers ||
              observers.length === 0 ||
              subject.isStopped ||
              subject.closed
            ) {
              return;
            }
            var subscriberIndex = observers.indexOf(this.subscriber);
            if (subscriberIndex !== -1) {
              observers.splice(subscriberIndex, 1);
            }
          };
          return SubjectSubscription;
        })(Subscription_1.Subscription);
        exports.SubjectSubscription = SubjectSubscription;
      },
      { "./Subscription": 347 },
    ],
    346: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var isFunction_1 = require("./util/isFunction");
        var Observer_1 = require("./Observer");
        var Subscription_1 = require("./Subscription");
        var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
        var config_1 = require("./config");
        var hostReportError_1 = require("./util/hostReportError");
        var Subscriber = (function (_super) {
          __extends(Subscriber, _super);
          function Subscriber(destinationOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this.syncErrorValue = null;
            _this.syncErrorThrown = false;
            _this.syncErrorThrowable = false;
            _this.isStopped = false;
            switch (arguments.length) {
              case 0:
                _this.destination = Observer_1.empty;
                break;
              case 1:
                if (!destinationOrNext) {
                  _this.destination = Observer_1.empty;
                  break;
                }
                if (typeof destinationOrNext === "object") {
                  if (destinationOrNext instanceof Subscriber) {
                    _this.syncErrorThrowable =
                      destinationOrNext.syncErrorThrowable;
                    _this.destination = destinationOrNext;
                    destinationOrNext.add(_this);
                  } else {
                    _this.syncErrorThrowable = true;
                    _this.destination = new SafeSubscriber(
                      _this,
                      destinationOrNext
                    );
                  }
                  break;
                }
              default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(
                  _this,
                  destinationOrNext,
                  error,
                  complete
                );
                break;
            }
            return _this;
          }
          Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {
            return this;
          };
          Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
          };
          Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
              this._next(value);
            }
          };
          Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
              this.isStopped = true;
              this._error(err);
            }
          };
          Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
              this.isStopped = true;
              this._complete();
            }
          };
          Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
              return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
          };
          Subscriber.prototype._next = function (value) {
            this.destination.next(value);
          };
          Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
          };
          Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
          };
          Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _parentOrParents = this._parentOrParents;
            this._parentOrParents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parentOrParents = _parentOrParents;
            return this;
          };
          return Subscriber;
        })(Subscription_1.Subscription);
        exports.Subscriber = Subscriber;
        var SafeSubscriber = (function (_super) {
          __extends(SafeSubscriber, _super);
          function SafeSubscriber(
            _parentSubscriber,
            observerOrNext,
            error,
            complete
          ) {
            var _this = _super.call(this) || this;
            _this._parentSubscriber = _parentSubscriber;
            var next;
            var context = _this;
            if (isFunction_1.isFunction(observerOrNext)) {
              next = observerOrNext;
            } else if (observerOrNext) {
              next = observerOrNext.next;
              error = observerOrNext.error;
              complete = observerOrNext.complete;
              if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                  _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
              }
            }
            _this._context = context;
            _this._next = next;
            _this._error = error;
            _this._complete = complete;
            return _this;
          }
          SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
              var _parentSubscriber = this._parentSubscriber;
              if (
                !config_1.config.useDeprecatedSynchronousErrorHandling ||
                !_parentSubscriber.syncErrorThrowable
              ) {
                this.__tryOrUnsub(this._next, value);
              } else if (
                this.__tryOrSetError(_parentSubscriber, this._next, value)
              ) {
                this.unsubscribe();
              }
            }
          };
          SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
              var _parentSubscriber = this._parentSubscriber;
              var useDeprecatedSynchronousErrorHandling =
                config_1.config.useDeprecatedSynchronousErrorHandling;
              if (this._error) {
                if (
                  !useDeprecatedSynchronousErrorHandling ||
                  !_parentSubscriber.syncErrorThrowable
                ) {
                  this.__tryOrUnsub(this._error, err);
                  this.unsubscribe();
                } else {
                  this.__tryOrSetError(_parentSubscriber, this._error, err);
                  this.unsubscribe();
                }
              } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                  throw err;
                }
                hostReportError_1.hostReportError(err);
              } else {
                if (useDeprecatedSynchronousErrorHandling) {
                  _parentSubscriber.syncErrorValue = err;
                  _parentSubscriber.syncErrorThrown = true;
                } else {
                  hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
              }
            }
          };
          SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
              var _parentSubscriber = this._parentSubscriber;
              if (this._complete) {
                var wrappedComplete = function () {
                  return _this._complete.call(_this._context);
                };
                if (
                  !config_1.config.useDeprecatedSynchronousErrorHandling ||
                  !_parentSubscriber.syncErrorThrowable
                ) {
                  this.__tryOrUnsub(wrappedComplete);
                  this.unsubscribe();
                } else {
                  this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                  this.unsubscribe();
                }
              } else {
                this.unsubscribe();
              }
            }
          };
          SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
              fn.call(this._context, value);
            } catch (err) {
              this.unsubscribe();
              if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
              } else {
                hostReportError_1.hostReportError(err);
              }
            }
          };
          SafeSubscriber.prototype.__tryOrSetError = function (
            parent,
            fn,
            value
          ) {
            if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
              throw new Error("bad call");
            }
            try {
              fn.call(this._context, value);
            } catch (err) {
              if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
              } else {
                hostReportError_1.hostReportError(err);
                return true;
              }
            }
            return false;
          };
          SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
          };
          return SafeSubscriber;
        })(Subscriber);
        exports.SafeSubscriber = SafeSubscriber;
      },
      {
        "../internal/symbol/rxSubscriber": 507,
        "./Observer": 340,
        "./Subscription": 347,
        "./config": 348,
        "./util/hostReportError": 522,
        "./util/isFunction": 527,
      },
    ],
    347: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isArray_1 = require("./util/isArray");
        var isObject_1 = require("./util/isObject");
        var isFunction_1 = require("./util/isFunction");
        var UnsubscriptionError_1 = require("./util/UnsubscriptionError");
        var Subscription = (function () {
          function Subscription(unsubscribe) {
            this.closed = false;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (unsubscribe) {
              this._unsubscribe = unsubscribe;
            }
          }
          Subscription.prototype.unsubscribe = function () {
            var errors;
            if (this.closed) {
              return;
            }
            var _a = this,
              _parentOrParents = _a._parentOrParents,
              _unsubscribe = _a._unsubscribe,
              _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (_parentOrParents instanceof Subscription) {
              _parentOrParents.remove(this);
            } else if (_parentOrParents !== null) {
              for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
              }
            }
            if (isFunction_1.isFunction(_unsubscribe)) {
              try {
                _unsubscribe.call(this);
              } catch (e) {
                errors =
                  e instanceof UnsubscriptionError_1.UnsubscriptionError
                    ? flattenUnsubscriptionErrors(e.errors)
                    : [e];
              }
            }
            if (isArray_1.isArray(_subscriptions)) {
              var index = -1;
              var len = _subscriptions.length;
              while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                  try {
                    sub.unsubscribe();
                  } catch (e) {
                    errors = errors || [];
                    if (
                      e instanceof UnsubscriptionError_1.UnsubscriptionError
                    ) {
                      errors = errors.concat(
                        flattenUnsubscriptionErrors(e.errors)
                      );
                    } else {
                      errors.push(e);
                    }
                  }
                }
              }
            }
            if (errors) {
              throw new UnsubscriptionError_1.UnsubscriptionError(errors);
            }
          };
          Subscription.prototype.add = function (teardown) {
            var subscription = teardown;
            if (!teardown) {
              return Subscription.EMPTY;
            }
            switch (typeof teardown) {
              case "function":
                subscription = new Subscription(teardown);
              case "object":
                if (
                  subscription === this ||
                  subscription.closed ||
                  typeof subscription.unsubscribe !== "function"
                ) {
                  return subscription;
                } else if (this.closed) {
                  subscription.unsubscribe();
                  return subscription;
                } else if (!(subscription instanceof Subscription)) {
                  var tmp = subscription;
                  subscription = new Subscription();
                  subscription._subscriptions = [tmp];
                }
                break;
              default: {
                throw new Error(
                  "unrecognized teardown " +
                    teardown +
                    " added to Subscription."
                );
              }
            }
            var _parentOrParents = subscription._parentOrParents;
            if (_parentOrParents === null) {
              subscription._parentOrParents = this;
            } else if (_parentOrParents instanceof Subscription) {
              if (_parentOrParents === this) {
                return subscription;
              }
              subscription._parentOrParents = [_parentOrParents, this];
            } else if (_parentOrParents.indexOf(this) === -1) {
              _parentOrParents.push(this);
            } else {
              return subscription;
            }
            var subscriptions = this._subscriptions;
            if (subscriptions === null) {
              this._subscriptions = [subscription];
            } else {
              subscriptions.push(subscription);
            }
            return subscription;
          };
          Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
              var subscriptionIndex = subscriptions.indexOf(subscription);
              if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
              }
            }
          };
          Subscription.EMPTY = (function (empty) {
            empty.closed = true;
            return empty;
          })(new Subscription());
          return Subscription;
        })();
        exports.Subscription = Subscription;
        function flattenUnsubscriptionErrors(errors) {
          return errors.reduce(function (errs, err) {
            return errs.concat(
              err instanceof UnsubscriptionError_1.UnsubscriptionError
                ? err.errors
                : err
            );
          }, []);
        }
      },
      {
        "./util/UnsubscriptionError": 518,
        "./util/isArray": 524,
        "./util/isFunction": 527,
        "./util/isObject": 531,
      },
    ],
    348: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var _enable_super_gross_mode_that_will_cause_bad_things = false;
        exports.config = {
          Promise: undefined,
          set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
              var error = new Error();
              console.warn(
                "DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" +
                  error.stack
              );
            } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
              console.log(
                "RxJS: Back to a better error behavior. Thank you. <3"
              );
            }
            _enable_super_gross_mode_that_will_cause_bad_things = value;
          },
          get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
          },
        };
      },
      {},
    ],
    349: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var Observable_1 = require("../Observable");
        var Subscriber_1 = require("../Subscriber");
        var Subscription_1 = require("../Subscription");
        var refCount_1 = require("../operators/refCount");
        var ConnectableObservable = (function (_super) {
          __extends(ConnectableObservable, _super);
          function ConnectableObservable(source, subjectFactory) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subjectFactory = subjectFactory;
            _this._refCount = 0;
            _this._isComplete = false;
            return _this;
          }
          ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
          };
          ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
              this._subject = this.subjectFactory();
            }
            return this._subject;
          };
          ConnectableObservable.prototype.connect = function () {
            var connection = this._connection;
            if (!connection) {
              this._isComplete = false;
              connection = this._connection = new Subscription_1.Subscription();
              connection.add(
                this.source.subscribe(
                  new ConnectableSubscriber(this.getSubject(), this)
                )
              );
              if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
              }
            }
            return connection;
          };
          ConnectableObservable.prototype.refCount = function () {
            return refCount_1.refCount()(this);
          };
          return ConnectableObservable;
        })(Observable_1.Observable);
        exports.ConnectableObservable = ConnectableObservable;
        exports.connectableObservableDescriptor = (function () {
          var connectableProto = ConnectableObservable.prototype;
          return {
            operator: { value: null },
            _refCount: { value: 0, writable: true },
            _subject: { value: null, writable: true },
            _connection: { value: null, writable: true },
            _subscribe: { value: connectableProto._subscribe },
            _isComplete: {
              value: connectableProto._isComplete,
              writable: true,
            },
            getSubject: { value: connectableProto.getSubject },
            connect: { value: connectableProto.connect },
            refCount: { value: connectableProto.refCount },
          };
        })();
        var ConnectableSubscriber = (function (_super) {
          __extends(ConnectableSubscriber, _super);
          function ConnectableSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
          }
          ConnectableSubscriber.prototype._error = function (err) {
            this._unsubscribe();
            _super.prototype._error.call(this, err);
          };
          ConnectableSubscriber.prototype._complete = function () {
            this.connectable._isComplete = true;
            this._unsubscribe();
            _super.prototype._complete.call(this);
          };
          ConnectableSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (connectable) {
              this.connectable = null;
              var connection = connectable._connection;
              connectable._refCount = 0;
              connectable._subject = null;
              connectable._connection = null;
              if (connection) {
                connection.unsubscribe();
              }
            }
          };
          return ConnectableSubscriber;
        })(Subject_1.SubjectSubscriber);
        var RefCountOperator = (function () {
          function RefCountOperator(connectable) {
            this.connectable = connectable;
          }
          RefCountOperator.prototype.call = function (subscriber, source) {
            var connectable = this.connectable;
            connectable._refCount++;
            var refCounter = new RefCountSubscriber(subscriber, connectable);
            var subscription = source.subscribe(refCounter);
            if (!refCounter.closed) {
              refCounter.connection = connectable.connect();
            }
            return subscription;
          };
          return RefCountOperator;
        })();
        var RefCountSubscriber = (function (_super) {
          __extends(RefCountSubscriber, _super);
          function RefCountSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
          }
          RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
              this.connection = null;
              return;
            }
            this.connectable = null;
            var refCount = connectable._refCount;
            if (refCount <= 0) {
              this.connection = null;
              return;
            }
            connectable._refCount = refCount - 1;
            if (refCount > 1) {
              this.connection = null;
              return;
            }
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (
              sharedConnection &&
              (!connection || sharedConnection === connection)
            ) {
              sharedConnection.unsubscribe();
            }
          };
          return RefCountSubscriber;
        })(Subscriber_1.Subscriber);
      },
      {
        "../Observable": 339,
        "../Subject": 344,
        "../Subscriber": 346,
        "../Subscription": 347,
        "../operators/refCount": 444,
      },
    ],
    350: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var asap_1 = require("../scheduler/asap");
        var isNumeric_1 = require("../util/isNumeric");
        var SubscribeOnObservable = (function (_super) {
          __extends(SubscribeOnObservable, _super);
          function SubscribeOnObservable(source, delayTime, scheduler) {
            if (delayTime === void 0) {
              delayTime = 0;
            }
            if (scheduler === void 0) {
              scheduler = asap_1.asap;
            }
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.delayTime = delayTime;
            _this.scheduler = scheduler;
            if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
              _this.delayTime = 0;
            }
            if (!scheduler || typeof scheduler.schedule !== "function") {
              _this.scheduler = asap_1.asap;
            }
            return _this;
          }
          SubscribeOnObservable.create = function (source, delay, scheduler) {
            if (delay === void 0) {
              delay = 0;
            }
            if (scheduler === void 0) {
              scheduler = asap_1.asap;
            }
            return new SubscribeOnObservable(source, delay, scheduler);
          };
          SubscribeOnObservable.dispatch = function (arg) {
            var source = arg.source,
              subscriber = arg.subscriber;
            return this.add(source.subscribe(subscriber));
          };
          SubscribeOnObservable.prototype._subscribe = function (subscriber) {
            var delay = this.delayTime;
            var source = this.source;
            var scheduler = this.scheduler;
            return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
              source: source,
              subscriber: subscriber,
            });
          };
          return SubscribeOnObservable;
        })(Observable_1.Observable);
        exports.SubscribeOnObservable = SubscribeOnObservable;
      },
      {
        "../Observable": 339,
        "../scheduler/asap": 502,
        "../util/isNumeric": 530,
      },
    ],
    351: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var AsyncSubject_1 = require("../AsyncSubject");
        var map_1 = require("../operators/map");
        var canReportError_1 = require("../util/canReportError");
        var isArray_1 = require("../util/isArray");
        var isScheduler_1 = require("../util/isScheduler");
        function bindCallback(callbackFunc, resultSelector, scheduler) {
          if (resultSelector) {
            if (isScheduler_1.isScheduler(resultSelector)) {
              scheduler = resultSelector;
            } else {
              return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler)
                  .apply(void 0, args)
                  .pipe(
                    map_1.map(function (args) {
                      return isArray_1.isArray(args)
                        ? resultSelector.apply(void 0, args)
                        : resultSelector(args);
                    })
                  );
              };
            }
          }
          return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var context = this;
            var subject;
            var params = {
              context: context,
              subject: subject,
              callbackFunc: callbackFunc,
              scheduler: scheduler,
            };
            return new Observable_1.Observable(function (subscriber) {
              if (!scheduler) {
                if (!subject) {
                  subject = new AsyncSubject_1.AsyncSubject();
                  var handler = function () {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                      innerArgs[_i] = arguments[_i];
                    }
                    subject.next(
                      innerArgs.length <= 1 ? innerArgs[0] : innerArgs
                    );
                    subject.complete();
                  };
                  try {
                    callbackFunc.apply(context, args.concat([handler]));
                  } catch (err) {
                    if (canReportError_1.canReportError(subject)) {
                      subject.error(err);
                    } else {
                      console.warn(err);
                    }
                  }
                }
                return subject.subscribe(subscriber);
              } else {
                var state = {
                  args: args,
                  subscriber: subscriber,
                  params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
              }
            });
          };
        }
        exports.bindCallback = bindCallback;
        function dispatch(state) {
          var _this = this;
          var self = this;
          var args = state.args,
            subscriber = state.subscriber,
            params = state.params;
          var callbackFunc = params.callbackFunc,
            context = params.context,
            scheduler = params.scheduler;
          var subject = params.subject;
          if (!subject) {
            subject = params.subject = new AsyncSubject_1.AsyncSubject();
            var handler = function () {
              var innerArgs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
              }
              var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
              _this.add(
                scheduler.schedule(dispatchNext, 0, {
                  value: value,
                  subject: subject,
                })
              );
            };
            try {
              callbackFunc.apply(context, args.concat([handler]));
            } catch (err) {
              subject.error(err);
            }
          }
          this.add(subject.subscribe(subscriber));
        }
        function dispatchNext(state) {
          var value = state.value,
            subject = state.subject;
          subject.next(value);
          subject.complete();
        }
        function dispatchError(state) {
          var err = state.err,
            subject = state.subject;
          subject.error(err);
        }
      },
      {
        "../AsyncSubject": 335,
        "../Observable": 339,
        "../operators/map": 422,
        "../util/canReportError": 520,
        "../util/isArray": 524,
        "../util/isScheduler": 534,
      },
    ],
    352: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var AsyncSubject_1 = require("../AsyncSubject");
        var map_1 = require("../operators/map");
        var canReportError_1 = require("../util/canReportError");
        var isScheduler_1 = require("../util/isScheduler");
        var isArray_1 = require("../util/isArray");
        function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
          if (resultSelector) {
            if (isScheduler_1.isScheduler(resultSelector)) {
              scheduler = resultSelector;
            } else {
              return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler)
                  .apply(void 0, args)
                  .pipe(
                    map_1.map(function (args) {
                      return isArray_1.isArray(args)
                        ? resultSelector.apply(void 0, args)
                        : resultSelector(args);
                    })
                  );
              };
            }
          }
          return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var params = {
              subject: undefined,
              args: args,
              callbackFunc: callbackFunc,
              scheduler: scheduler,
              context: this,
            };
            return new Observable_1.Observable(function (subscriber) {
              var context = params.context;
              var subject = params.subject;
              if (!scheduler) {
                if (!subject) {
                  subject = params.subject = new AsyncSubject_1.AsyncSubject();
                  var handler = function () {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                      innerArgs[_i] = arguments[_i];
                    }
                    var err = innerArgs.shift();
                    if (err) {
                      subject.error(err);
                      return;
                    }
                    subject.next(
                      innerArgs.length <= 1 ? innerArgs[0] : innerArgs
                    );
                    subject.complete();
                  };
                  try {
                    callbackFunc.apply(context, args.concat([handler]));
                  } catch (err) {
                    if (canReportError_1.canReportError(subject)) {
                      subject.error(err);
                    } else {
                      console.warn(err);
                    }
                  }
                }
                return subject.subscribe(subscriber);
              } else {
                return scheduler.schedule(dispatch, 0, {
                  params: params,
                  subscriber: subscriber,
                  context: context,
                });
              }
            });
          };
        }
        exports.bindNodeCallback = bindNodeCallback;
        function dispatch(state) {
          var _this = this;
          var params = state.params,
            subscriber = state.subscriber,
            context = state.context;
          var callbackFunc = params.callbackFunc,
            args = params.args,
            scheduler = params.scheduler;
          var subject = params.subject;
          if (!subject) {
            subject = params.subject = new AsyncSubject_1.AsyncSubject();
            var handler = function () {
              var innerArgs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
              }
              var err = innerArgs.shift();
              if (err) {
                _this.add(
                  scheduler.schedule(dispatchError, 0, {
                    err: err,
                    subject: subject,
                  })
                );
              } else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(
                  scheduler.schedule(dispatchNext, 0, {
                    value: value,
                    subject: subject,
                  })
                );
              }
            };
            try {
              callbackFunc.apply(context, args.concat([handler]));
            } catch (err) {
              this.add(
                scheduler.schedule(dispatchError, 0, {
                  err: err,
                  subject: subject,
                })
              );
            }
          }
          this.add(subject.subscribe(subscriber));
        }
        function dispatchNext(arg) {
          var value = arg.value,
            subject = arg.subject;
          subject.next(value);
          subject.complete();
        }
        function dispatchError(arg) {
          var err = arg.err,
            subject = arg.subject;
          subject.error(err);
        }
      },
      {
        "../AsyncSubject": 335,
        "../Observable": 339,
        "../operators/map": 422,
        "../util/canReportError": 520,
        "../util/isArray": 524,
        "../util/isScheduler": 534,
      },
    ],
    353: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var isScheduler_1 = require("../util/isScheduler");
        var isArray_1 = require("../util/isArray");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var fromArray_1 = require("./fromArray");
        var NONE = {};
        function combineLatest() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          var resultSelector = null;
          var scheduler = null;
          if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
            scheduler = observables.pop();
          }
          if (typeof observables[observables.length - 1] === "function") {
            resultSelector = observables.pop();
          }
          if (observables.length === 1 && isArray_1.isArray(observables[0])) {
            observables = observables[0];
          }
          return fromArray_1
            .fromArray(observables, scheduler)
            .lift(new CombineLatestOperator(resultSelector));
        }
        exports.combineLatest = combineLatest;
        var CombineLatestOperator = (function () {
          function CombineLatestOperator(resultSelector) {
            this.resultSelector = resultSelector;
          }
          CombineLatestOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new CombineLatestSubscriber(subscriber, this.resultSelector)
            );
          };
          return CombineLatestOperator;
        })();
        exports.CombineLatestOperator = CombineLatestOperator;
        var CombineLatestSubscriber = (function (_super) {
          __extends(CombineLatestSubscriber, _super);
          function CombineLatestSubscriber(destination, resultSelector) {
            var _this = _super.call(this, destination) || this;
            _this.resultSelector = resultSelector;
            _this.active = 0;
            _this.values = [];
            _this.observables = [];
            return _this;
          }
          CombineLatestSubscriber.prototype._next = function (observable) {
            this.values.push(NONE);
            this.observables.push(observable);
          };
          CombineLatestSubscriber.prototype._complete = function () {
            var observables = this.observables;
            var len = observables.length;
            if (len === 0) {
              this.destination.complete();
            } else {
              this.active = len;
              this.toRespond = len;
              for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(
                  subscribeToResult_1.subscribeToResult(
                    this,
                    observable,
                    observable,
                    i
                  )
                );
              }
            }
          };
          CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
            if ((this.active -= 1) === 0) {
              this.destination.complete();
            }
          };
          CombineLatestSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            var values = this.values;
            var oldVal = values[outerIndex];
            var toRespond = !this.toRespond
              ? 0
              : oldVal === NONE
              ? --this.toRespond
              : this.toRespond;
            values[outerIndex] = innerValue;
            if (toRespond === 0) {
              if (this.resultSelector) {
                this._tryResultSelector(values);
              } else {
                this.destination.next(values.slice());
              }
            }
          };
          CombineLatestSubscriber.prototype._tryResultSelector = function (
            values
          ) {
            var result;
            try {
              result = this.resultSelector.apply(this, values);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            this.destination.next(result);
          };
          return CombineLatestSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
        exports.CombineLatestSubscriber = CombineLatestSubscriber;
      },
      {
        "../OuterSubscriber": 341,
        "../util/isArray": 524,
        "../util/isScheduler": 534,
        "../util/subscribeToResult": 544,
        "./fromArray": 363,
      },
    ],
    354: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var of_1 = require("./of");
        var concatAll_1 = require("../operators/concatAll");
        function concat() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
        }
        exports.concat = concat;
      },
      { "../operators/concatAll": 394, "./of": 373 },
    ],
    355: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var from_1 = require("./from");
        var empty_1 = require("./empty");
        function defer(observableFactory) {
          return new Observable_1.Observable(function (subscriber) {
            var input;
            try {
              input = observableFactory();
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }
            var source = input ? from_1.from(input) : empty_1.empty();
            return source.subscribe(subscriber);
          });
        }
        exports.defer = defer;
      },
      { "../Observable": 339, "./empty": 360, "./from": 362 },
    ],
    356: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var root_1 = require("../../util/root");
        var Observable_1 = require("../../Observable");
        var Subscriber_1 = require("../../Subscriber");
        var map_1 = require("../../operators/map");
        function getCORSRequest() {
          if (root_1.root.XMLHttpRequest) {
            return new root_1.root.XMLHttpRequest();
          } else if (!!root_1.root.XDomainRequest) {
            return new root_1.root.XDomainRequest();
          } else {
            throw new Error("CORS is not supported by your browser");
          }
        }
        function getXMLHttpRequest() {
          if (root_1.root.XMLHttpRequest) {
            return new root_1.root.XMLHttpRequest();
          } else {
            var progId = void 0;
            try {
              var progIds = [
                "Msxml2.XMLHTTP",
                "Microsoft.XMLHTTP",
                "Msxml2.XMLHTTP.4.0",
              ];
              for (var i = 0; i < 3; i++) {
                try {
                  progId = progIds[i];
                  if (new root_1.root.ActiveXObject(progId)) {
                    break;
                  }
                } catch (e) {}
              }
              return new root_1.root.ActiveXObject(progId);
            } catch (e) {
              throw new Error(
                "XMLHttpRequest is not supported by your browser"
              );
            }
          }
        }
        function ajaxGet(url, headers) {
          if (headers === void 0) {
            headers = null;
          }
          return new AjaxObservable({
            method: "GET",
            url: url,
            headers: headers,
          });
        }
        exports.ajaxGet = ajaxGet;
        function ajaxPost(url, body, headers) {
          return new AjaxObservable({
            method: "POST",
            url: url,
            body: body,
            headers: headers,
          });
        }
        exports.ajaxPost = ajaxPost;
        function ajaxDelete(url, headers) {
          return new AjaxObservable({
            method: "DELETE",
            url: url,
            headers: headers,
          });
        }
        exports.ajaxDelete = ajaxDelete;
        function ajaxPut(url, body, headers) {
          return new AjaxObservable({
            method: "PUT",
            url: url,
            body: body,
            headers: headers,
          });
        }
        exports.ajaxPut = ajaxPut;
        function ajaxPatch(url, body, headers) {
          return new AjaxObservable({
            method: "PATCH",
            url: url,
            body: body,
            headers: headers,
          });
        }
        exports.ajaxPatch = ajaxPatch;
        var mapResponse = map_1.map(function (x, index) {
          return x.response;
        });
        function ajaxGetJSON(url, headers) {
          return mapResponse(
            new AjaxObservable({
              method: "GET",
              url: url,
              responseType: "json",
              headers: headers,
            })
          );
        }
        exports.ajaxGetJSON = ajaxGetJSON;
        var AjaxObservable = (function (_super) {
          __extends(AjaxObservable, _super);
          function AjaxObservable(urlOrRequest) {
            var _this = _super.call(this) || this;
            var request = {
              async: true,
              createXHR: function () {
                return this.crossDomain
                  ? getCORSRequest()
                  : getXMLHttpRequest();
              },
              crossDomain: true,
              withCredentials: false,
              headers: {},
              method: "GET",
              responseType: "json",
              timeout: 0,
            };
            if (typeof urlOrRequest === "string") {
              request.url = urlOrRequest;
            } else {
              for (var prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                  request[prop] = urlOrRequest[prop];
                }
              }
            }
            _this.request = request;
            return _this;
          }
          AjaxObservable.prototype._subscribe = function (subscriber) {
            return new AjaxSubscriber(subscriber, this.request);
          };
          AjaxObservable.create = (function () {
            var create = function (urlOrRequest) {
              return new AjaxObservable(urlOrRequest);
            };
            create.get = ajaxGet;
            create.post = ajaxPost;
            create.delete = ajaxDelete;
            create.put = ajaxPut;
            create.patch = ajaxPatch;
            create.getJSON = ajaxGetJSON;
            return create;
          })();
          return AjaxObservable;
        })(Observable_1.Observable);
        exports.AjaxObservable = AjaxObservable;
        var AjaxSubscriber = (function (_super) {
          __extends(AjaxSubscriber, _super);
          function AjaxSubscriber(destination, request) {
            var _this = _super.call(this, destination) || this;
            _this.request = request;
            _this.done = false;
            var headers = (request.headers = request.headers || {});
            if (
              !request.crossDomain &&
              !_this.getHeader(headers, "X-Requested-With")
            ) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }
            var contentTypeHeader = _this.getHeader(headers, "Content-Type");
            if (
              !contentTypeHeader &&
              !(
                root_1.root.FormData &&
                request.body instanceof root_1.root.FormData
              ) &&
              typeof request.body !== "undefined"
            ) {
              headers["Content-Type"] =
                "application/x-www-form-urlencoded; charset=UTF-8";
            }
            request.body = _this.serializeBody(
              request.body,
              _this.getHeader(request.headers, "Content-Type")
            );
            _this.send();
            return _this;
          }
          AjaxSubscriber.prototype.next = function (e) {
            this.done = true;
            var _a = this,
              xhr = _a.xhr,
              request = _a.request,
              destination = _a.destination;
            var result;
            try {
              result = new AjaxResponse(e, xhr, request);
            } catch (err) {
              return destination.error(err);
            }
            destination.next(result);
          };
          AjaxSubscriber.prototype.send = function () {
            var _a = this,
              request = _a.request,
              _b = _a.request,
              user = _b.user,
              method = _b.method,
              url = _b.url,
              async = _b.async,
              password = _b.password,
              headers = _b.headers,
              body = _b.body;
            try {
              var xhr = (this.xhr = request.createXHR());
              this.setupEvents(xhr, request);
              if (user) {
                xhr.open(method, url, async, user, password);
              } else {
                xhr.open(method, url, async);
              }
              if (async) {
                xhr.timeout = request.timeout;
                xhr.responseType = request.responseType;
              }
              if ("withCredentials" in xhr) {
                xhr.withCredentials = !!request.withCredentials;
              }
              this.setHeaders(xhr, headers);
              if (body) {
                xhr.send(body);
              } else {
                xhr.send();
              }
            } catch (err) {
              this.error(err);
            }
          };
          AjaxSubscriber.prototype.serializeBody = function (
            body,
            contentType
          ) {
            if (!body || typeof body === "string") {
              return body;
            } else if (
              root_1.root.FormData &&
              body instanceof root_1.root.FormData
            ) {
              return body;
            }
            if (contentType) {
              var splitIndex = contentType.indexOf(";");
              if (splitIndex !== -1) {
                contentType = contentType.substring(0, splitIndex);
              }
            }
            switch (contentType) {
              case "application/x-www-form-urlencoded":
                return Object.keys(body)
                  .map(function (key) {
                    return (
                      encodeURIComponent(key) +
                      "=" +
                      encodeURIComponent(body[key])
                    );
                  })
                  .join("&");
              case "application/json":
                return JSON.stringify(body);
              default:
                return body;
            }
          };
          AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
            for (var key in headers) {
              if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
              }
            }
          };
          AjaxSubscriber.prototype.getHeader = function (headers, headerName) {
            for (var key in headers) {
              if (key.toLowerCase() === headerName.toLowerCase()) {
                return headers[key];
              }
            }
            return undefined;
          };
          AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
            var progressSubscriber = request.progressSubscriber;
            function xhrTimeout(e) {
              var _a = xhrTimeout,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
              if (progressSubscriber) {
                progressSubscriber.error(e);
              }
              var error;
              try {
                error = new exports.AjaxTimeoutError(this, request);
              } catch (err) {
                error = err;
              }
              subscriber.error(error);
            }
            xhr.ontimeout = xhrTimeout;
            xhrTimeout.request = request;
            xhrTimeout.subscriber = this;
            xhrTimeout.progressSubscriber = progressSubscriber;
            if (xhr.upload && "withCredentials" in xhr) {
              if (progressSubscriber) {
                var xhrProgress_1;
                xhrProgress_1 = function (e) {
                  var progressSubscriber = xhrProgress_1.progressSubscriber;
                  progressSubscriber.next(e);
                };
                if (root_1.root.XDomainRequest) {
                  xhr.onprogress = xhrProgress_1;
                } else {
                  xhr.upload.onprogress = xhrProgress_1;
                }
                xhrProgress_1.progressSubscriber = progressSubscriber;
              }
              var xhrError_1;
              xhrError_1 = function (e) {
                var _a = xhrError_1,
                  progressSubscriber = _a.progressSubscriber,
                  subscriber = _a.subscriber,
                  request = _a.request;
                if (progressSubscriber) {
                  progressSubscriber.error(e);
                }
                var error;
                try {
                  error = new exports.AjaxError("ajax error", this, request);
                } catch (err) {
                  error = err;
                }
                subscriber.error(error);
              };
              xhr.onerror = xhrError_1;
              xhrError_1.request = request;
              xhrError_1.subscriber = this;
              xhrError_1.progressSubscriber = progressSubscriber;
            }
            function xhrReadyStateChange(e) {
              return;
            }
            xhr.onreadystatechange = xhrReadyStateChange;
            xhrReadyStateChange.subscriber = this;
            xhrReadyStateChange.progressSubscriber = progressSubscriber;
            xhrReadyStateChange.request = request;
            function xhrLoad(e) {
              var _a = xhrLoad,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
              if (this.readyState === 4) {
                var status_1 = this.status === 1223 ? 204 : this.status;
                var response =
                  this.responseType === "text"
                    ? this.response || this.responseText
                    : this.response;
                if (status_1 === 0) {
                  status_1 = response ? 200 : 0;
                }
                if (status_1 < 400) {
                  if (progressSubscriber) {
                    progressSubscriber.complete();
                  }
                  subscriber.next(e);
                  subscriber.complete();
                } else {
                  if (progressSubscriber) {
                    progressSubscriber.error(e);
                  }
                  var error = void 0;
                  try {
                    error = new exports.AjaxError(
                      "ajax error " + status_1,
                      this,
                      request
                    );
                  } catch (err) {
                    error = err;
                  }
                  subscriber.error(error);
                }
              }
            }
            xhr.onload = xhrLoad;
            xhrLoad.subscriber = this;
            xhrLoad.progressSubscriber = progressSubscriber;
            xhrLoad.request = request;
          };
          AjaxSubscriber.prototype.unsubscribe = function () {
            var _a = this,
              done = _a.done,
              xhr = _a.xhr;
            if (
              !done &&
              xhr &&
              xhr.readyState !== 4 &&
              typeof xhr.abort === "function"
            ) {
              xhr.abort();
            }
            _super.prototype.unsubscribe.call(this);
          };
          return AjaxSubscriber;
        })(Subscriber_1.Subscriber);
        exports.AjaxSubscriber = AjaxSubscriber;
        var AjaxResponse = (function () {
          function AjaxResponse(originalEvent, xhr, request) {
            this.originalEvent = originalEvent;
            this.xhr = xhr;
            this.request = request;
            this.status = xhr.status;
            this.responseType = xhr.responseType || request.responseType;
            this.response = parseXhrResponse(this.responseType, xhr);
          }
          return AjaxResponse;
        })();
        exports.AjaxResponse = AjaxResponse;
        var AjaxErrorImpl = (function () {
          function AjaxErrorImpl(message, xhr, request) {
            Error.call(this);
            this.message = message;
            this.name = "AjaxError";
            this.xhr = xhr;
            this.request = request;
            this.status = xhr.status;
            this.responseType = xhr.responseType || request.responseType;
            this.response = parseXhrResponse(this.responseType, xhr);
            return this;
          }
          AjaxErrorImpl.prototype = Object.create(Error.prototype);
          return AjaxErrorImpl;
        })();
        exports.AjaxError = AjaxErrorImpl;
        function parseJson(xhr) {
          if ("response" in xhr) {
            return xhr.responseType
              ? xhr.response
              : JSON.parse(xhr.response || xhr.responseText || "null");
          } else {
            return JSON.parse(xhr.responseText || "null");
          }
        }
        function parseXhrResponse(responseType, xhr) {
          switch (responseType) {
            case "json":
              return parseJson(xhr);
            case "xml":
              return xhr.responseXML;
            case "text":
            default:
              return "response" in xhr ? xhr.response : xhr.responseText;
          }
        }
        function AjaxTimeoutErrorImpl(xhr, request) {
          exports.AjaxError.call(this, "ajax timeout", xhr, request);
          this.name = "AjaxTimeoutError";
          return this;
        }
        exports.AjaxTimeoutError = AjaxTimeoutErrorImpl;
      },
      {
        "../../Observable": 339,
        "../../Subscriber": 346,
        "../../operators/map": 422,
        "../../util/root": 538,
      },
    ],
    357: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        var __assign =
          (this && this.__assign) ||
          function () {
            __assign =
              Object.assign ||
              function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
              };
            return __assign.apply(this, arguments);
          };
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../../Subject");
        var Subscriber_1 = require("../../Subscriber");
        var Observable_1 = require("../../Observable");
        var Subscription_1 = require("../../Subscription");
        var ReplaySubject_1 = require("../../ReplaySubject");
        var DEFAULT_WEBSOCKET_CONFIG = {
          url: "",
          deserializer: function (e) {
            return JSON.parse(e.data);
          },
          serializer: function (value) {
            return JSON.stringify(value);
          },
        };
        var WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT =
          "WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }";
        var WebSocketSubject = (function (_super) {
          __extends(WebSocketSubject, _super);
          function WebSocketSubject(urlConfigOrSource, destination) {
            var _this = _super.call(this) || this;
            if (urlConfigOrSource instanceof Observable_1.Observable) {
              _this.destination = destination;
              _this.source = urlConfigOrSource;
            } else {
              var config = (_this._config = __assign(
                {},
                DEFAULT_WEBSOCKET_CONFIG
              ));
              _this._output = new Subject_1.Subject();
              if (typeof urlConfigOrSource === "string") {
                config.url = urlConfigOrSource;
              } else {
                for (var key in urlConfigOrSource) {
                  if (urlConfigOrSource.hasOwnProperty(key)) {
                    config[key] = urlConfigOrSource[key];
                  }
                }
              }
              if (!config.WebSocketCtor && WebSocket) {
                config.WebSocketCtor = WebSocket;
              } else if (!config.WebSocketCtor) {
                throw new Error("no WebSocket constructor can be found");
              }
              _this.destination = new ReplaySubject_1.ReplaySubject();
            }
            return _this;
          }
          WebSocketSubject.prototype.lift = function (operator) {
            var sock = new WebSocketSubject(this._config, this.destination);
            sock.operator = operator;
            sock.source = this;
            return sock;
          };
          WebSocketSubject.prototype._resetState = function () {
            this._socket = null;
            if (!this.source) {
              this.destination = new ReplaySubject_1.ReplaySubject();
            }
            this._output = new Subject_1.Subject();
          };
          WebSocketSubject.prototype.multiplex = function (
            subMsg,
            unsubMsg,
            messageFilter
          ) {
            var self = this;
            return new Observable_1.Observable(function (observer) {
              try {
                self.next(subMsg());
              } catch (err) {
                observer.error(err);
              }
              var subscription = self.subscribe(
                function (x) {
                  try {
                    if (messageFilter(x)) {
                      observer.next(x);
                    }
                  } catch (err) {
                    observer.error(err);
                  }
                },
                function (err) {
                  return observer.error(err);
                },
                function () {
                  return observer.complete();
                }
              );
              return function () {
                try {
                  self.next(unsubMsg());
                } catch (err) {
                  observer.error(err);
                }
                subscription.unsubscribe();
              };
            });
          };
          WebSocketSubject.prototype._connectSocket = function () {
            var _this = this;
            var _a = this._config,
              WebSocketCtor = _a.WebSocketCtor,
              protocol = _a.protocol,
              url = _a.url,
              binaryType = _a.binaryType;
            var observer = this._output;
            var socket = null;
            try {
              socket = protocol
                ? new WebSocketCtor(url, protocol)
                : new WebSocketCtor(url);
              this._socket = socket;
              if (binaryType) {
                this._socket.binaryType = binaryType;
              }
            } catch (e) {
              observer.error(e);
              return;
            }
            var subscription = new Subscription_1.Subscription(function () {
              _this._socket = null;
              if (socket && socket.readyState === 1) {
                socket.close();
              }
            });
            socket.onopen = function (e) {
              var _socket = _this._socket;
              if (!_socket) {
                socket.close();
                _this._resetState();
                return;
              }
              var openObserver = _this._config.openObserver;
              if (openObserver) {
                openObserver.next(e);
              }
              var queue = _this.destination;
              _this.destination = Subscriber_1.Subscriber.create(
                function (x) {
                  if (socket.readyState === 1) {
                    try {
                      var serializer = _this._config.serializer;
                      socket.send(serializer(x));
                    } catch (e) {
                      _this.destination.error(e);
                    }
                  }
                },
                function (e) {
                  var closingObserver = _this._config.closingObserver;
                  if (closingObserver) {
                    closingObserver.next(undefined);
                  }
                  if (e && e.code) {
                    socket.close(e.code, e.reason);
                  } else {
                    observer.error(
                      new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT)
                    );
                  }
                  _this._resetState();
                },
                function () {
                  var closingObserver = _this._config.closingObserver;
                  if (closingObserver) {
                    closingObserver.next(undefined);
                  }
                  socket.close();
                  _this._resetState();
                }
              );
              if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {
                subscription.add(queue.subscribe(_this.destination));
              }
            };
            socket.onerror = function (e) {
              _this._resetState();
              observer.error(e);
            };
            socket.onclose = function (e) {
              _this._resetState();
              var closeObserver = _this._config.closeObserver;
              if (closeObserver) {
                closeObserver.next(e);
              }
              if (e.wasClean) {
                observer.complete();
              } else {
                observer.error(e);
              }
            };
            socket.onmessage = function (e) {
              try {
                var deserializer = _this._config.deserializer;
                observer.next(deserializer(e));
              } catch (err) {
                observer.error(err);
              }
            };
          };
          WebSocketSubject.prototype._subscribe = function (subscriber) {
            var _this = this;
            var source = this.source;
            if (source) {
              return source.subscribe(subscriber);
            }
            if (!this._socket) {
              this._connectSocket();
            }
            this._output.subscribe(subscriber);
            subscriber.add(function () {
              var _socket = _this._socket;
              if (_this._output.observers.length === 0) {
                if (_socket && _socket.readyState === 1) {
                  _socket.close();
                }
                _this._resetState();
              }
            });
            return subscriber;
          };
          WebSocketSubject.prototype.unsubscribe = function () {
            var _socket = this._socket;
            if (_socket && _socket.readyState === 1) {
              _socket.close();
            }
            this._resetState();
            _super.prototype.unsubscribe.call(this);
          };
          return WebSocketSubject;
        })(Subject_1.AnonymousSubject);
        exports.WebSocketSubject = WebSocketSubject;
      },
      {
        "../../Observable": 339,
        "../../ReplaySubject": 342,
        "../../Subject": 344,
        "../../Subscriber": 346,
        "../../Subscription": 347,
      },
    ],
    358: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var AjaxObservable_1 = require("./AjaxObservable");
        exports.ajax = (function () {
          return AjaxObservable_1.AjaxObservable.create;
        })();
      },
      { "./AjaxObservable": 356 },
    ],
    359: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var WebSocketSubject_1 = require("./WebSocketSubject");
        function webSocket(urlConfigOrSource) {
          return new WebSocketSubject_1.WebSocketSubject(urlConfigOrSource);
        }
        exports.webSocket = webSocket;
      },
      { "./WebSocketSubject": 357 },
    ],
    360: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        exports.EMPTY = new Observable_1.Observable(function (subscriber) {
          return subscriber.complete();
        });
        function empty(scheduler) {
          return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
        }
        exports.empty = empty;
        function emptyScheduled(scheduler) {
          return new Observable_1.Observable(function (subscriber) {
            return scheduler.schedule(function () {
              return subscriber.complete();
            });
          });
        }
      },
      { "../Observable": 339 },
    ],
    361: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isArray_1 = require("../util/isArray");
        var map_1 = require("../operators/map");
        var isObject_1 = require("../util/isObject");
        var from_1 = require("./from");
        function forkJoin() {
          var sources = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
          }
          if (sources.length === 1) {
            var first_1 = sources[0];
            if (isArray_1.isArray(first_1)) {
              return forkJoinInternal(first_1, null);
            }
            if (
              isObject_1.isObject(first_1) &&
              Object.getPrototypeOf(first_1) === Object.prototype
            ) {
              var keys = Object.keys(first_1);
              return forkJoinInternal(
                keys.map(function (key) {
                  return first_1[key];
                }),
                keys
              );
            }
          }
          if (typeof sources[sources.length - 1] === "function") {
            var resultSelector_1 = sources.pop();
            sources =
              sources.length === 1 && isArray_1.isArray(sources[0])
                ? sources[0]
                : sources;
            return forkJoinInternal(sources, null).pipe(
              map_1.map(function (args) {
                return resultSelector_1.apply(void 0, args);
              })
            );
          }
          return forkJoinInternal(sources, null);
        }
        exports.forkJoin = forkJoin;
        function forkJoinInternal(sources, keys) {
          return new Observable_1.Observable(function (subscriber) {
            var len = sources.length;
            if (len === 0) {
              subscriber.complete();
              return;
            }
            var values = new Array(len);
            var completed = 0;
            var emitted = 0;
            var _loop_1 = function (i) {
              var source = from_1.from(sources[i]);
              var hasValue = false;
              subscriber.add(
                source.subscribe({
                  next: function (value) {
                    if (!hasValue) {
                      hasValue = true;
                      emitted++;
                    }
                    values[i] = value;
                  },
                  error: function (err) {
                    return subscriber.error(err);
                  },
                  complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                      if (emitted === len) {
                        subscriber.next(
                          keys
                            ? keys.reduce(function (result, key, i) {
                                return (result[key] = values[i]), result;
                              }, {})
                            : values
                        );
                      }
                      subscriber.complete();
                    }
                  },
                })
              );
            };
            for (var i = 0; i < len; i++) {
              _loop_1(i);
            }
          });
        }
      },
      {
        "../Observable": 339,
        "../operators/map": 422,
        "../util/isArray": 524,
        "../util/isObject": 531,
        "./from": 362,
      },
    ],
    362: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var subscribeTo_1 = require("../util/subscribeTo");
        var scheduled_1 = require("../scheduled/scheduled");
        function from(input, scheduler) {
          if (!scheduler) {
            if (input instanceof Observable_1.Observable) {
              return input;
            }
            return new Observable_1.Observable(
              subscribeTo_1.subscribeTo(input)
            );
          } else {
            return scheduled_1.scheduled(input, scheduler);
          }
        }
        exports.from = from;
      },
      {
        "../Observable": 339,
        "../scheduled/scheduled": 490,
        "../util/subscribeTo": 539,
      },
    ],
    363: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var subscribeToArray_1 = require("../util/subscribeToArray");
        var scheduleArray_1 = require("../scheduled/scheduleArray");
        function fromArray(input, scheduler) {
          if (!scheduler) {
            return new Observable_1.Observable(
              subscribeToArray_1.subscribeToArray(input)
            );
          } else {
            return scheduleArray_1.scheduleArray(input, scheduler);
          }
        }
        exports.fromArray = fromArray;
      },
      {
        "../Observable": 339,
        "../scheduled/scheduleArray": 486,
        "../util/subscribeToArray": 540,
      },
    ],
    364: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isArray_1 = require("../util/isArray");
        var isFunction_1 = require("../util/isFunction");
        var map_1 = require("../operators/map");
        var toString = (function () {
          return Object.prototype.toString;
        })();
        function fromEvent(target, eventName, options, resultSelector) {
          if (isFunction_1.isFunction(options)) {
            resultSelector = options;
            options = undefined;
          }
          if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(
              map_1.map(function (args) {
                return isArray_1.isArray(args)
                  ? resultSelector.apply(void 0, args)
                  : resultSelector(args);
              })
            );
          }
          return new Observable_1.Observable(function (subscriber) {
            function handler(e) {
              if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
              } else {
                subscriber.next(e);
              }
            }
            setupSubscription(target, eventName, handler, subscriber, options);
          });
        }
        exports.fromEvent = fromEvent;
        function setupSubscription(
          sourceObj,
          eventName,
          handler,
          subscriber,
          options
        ) {
          var unsubscribe;
          if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () {
              return source_1.removeEventListener(eventName, handler, options);
            };
          } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () {
              return source_2.off(eventName, handler);
            };
          } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () {
              return source_3.removeListener(eventName, handler);
            };
          } else if (sourceObj && sourceObj.length) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
              setupSubscription(
                sourceObj[i],
                eventName,
                handler,
                subscriber,
                options
              );
            }
          } else {
            throw new TypeError("Invalid event target");
          }
          subscriber.add(unsubscribe);
        }
        function isNodeStyleEventEmitter(sourceObj) {
          return (
            sourceObj &&
            typeof sourceObj.addListener === "function" &&
            typeof sourceObj.removeListener === "function"
          );
        }
        function isJQueryStyleEventEmitter(sourceObj) {
          return (
            sourceObj &&
            typeof sourceObj.on === "function" &&
            typeof sourceObj.off === "function"
          );
        }
        function isEventTarget(sourceObj) {
          return (
            sourceObj &&
            typeof sourceObj.addEventListener === "function" &&
            typeof sourceObj.removeEventListener === "function"
          );
        }
      },
      {
        "../Observable": 339,
        "../operators/map": 422,
        "../util/isArray": 524,
        "../util/isFunction": 527,
      },
    ],
    365: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isArray_1 = require("../util/isArray");
        var isFunction_1 = require("../util/isFunction");
        var map_1 = require("../operators/map");
        function fromEventPattern(addHandler, removeHandler, resultSelector) {
          if (resultSelector) {
            return fromEventPattern(addHandler, removeHandler).pipe(
              map_1.map(function (args) {
                return isArray_1.isArray(args)
                  ? resultSelector.apply(void 0, args)
                  : resultSelector(args);
              })
            );
          }
          return new Observable_1.Observable(function (subscriber) {
            var handler = function () {
              var e = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
              }
              return subscriber.next(e.length === 1 ? e[0] : e);
            };
            var retValue;
            try {
              retValue = addHandler(handler);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }
            if (!isFunction_1.isFunction(removeHandler)) {
              return undefined;
            }
            return function () {
              return removeHandler(handler, retValue);
            };
          });
        }
        exports.fromEventPattern = fromEventPattern;
      },
      {
        "../Observable": 339,
        "../operators/map": 422,
        "../util/isArray": 524,
        "../util/isFunction": 527,
      },
    ],
    366: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var subscribeToIterable_1 = require("../util/subscribeToIterable");
        var scheduleIterable_1 = require("../scheduled/scheduleIterable");
        function fromIterable(input, scheduler) {
          if (!input) {
            throw new Error("Iterable cannot be null");
          }
          if (!scheduler) {
            return new Observable_1.Observable(
              subscribeToIterable_1.subscribeToIterable(input)
            );
          } else {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
          }
        }
        exports.fromIterable = fromIterable;
      },
      {
        "../Observable": 339,
        "../scheduled/scheduleIterable": 487,
        "../util/subscribeToIterable": 541,
      },
    ],
    367: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var subscribeToPromise_1 = require("../util/subscribeToPromise");
        var schedulePromise_1 = require("../scheduled/schedulePromise");
        function fromPromise(input, scheduler) {
          if (!scheduler) {
            return new Observable_1.Observable(
              subscribeToPromise_1.subscribeToPromise(input)
            );
          } else {
            return schedulePromise_1.schedulePromise(input, scheduler);
          }
        }
        exports.fromPromise = fromPromise;
      },
      {
        "../Observable": 339,
        "../scheduled/schedulePromise": 489,
        "../util/subscribeToPromise": 543,
      },
    ],
    368: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var identity_1 = require("../util/identity");
        var isScheduler_1 = require("../util/isScheduler");
        function generate(
          initialStateOrOptions,
          condition,
          iterate,
          resultSelectorOrObservable,
          scheduler
        ) {
          var resultSelector;
          var initialState;
          if (arguments.length == 1) {
            var options = initialStateOrOptions;
            initialState = options.initialState;
            condition = options.condition;
            iterate = options.iterate;
            resultSelector = options.resultSelector || identity_1.identity;
            scheduler = options.scheduler;
          } else if (
            resultSelectorOrObservable === undefined ||
            isScheduler_1.isScheduler(resultSelectorOrObservable)
          ) {
            initialState = initialStateOrOptions;
            resultSelector = identity_1.identity;
            scheduler = resultSelectorOrObservable;
          } else {
            initialState = initialStateOrOptions;
            resultSelector = resultSelectorOrObservable;
          }
          return new Observable_1.Observable(function (subscriber) {
            var state = initialState;
            if (scheduler) {
              return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state,
              });
            }
            do {
              if (condition) {
                var conditionResult = void 0;
                try {
                  conditionResult = condition(state);
                } catch (err) {
                  subscriber.error(err);
                  return undefined;
                }
                if (!conditionResult) {
                  subscriber.complete();
                  break;
                }
              }
              var value = void 0;
              try {
                value = resultSelector(state);
              } catch (err) {
                subscriber.error(err);
                return undefined;
              }
              subscriber.next(value);
              if (subscriber.closed) {
                break;
              }
              try {
                state = iterate(state);
              } catch (err) {
                subscriber.error(err);
                return undefined;
              }
            } while (true);
            return undefined;
          });
        }
        exports.generate = generate;
        function dispatch(state) {
          var subscriber = state.subscriber,
            condition = state.condition;
          if (subscriber.closed) {
            return undefined;
          }
          if (state.needIterate) {
            try {
              state.state = state.iterate(state.state);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }
          } else {
            state.needIterate = true;
          }
          if (condition) {
            var conditionResult = void 0;
            try {
              conditionResult = condition(state.state);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }
            if (!conditionResult) {
              subscriber.complete();
              return undefined;
            }
            if (subscriber.closed) {
              return undefined;
            }
          }
          var value;
          try {
            value = state.resultSelector(state.state);
          } catch (err) {
            subscriber.error(err);
            return undefined;
          }
          if (subscriber.closed) {
            return undefined;
          }
          subscriber.next(value);
          if (subscriber.closed) {
            return undefined;
          }
          return this.schedule(state);
        }
      },
      {
        "../Observable": 339,
        "../util/identity": 523,
        "../util/isScheduler": 534,
      },
    ],
    369: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var defer_1 = require("./defer");
        var empty_1 = require("./empty");
        function iif(condition, trueResult, falseResult) {
          if (trueResult === void 0) {
            trueResult = empty_1.EMPTY;
          }
          if (falseResult === void 0) {
            falseResult = empty_1.EMPTY;
          }
          return defer_1.defer(function () {
            return condition() ? trueResult : falseResult;
          });
        }
        exports.iif = iif;
      },
      { "./defer": 355, "./empty": 360 },
    ],
    370: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var async_1 = require("../scheduler/async");
        var isNumeric_1 = require("../util/isNumeric");
        function interval(period, scheduler) {
          if (period === void 0) {
            period = 0;
          }
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          if (!isNumeric_1.isNumeric(period) || period < 0) {
            period = 0;
          }
          if (!scheduler || typeof scheduler.schedule !== "function") {
            scheduler = async_1.async;
          }
          return new Observable_1.Observable(function (subscriber) {
            subscriber.add(
              scheduler.schedule(dispatch, period, {
                subscriber: subscriber,
                counter: 0,
                period: period,
              })
            );
            return subscriber;
          });
        }
        exports.interval = interval;
        function dispatch(state) {
          var subscriber = state.subscriber,
            counter = state.counter,
            period = state.period;
          subscriber.next(counter);
          this.schedule(
            { subscriber: subscriber, counter: counter + 1, period: period },
            period
          );
        }
      },
      {
        "../Observable": 339,
        "../scheduler/async": 503,
        "../util/isNumeric": 530,
      },
    ],
    371: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var isScheduler_1 = require("../util/isScheduler");
        var mergeAll_1 = require("../operators/mergeAll");
        var fromArray_1 = require("./fromArray");
        function merge() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          var concurrent = Number.POSITIVE_INFINITY;
          var scheduler = null;
          var last = observables[observables.length - 1];
          if (isScheduler_1.isScheduler(last)) {
            scheduler = observables.pop();
            if (
              observables.length > 1 &&
              typeof observables[observables.length - 1] === "number"
            ) {
              concurrent = observables.pop();
            }
          } else if (typeof last === "number") {
            concurrent = observables.pop();
          }
          if (
            scheduler === null &&
            observables.length === 1 &&
            observables[0] instanceof Observable_1.Observable
          ) {
            return observables[0];
          }
          return mergeAll_1.mergeAll(concurrent)(
            fromArray_1.fromArray(observables, scheduler)
          );
        }
        exports.merge = merge;
      },
      {
        "../Observable": 339,
        "../operators/mergeAll": 427,
        "../util/isScheduler": 534,
        "./fromArray": 363,
      },
    ],
    372: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var noop_1 = require("../util/noop");
        exports.NEVER = new Observable_1.Observable(noop_1.noop);
        function never() {
          return exports.NEVER;
        }
        exports.never = never;
      },
      { "../Observable": 339, "../util/noop": 535 },
    ],
    373: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isScheduler_1 = require("../util/isScheduler");
        var fromArray_1 = require("./fromArray");
        var scheduleArray_1 = require("../scheduled/scheduleArray");
        function of() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var scheduler = args[args.length - 1];
          if (isScheduler_1.isScheduler(scheduler)) {
            args.pop();
            return scheduleArray_1.scheduleArray(args, scheduler);
          } else {
            return fromArray_1.fromArray(args);
          }
        }
        exports.of = of;
      },
      {
        "../scheduled/scheduleArray": 486,
        "../util/isScheduler": 534,
        "./fromArray": 363,
      },
    ],
    374: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var from_1 = require("./from");
        var isArray_1 = require("../util/isArray");
        var empty_1 = require("./empty");
        function onErrorResumeNext() {
          var sources = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
          }
          if (sources.length === 0) {
            return empty_1.EMPTY;
          }
          var first = sources[0],
            remainder = sources.slice(1);
          if (sources.length === 1 && isArray_1.isArray(first)) {
            return onErrorResumeNext.apply(void 0, first);
          }
          return new Observable_1.Observable(function (subscriber) {
            var subNext = function () {
              return subscriber.add(
                onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)
              );
            };
            return from_1.from(first).subscribe({
              next: function (value) {
                subscriber.next(value);
              },
              error: subNext,
              complete: subNext,
            });
          });
        }
        exports.onErrorResumeNext = onErrorResumeNext;
      },
      {
        "../Observable": 339,
        "../util/isArray": 524,
        "./empty": 360,
        "./from": 362,
      },
    ],
    375: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        function pairs(obj, scheduler) {
          if (!scheduler) {
            return new Observable_1.Observable(function (subscriber) {
              var keys = Object.keys(obj);
              for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                  subscriber.next([key, obj[key]]);
                }
              }
              subscriber.complete();
            });
          } else {
            return new Observable_1.Observable(function (subscriber) {
              var keys = Object.keys(obj);
              var subscription = new Subscription_1.Subscription();
              subscription.add(
                scheduler.schedule(dispatch, 0, {
                  keys: keys,
                  index: 0,
                  subscriber: subscriber,
                  subscription: subscription,
                  obj: obj,
                })
              );
              return subscription;
            });
          }
        }
        exports.pairs = pairs;
        function dispatch(state) {
          var keys = state.keys,
            index = state.index,
            subscriber = state.subscriber,
            subscription = state.subscription,
            obj = state.obj;
          if (!subscriber.closed) {
            if (index < keys.length) {
              var key = keys[index];
              subscriber.next([key, obj[key]]);
              subscription.add(
                this.schedule({
                  keys: keys,
                  index: index + 1,
                  subscriber: subscriber,
                  subscription: subscription,
                  obj: obj,
                })
              );
            } else {
              subscriber.complete();
            }
          }
        }
        exports.dispatch = dispatch;
      },
      { "../Observable": 339, "../Subscription": 347 },
    ],
    376: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var not_1 = require("../util/not");
        var subscribeTo_1 = require("../util/subscribeTo");
        var filter_1 = require("../operators/filter");
        var Observable_1 = require("../Observable");
        function partition(source, predicate, thisArg) {
          return [
            filter_1.filter(
              predicate,
              thisArg
            )(new Observable_1.Observable(subscribeTo_1.subscribeTo(source))),
            filter_1.filter(not_1.not(predicate, thisArg))(
              new Observable_1.Observable(subscribeTo_1.subscribeTo(source))
            ),
          ];
        }
        exports.partition = partition;
      },
      {
        "../Observable": 339,
        "../operators/filter": 413,
        "../util/not": 536,
        "../util/subscribeTo": 539,
      },
    ],
    377: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var isArray_1 = require("../util/isArray");
        var fromArray_1 = require("./fromArray");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function race() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          if (observables.length === 1) {
            if (isArray_1.isArray(observables[0])) {
              observables = observables[0];
            } else {
              return observables[0];
            }
          }
          return fromArray_1
            .fromArray(observables, undefined)
            .lift(new RaceOperator());
        }
        exports.race = race;
        var RaceOperator = (function () {
          function RaceOperator() {}
          RaceOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new RaceSubscriber(subscriber));
          };
          return RaceOperator;
        })();
        exports.RaceOperator = RaceOperator;
        var RaceSubscriber = (function (_super) {
          __extends(RaceSubscriber, _super);
          function RaceSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.hasFirst = false;
            _this.observables = [];
            _this.subscriptions = [];
            return _this;
          }
          RaceSubscriber.prototype._next = function (observable) {
            this.observables.push(observable);
          };
          RaceSubscriber.prototype._complete = function () {
            var observables = this.observables;
            var len = observables.length;
            if (len === 0) {
              this.destination.complete();
            } else {
              for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(
                  this,
                  observable,
                  observable,
                  i
                );
                if (this.subscriptions) {
                  this.subscriptions.push(subscription);
                }
                this.add(subscription);
              }
              this.observables = null;
            }
          };
          RaceSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            if (!this.hasFirst) {
              this.hasFirst = true;
              for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                  var subscription = this.subscriptions[i];
                  subscription.unsubscribe();
                  this.remove(subscription);
                }
              }
              this.subscriptions = null;
            }
            this.destination.next(innerValue);
          };
          return RaceSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
        exports.RaceSubscriber = RaceSubscriber;
      },
      {
        "../OuterSubscriber": 341,
        "../util/isArray": 524,
        "../util/subscribeToResult": 544,
        "./fromArray": 363,
      },
    ],
    378: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        function range(start, count, scheduler) {
          if (start === void 0) {
            start = 0;
          }
          return new Observable_1.Observable(function (subscriber) {
            if (count === undefined) {
              count = start;
              start = 0;
            }
            var index = 0;
            var current = start;
            if (scheduler) {
              return scheduler.schedule(dispatch, 0, {
                index: index,
                count: count,
                start: start,
                subscriber: subscriber,
              });
            } else {
              do {
                if (index++ >= count) {
                  subscriber.complete();
                  break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                  break;
                }
              } while (true);
            }
            return undefined;
          });
        }
        exports.range = range;
        function dispatch(state) {
          var start = state.start,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
          if (index >= count) {
            subscriber.complete();
            return;
          }
          subscriber.next(start);
          if (subscriber.closed) {
            return;
          }
          state.index = index + 1;
          state.start = start + 1;
          this.schedule(state);
        }
        exports.dispatch = dispatch;
      },
      { "../Observable": 339 },
    ],
    379: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        function throwError(error, scheduler) {
          if (!scheduler) {
            return new Observable_1.Observable(function (subscriber) {
              return subscriber.error(error);
            });
          } else {
            return new Observable_1.Observable(function (subscriber) {
              return scheduler.schedule(dispatch, 0, {
                error: error,
                subscriber: subscriber,
              });
            });
          }
        }
        exports.throwError = throwError;
        function dispatch(_a) {
          var error = _a.error,
            subscriber = _a.subscriber;
          subscriber.error(error);
        }
      },
      { "../Observable": 339 },
    ],
    380: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var async_1 = require("../scheduler/async");
        var isNumeric_1 = require("../util/isNumeric");
        var isScheduler_1 = require("../util/isScheduler");
        function timer(dueTime, periodOrScheduler, scheduler) {
          if (dueTime === void 0) {
            dueTime = 0;
          }
          var period = -1;
          if (isNumeric_1.isNumeric(periodOrScheduler)) {
            period =
              (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);
          } else if (isScheduler_1.isScheduler(periodOrScheduler)) {
            scheduler = periodOrScheduler;
          }
          if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
          }
          return new Observable_1.Observable(function (subscriber) {
            var due = isNumeric_1.isNumeric(dueTime)
              ? dueTime
              : +dueTime - scheduler.now();
            return scheduler.schedule(dispatch, due, {
              index: 0,
              period: period,
              subscriber: subscriber,
            });
          });
        }
        exports.timer = timer;
        function dispatch(state) {
          var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
          subscriber.next(index);
          if (subscriber.closed) {
            return;
          } else if (period === -1) {
            return subscriber.complete();
          }
          state.index = index + 1;
          this.schedule(state, period);
        }
      },
      {
        "../Observable": 339,
        "../scheduler/async": 503,
        "../util/isNumeric": 530,
        "../util/isScheduler": 534,
      },
    ],
    381: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var from_1 = require("./from");
        var empty_1 = require("./empty");
        function using(resourceFactory, observableFactory) {
          return new Observable_1.Observable(function (subscriber) {
            var resource;
            try {
              resource = resourceFactory();
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }
            var result;
            try {
              result = observableFactory(resource);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }
            var source = result ? from_1.from(result) : empty_1.EMPTY;
            var subscription = source.subscribe(subscriber);
            return function () {
              subscription.unsubscribe();
              if (resource) {
                resource.unsubscribe();
              }
            };
          });
        }
        exports.using = using;
      },
      { "../Observable": 339, "./empty": 360, "./from": 362 },
    ],
    382: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var fromArray_1 = require("./fromArray");
        var isArray_1 = require("../util/isArray");
        var Subscriber_1 = require("../Subscriber");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var iterator_1 = require("../../internal/symbol/iterator");
        function zip() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          var resultSelector = observables[observables.length - 1];
          if (typeof resultSelector === "function") {
            observables.pop();
          }
          return fromArray_1
            .fromArray(observables, undefined)
            .lift(new ZipOperator(resultSelector));
        }
        exports.zip = zip;
        var ZipOperator = (function () {
          function ZipOperator(resultSelector) {
            this.resultSelector = resultSelector;
          }
          ZipOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new ZipSubscriber(subscriber, this.resultSelector)
            );
          };
          return ZipOperator;
        })();
        exports.ZipOperator = ZipOperator;
        var ZipSubscriber = (function (_super) {
          __extends(ZipSubscriber, _super);
          function ZipSubscriber(destination, resultSelector, values) {
            if (values === void 0) {
              values = Object.create(null);
            }
            var _this = _super.call(this, destination) || this;
            _this.iterators = [];
            _this.active = 0;
            _this.resultSelector =
              typeof resultSelector === "function" ? resultSelector : null;
            _this.values = values;
            return _this;
          }
          ZipSubscriber.prototype._next = function (value) {
            var iterators = this.iterators;
            if (isArray_1.isArray(value)) {
              iterators.push(new StaticArrayIterator(value));
            } else if (typeof value[iterator_1.iterator] === "function") {
              iterators.push(new StaticIterator(value[iterator_1.iterator]()));
            } else {
              iterators.push(
                new ZipBufferIterator(this.destination, this, value)
              );
            }
          };
          ZipSubscriber.prototype._complete = function () {
            var iterators = this.iterators;
            var len = iterators.length;
            this.unsubscribe();
            if (len === 0) {
              this.destination.complete();
              return;
            }
            this.active = len;
            for (var i = 0; i < len; i++) {
              var iterator = iterators[i];
              if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe(iterator, i));
              } else {
                this.active--;
              }
            }
          };
          ZipSubscriber.prototype.notifyInactive = function () {
            this.active--;
            if (this.active === 0) {
              this.destination.complete();
            }
          };
          ZipSubscriber.prototype.checkIterators = function () {
            var iterators = this.iterators;
            var len = iterators.length;
            var destination = this.destination;
            for (var i = 0; i < len; i++) {
              var iterator = iterators[i];
              if (
                typeof iterator.hasValue === "function" &&
                !iterator.hasValue()
              ) {
                return;
              }
            }
            var shouldComplete = false;
            var args = [];
            for (var i = 0; i < len; i++) {
              var iterator = iterators[i];
              var result = iterator.next();
              if (iterator.hasCompleted()) {
                shouldComplete = true;
              }
              if (result.done) {
                destination.complete();
                return;
              }
              args.push(result.value);
            }
            if (this.resultSelector) {
              this._tryresultSelector(args);
            } else {
              destination.next(args);
            }
            if (shouldComplete) {
              destination.complete();
            }
          };
          ZipSubscriber.prototype._tryresultSelector = function (args) {
            var result;
            try {
              result = this.resultSelector.apply(this, args);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            this.destination.next(result);
          };
          return ZipSubscriber;
        })(Subscriber_1.Subscriber);
        exports.ZipSubscriber = ZipSubscriber;
        var StaticIterator = (function () {
          function StaticIterator(iterator) {
            this.iterator = iterator;
            this.nextResult = iterator.next();
          }
          StaticIterator.prototype.hasValue = function () {
            return true;
          };
          StaticIterator.prototype.next = function () {
            var result = this.nextResult;
            this.nextResult = this.iterator.next();
            return result;
          };
          StaticIterator.prototype.hasCompleted = function () {
            var nextResult = this.nextResult;
            return nextResult && nextResult.done;
          };
          return StaticIterator;
        })();
        var StaticArrayIterator = (function () {
          function StaticArrayIterator(array) {
            this.array = array;
            this.index = 0;
            this.length = 0;
            this.length = array.length;
          }
          StaticArrayIterator.prototype[iterator_1.iterator] = function () {
            return this;
          };
          StaticArrayIterator.prototype.next = function (value) {
            var i = this.index++;
            var array = this.array;
            return i < this.length
              ? { value: array[i], done: false }
              : { value: null, done: true };
          };
          StaticArrayIterator.prototype.hasValue = function () {
            return this.array.length > this.index;
          };
          StaticArrayIterator.prototype.hasCompleted = function () {
            return this.array.length === this.index;
          };
          return StaticArrayIterator;
        })();
        var ZipBufferIterator = (function (_super) {
          __extends(ZipBufferIterator, _super);
          function ZipBufferIterator(destination, parent, observable) {
            var _this = _super.call(this, destination) || this;
            _this.parent = parent;
            _this.observable = observable;
            _this.stillUnsubscribed = true;
            _this.buffer = [];
            _this.isComplete = false;
            return _this;
          }
          ZipBufferIterator.prototype[iterator_1.iterator] = function () {
            return this;
          };
          ZipBufferIterator.prototype.next = function () {
            var buffer = this.buffer;
            if (buffer.length === 0 && this.isComplete) {
              return { value: null, done: true };
            } else {
              return { value: buffer.shift(), done: false };
            }
          };
          ZipBufferIterator.prototype.hasValue = function () {
            return this.buffer.length > 0;
          };
          ZipBufferIterator.prototype.hasCompleted = function () {
            return this.buffer.length === 0 && this.isComplete;
          };
          ZipBufferIterator.prototype.notifyComplete = function () {
            if (this.buffer.length > 0) {
              this.isComplete = true;
              this.parent.notifyInactive();
            } else {
              this.destination.complete();
            }
          };
          ZipBufferIterator.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.buffer.push(innerValue);
            this.parent.checkIterators();
          };
          ZipBufferIterator.prototype.subscribe = function (value, index) {
            return subscribeToResult_1.subscribeToResult(
              this,
              this.observable,
              this,
              index
            );
          };
          return ZipBufferIterator;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../../internal/symbol/iterator": 505,
        "../OuterSubscriber": 341,
        "../Subscriber": 346,
        "../util/isArray": 524,
        "../util/subscribeToResult": 544,
        "./fromArray": 363,
      },
    ],
    383: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function audit(durationSelector) {
          return function auditOperatorFunction(source) {
            return source.lift(new AuditOperator(durationSelector));
          };
        }
        exports.audit = audit;
        var AuditOperator = (function () {
          function AuditOperator(durationSelector) {
            this.durationSelector = durationSelector;
          }
          AuditOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new AuditSubscriber(subscriber, this.durationSelector)
            );
          };
          return AuditOperator;
        })();
        var AuditSubscriber = (function (_super) {
          __extends(AuditSubscriber, _super);
          function AuditSubscriber(destination, durationSelector) {
            var _this = _super.call(this, destination) || this;
            _this.durationSelector = durationSelector;
            _this.hasValue = false;
            return _this;
          }
          AuditSubscriber.prototype._next = function (value) {
            this.value = value;
            this.hasValue = true;
            if (!this.throttled) {
              var duration = void 0;
              try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
              } catch (err) {
                return this.destination.error(err);
              }
              var innerSubscription = subscribeToResult_1.subscribeToResult(
                this,
                duration
              );
              if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
              } else {
                this.add((this.throttled = innerSubscription));
              }
            }
          };
          AuditSubscriber.prototype.clearThrottle = function () {
            var _a = this,
              value = _a.value,
              hasValue = _a.hasValue,
              throttled = _a.throttled;
            if (throttled) {
              this.remove(throttled);
              this.throttled = null;
              throttled.unsubscribe();
            }
            if (hasValue) {
              this.value = null;
              this.hasValue = false;
              this.destination.next(value);
            }
          };
          AuditSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex
          ) {
            this.clearThrottle();
          };
          AuditSubscriber.prototype.notifyComplete = function () {
            this.clearThrottle();
          };
          return AuditSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    384: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var async_1 = require("../scheduler/async");
        var audit_1 = require("./audit");
        var timer_1 = require("../observable/timer");
        function auditTime(duration, scheduler) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          return audit_1.audit(function () {
            return timer_1.timer(duration, scheduler);
          });
        }
        exports.auditTime = auditTime;
      },
      { "../observable/timer": 380, "../scheduler/async": 503, "./audit": 383 },
    ],
    385: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function buffer(closingNotifier) {
          return function bufferOperatorFunction(source) {
            return source.lift(new BufferOperator(closingNotifier));
          };
        }
        exports.buffer = buffer;
        var BufferOperator = (function () {
          function BufferOperator(closingNotifier) {
            this.closingNotifier = closingNotifier;
          }
          BufferOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new BufferSubscriber(subscriber, this.closingNotifier)
            );
          };
          return BufferOperator;
        })();
        var BufferSubscriber = (function (_super) {
          __extends(BufferSubscriber, _super);
          function BufferSubscriber(destination, closingNotifier) {
            var _this = _super.call(this, destination) || this;
            _this.buffer = [];
            _this.add(
              subscribeToResult_1.subscribeToResult(_this, closingNotifier)
            );
            return _this;
          }
          BufferSubscriber.prototype._next = function (value) {
            this.buffer.push(value);
          };
          BufferSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            var buffer = this.buffer;
            this.buffer = [];
            this.destination.next(buffer);
          };
          return BufferSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    386: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function bufferCount(bufferSize, startBufferEvery) {
          if (startBufferEvery === void 0) {
            startBufferEvery = null;
          }
          return function bufferCountOperatorFunction(source) {
            return source.lift(
              new BufferCountOperator(bufferSize, startBufferEvery)
            );
          };
        }
        exports.bufferCount = bufferCount;
        var BufferCountOperator = (function () {
          function BufferCountOperator(bufferSize, startBufferEvery) {
            this.bufferSize = bufferSize;
            this.startBufferEvery = startBufferEvery;
            if (!startBufferEvery || bufferSize === startBufferEvery) {
              this.subscriberClass = BufferCountSubscriber;
            } else {
              this.subscriberClass = BufferSkipCountSubscriber;
            }
          }
          BufferCountOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new this.subscriberClass(
                subscriber,
                this.bufferSize,
                this.startBufferEvery
              )
            );
          };
          return BufferCountOperator;
        })();
        var BufferCountSubscriber = (function (_super) {
          __extends(BufferCountSubscriber, _super);
          function BufferCountSubscriber(destination, bufferSize) {
            var _this = _super.call(this, destination) || this;
            _this.bufferSize = bufferSize;
            _this.buffer = [];
            return _this;
          }
          BufferCountSubscriber.prototype._next = function (value) {
            var buffer = this.buffer;
            buffer.push(value);
            if (buffer.length == this.bufferSize) {
              this.destination.next(buffer);
              this.buffer = [];
            }
          };
          BufferCountSubscriber.prototype._complete = function () {
            var buffer = this.buffer;
            if (buffer.length > 0) {
              this.destination.next(buffer);
            }
            _super.prototype._complete.call(this);
          };
          return BufferCountSubscriber;
        })(Subscriber_1.Subscriber);
        var BufferSkipCountSubscriber = (function (_super) {
          __extends(BufferSkipCountSubscriber, _super);
          function BufferSkipCountSubscriber(
            destination,
            bufferSize,
            startBufferEvery
          ) {
            var _this = _super.call(this, destination) || this;
            _this.bufferSize = bufferSize;
            _this.startBufferEvery = startBufferEvery;
            _this.buffers = [];
            _this.count = 0;
            return _this;
          }
          BufferSkipCountSubscriber.prototype._next = function (value) {
            var _a = this,
              bufferSize = _a.bufferSize,
              startBufferEvery = _a.startBufferEvery,
              buffers = _a.buffers,
              count = _a.count;
            this.count++;
            if (count % startBufferEvery === 0) {
              buffers.push([]);
            }
            for (var i = buffers.length; i--; ) {
              var buffer = buffers[i];
              buffer.push(value);
              if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
              }
            }
          };
          BufferSkipCountSubscriber.prototype._complete = function () {
            var _a = this,
              buffers = _a.buffers,
              destination = _a.destination;
            while (buffers.length > 0) {
              var buffer = buffers.shift();
              if (buffer.length > 0) {
                destination.next(buffer);
              }
            }
            _super.prototype._complete.call(this);
          };
          return BufferSkipCountSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    387: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var async_1 = require("../scheduler/async");
        var Subscriber_1 = require("../Subscriber");
        var isScheduler_1 = require("../util/isScheduler");
        function bufferTime(bufferTimeSpan) {
          var length = arguments.length;
          var scheduler = async_1.async;
          if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
            scheduler = arguments[arguments.length - 1];
            length--;
          }
          var bufferCreationInterval = null;
          if (length >= 2) {
            bufferCreationInterval = arguments[1];
          }
          var maxBufferSize = Number.POSITIVE_INFINITY;
          if (length >= 3) {
            maxBufferSize = arguments[2];
          }
          return function bufferTimeOperatorFunction(source) {
            return source.lift(
              new BufferTimeOperator(
                bufferTimeSpan,
                bufferCreationInterval,
                maxBufferSize,
                scheduler
              )
            );
          };
        }
        exports.bufferTime = bufferTime;
        var BufferTimeOperator = (function () {
          function BufferTimeOperator(
            bufferTimeSpan,
            bufferCreationInterval,
            maxBufferSize,
            scheduler
          ) {
            this.bufferTimeSpan = bufferTimeSpan;
            this.bufferCreationInterval = bufferCreationInterval;
            this.maxBufferSize = maxBufferSize;
            this.scheduler = scheduler;
          }
          BufferTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new BufferTimeSubscriber(
                subscriber,
                this.bufferTimeSpan,
                this.bufferCreationInterval,
                this.maxBufferSize,
                this.scheduler
              )
            );
          };
          return BufferTimeOperator;
        })();
        var Context = (function () {
          function Context() {
            this.buffer = [];
          }
          return Context;
        })();
        var BufferTimeSubscriber = (function (_super) {
          __extends(BufferTimeSubscriber, _super);
          function BufferTimeSubscriber(
            destination,
            bufferTimeSpan,
            bufferCreationInterval,
            maxBufferSize,
            scheduler
          ) {
            var _this = _super.call(this, destination) || this;
            _this.bufferTimeSpan = bufferTimeSpan;
            _this.bufferCreationInterval = bufferCreationInterval;
            _this.maxBufferSize = maxBufferSize;
            _this.scheduler = scheduler;
            _this.contexts = [];
            var context = _this.openContext();
            _this.timespanOnly =
              bufferCreationInterval == null || bufferCreationInterval < 0;
            if (_this.timespanOnly) {
              var timeSpanOnlyState = {
                subscriber: _this,
                context: context,
                bufferTimeSpan: bufferTimeSpan,
              };
              _this.add(
                (context.closeAction = scheduler.schedule(
                  dispatchBufferTimeSpanOnly,
                  bufferTimeSpan,
                  timeSpanOnlyState
                ))
              );
            } else {
              var closeState = { subscriber: _this, context: context };
              var creationState = {
                bufferTimeSpan: bufferTimeSpan,
                bufferCreationInterval: bufferCreationInterval,
                subscriber: _this,
                scheduler: scheduler,
              };
              _this.add(
                (context.closeAction = scheduler.schedule(
                  dispatchBufferClose,
                  bufferTimeSpan,
                  closeState
                ))
              );
              _this.add(
                scheduler.schedule(
                  dispatchBufferCreation,
                  bufferCreationInterval,
                  creationState
                )
              );
            }
            return _this;
          }
          BufferTimeSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            var len = contexts.length;
            var filledBufferContext;
            for (var i = 0; i < len; i++) {
              var context_1 = contexts[i];
              var buffer = context_1.buffer;
              buffer.push(value);
              if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
              }
            }
            if (filledBufferContext) {
              this.onBufferFull(filledBufferContext);
            }
          };
          BufferTimeSubscriber.prototype._error = function (err) {
            this.contexts.length = 0;
            _super.prototype._error.call(this, err);
          };
          BufferTimeSubscriber.prototype._complete = function () {
            var _a = this,
              contexts = _a.contexts,
              destination = _a.destination;
            while (contexts.length > 0) {
              var context_2 = contexts.shift();
              destination.next(context_2.buffer);
            }
            _super.prototype._complete.call(this);
          };
          BufferTimeSubscriber.prototype._unsubscribe = function () {
            this.contexts = null;
          };
          BufferTimeSubscriber.prototype.onBufferFull = function (context) {
            this.closeContext(context);
            var closeAction = context.closeAction;
            closeAction.unsubscribe();
            this.remove(closeAction);
            if (!this.closed && this.timespanOnly) {
              context = this.openContext();
              var bufferTimeSpan = this.bufferTimeSpan;
              var timeSpanOnlyState = {
                subscriber: this,
                context: context,
                bufferTimeSpan: bufferTimeSpan,
              };
              this.add(
                (context.closeAction = this.scheduler.schedule(
                  dispatchBufferTimeSpanOnly,
                  bufferTimeSpan,
                  timeSpanOnlyState
                ))
              );
            }
          };
          BufferTimeSubscriber.prototype.openContext = function () {
            var context = new Context();
            this.contexts.push(context);
            return context;
          };
          BufferTimeSubscriber.prototype.closeContext = function (context) {
            this.destination.next(context.buffer);
            var contexts = this.contexts;
            var spliceIndex = contexts ? contexts.indexOf(context) : -1;
            if (spliceIndex >= 0) {
              contexts.splice(contexts.indexOf(context), 1);
            }
          };
          return BufferTimeSubscriber;
        })(Subscriber_1.Subscriber);
        function dispatchBufferTimeSpanOnly(state) {
          var subscriber = state.subscriber;
          var prevContext = state.context;
          if (prevContext) {
            subscriber.closeContext(prevContext);
          }
          if (!subscriber.closed) {
            state.context = subscriber.openContext();
            state.context.closeAction = this.schedule(
              state,
              state.bufferTimeSpan
            );
          }
        }
        function dispatchBufferCreation(state) {
          var bufferCreationInterval = state.bufferCreationInterval,
            bufferTimeSpan = state.bufferTimeSpan,
            subscriber = state.subscriber,
            scheduler = state.scheduler;
          var context = subscriber.openContext();
          var action = this;
          if (!subscriber.closed) {
            subscriber.add(
              (context.closeAction = scheduler.schedule(
                dispatchBufferClose,
                bufferTimeSpan,
                { subscriber: subscriber, context: context }
              ))
            );
            action.schedule(state, bufferCreationInterval);
          }
        }
        function dispatchBufferClose(arg) {
          var subscriber = arg.subscriber,
            context = arg.context;
          subscriber.closeContext(context);
        }
      },
      {
        "../Subscriber": 346,
        "../scheduler/async": 503,
        "../util/isScheduler": 534,
      },
    ],
    388: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscription_1 = require("../Subscription");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        function bufferToggle(openings, closingSelector) {
          return function bufferToggleOperatorFunction(source) {
            return source.lift(
              new BufferToggleOperator(openings, closingSelector)
            );
          };
        }
        exports.bufferToggle = bufferToggle;
        var BufferToggleOperator = (function () {
          function BufferToggleOperator(openings, closingSelector) {
            this.openings = openings;
            this.closingSelector = closingSelector;
          }
          BufferToggleOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new BufferToggleSubscriber(
                subscriber,
                this.openings,
                this.closingSelector
              )
            );
          };
          return BufferToggleOperator;
        })();
        var BufferToggleSubscriber = (function (_super) {
          __extends(BufferToggleSubscriber, _super);
          function BufferToggleSubscriber(
            destination,
            openings,
            closingSelector
          ) {
            var _this = _super.call(this, destination) || this;
            _this.openings = openings;
            _this.closingSelector = closingSelector;
            _this.contexts = [];
            _this.add(subscribeToResult_1.subscribeToResult(_this, openings));
            return _this;
          }
          BufferToggleSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
              contexts[i].buffer.push(value);
            }
          };
          BufferToggleSubscriber.prototype._error = function (err) {
            var contexts = this.contexts;
            while (contexts.length > 0) {
              var context_1 = contexts.shift();
              context_1.subscription.unsubscribe();
              context_1.buffer = null;
              context_1.subscription = null;
            }
            this.contexts = null;
            _super.prototype._error.call(this, err);
          };
          BufferToggleSubscriber.prototype._complete = function () {
            var contexts = this.contexts;
            while (contexts.length > 0) {
              var context_2 = contexts.shift();
              this.destination.next(context_2.buffer);
              context_2.subscription.unsubscribe();
              context_2.buffer = null;
              context_2.subscription = null;
            }
            this.contexts = null;
            _super.prototype._complete.call(this);
          };
          BufferToggleSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            outerValue
              ? this.closeBuffer(outerValue)
              : this.openBuffer(innerValue);
          };
          BufferToggleSubscriber.prototype.notifyComplete = function (
            innerSub
          ) {
            this.closeBuffer(innerSub.context);
          };
          BufferToggleSubscriber.prototype.openBuffer = function (value) {
            try {
              var closingSelector = this.closingSelector;
              var closingNotifier = closingSelector.call(this, value);
              if (closingNotifier) {
                this.trySubscribe(closingNotifier);
              }
            } catch (err) {
              this._error(err);
            }
          };
          BufferToggleSubscriber.prototype.closeBuffer = function (context) {
            var contexts = this.contexts;
            if (contexts && context) {
              var buffer = context.buffer,
                subscription = context.subscription;
              this.destination.next(buffer);
              contexts.splice(contexts.indexOf(context), 1);
              this.remove(subscription);
              subscription.unsubscribe();
            }
          };
          BufferToggleSubscriber.prototype.trySubscribe = function (
            closingNotifier
          ) {
            var contexts = this.contexts;
            var buffer = [];
            var subscription = new Subscription_1.Subscription();
            var context = { buffer: buffer, subscription: subscription };
            contexts.push(context);
            var innerSubscription = subscribeToResult_1.subscribeToResult(
              this,
              closingNotifier,
              context
            );
            if (!innerSubscription || innerSubscription.closed) {
              this.closeBuffer(context);
            } else {
              innerSubscription.context = context;
              this.add(innerSubscription);
              subscription.add(innerSubscription);
            }
          };
          return BufferToggleSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../OuterSubscriber": 341,
        "../Subscription": 347,
        "../util/subscribeToResult": 544,
      },
    ],
    389: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscription_1 = require("../Subscription");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function bufferWhen(closingSelector) {
          return function (source) {
            return source.lift(new BufferWhenOperator(closingSelector));
          };
        }
        exports.bufferWhen = bufferWhen;
        var BufferWhenOperator = (function () {
          function BufferWhenOperator(closingSelector) {
            this.closingSelector = closingSelector;
          }
          BufferWhenOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new BufferWhenSubscriber(subscriber, this.closingSelector)
            );
          };
          return BufferWhenOperator;
        })();
        var BufferWhenSubscriber = (function (_super) {
          __extends(BufferWhenSubscriber, _super);
          function BufferWhenSubscriber(destination, closingSelector) {
            var _this = _super.call(this, destination) || this;
            _this.closingSelector = closingSelector;
            _this.subscribing = false;
            _this.openBuffer();
            return _this;
          }
          BufferWhenSubscriber.prototype._next = function (value) {
            this.buffer.push(value);
          };
          BufferWhenSubscriber.prototype._complete = function () {
            var buffer = this.buffer;
            if (buffer) {
              this.destination.next(buffer);
            }
            _super.prototype._complete.call(this);
          };
          BufferWhenSubscriber.prototype._unsubscribe = function () {
            this.buffer = null;
            this.subscribing = false;
          };
          BufferWhenSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.openBuffer();
          };
          BufferWhenSubscriber.prototype.notifyComplete = function () {
            if (this.subscribing) {
              this.complete();
            } else {
              this.openBuffer();
            }
          };
          BufferWhenSubscriber.prototype.openBuffer = function () {
            var closingSubscription = this.closingSubscription;
            if (closingSubscription) {
              this.remove(closingSubscription);
              closingSubscription.unsubscribe();
            }
            var buffer = this.buffer;
            if (this.buffer) {
              this.destination.next(buffer);
            }
            this.buffer = [];
            var closingNotifier;
            try {
              var closingSelector = this.closingSelector;
              closingNotifier = closingSelector();
            } catch (err) {
              return this.error(err);
            }
            closingSubscription = new Subscription_1.Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(
              subscribeToResult_1.subscribeToResult(this, closingNotifier)
            );
            this.subscribing = false;
          };
          return BufferWhenSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../OuterSubscriber": 341,
        "../Subscription": 347,
        "../util/subscribeToResult": 544,
      },
    ],
    390: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var InnerSubscriber_1 = require("../InnerSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function catchError(selector) {
          return function catchErrorOperatorFunction(source) {
            var operator = new CatchOperator(selector);
            var caught = source.lift(operator);
            return (operator.caught = caught);
          };
        }
        exports.catchError = catchError;
        var CatchOperator = (function () {
          function CatchOperator(selector) {
            this.selector = selector;
          }
          CatchOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new CatchSubscriber(subscriber, this.selector, this.caught)
            );
          };
          return CatchOperator;
        })();
        var CatchSubscriber = (function (_super) {
          __extends(CatchSubscriber, _super);
          function CatchSubscriber(destination, selector, caught) {
            var _this = _super.call(this, destination) || this;
            _this.selector = selector;
            _this.caught = caught;
            return _this;
          }
          CatchSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
              var result = void 0;
              try {
                result = this.selector(err, this.caught);
              } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
              }
              this._unsubscribeAndRecycle();
              var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(
                this,
                undefined,
                undefined
              );
              this.add(innerSubscriber);
              var innerSubscription = subscribeToResult_1.subscribeToResult(
                this,
                result,
                undefined,
                undefined,
                innerSubscriber
              );
              if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
              }
            }
          };
          return CatchSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../InnerSubscriber": 337,
        "../OuterSubscriber": 341,
        "../util/subscribeToResult": 544,
      },
    ],
    391: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var combineLatest_1 = require("../observable/combineLatest");
        function combineAll(project) {
          return function (source) {
            return source.lift(
              new combineLatest_1.CombineLatestOperator(project)
            );
          };
        }
        exports.combineAll = combineAll;
      },
      { "../observable/combineLatest": 353 },
    ],
    392: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isArray_1 = require("../util/isArray");
        var combineLatest_1 = require("../observable/combineLatest");
        var from_1 = require("../observable/from");
        var none = {};
        function combineLatest() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          var project = null;
          if (typeof observables[observables.length - 1] === "function") {
            project = observables.pop();
          }
          if (observables.length === 1 && isArray_1.isArray(observables[0])) {
            observables = observables[0].slice();
          }
          return function (source) {
            return source.lift.call(
              from_1.from([source].concat(observables)),
              new combineLatest_1.CombineLatestOperator(project)
            );
          };
        }
        exports.combineLatest = combineLatest;
      },
      {
        "../observable/combineLatest": 353,
        "../observable/from": 362,
        "../util/isArray": 524,
      },
    ],
    393: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var concat_1 = require("../observable/concat");
        function concat() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return function (source) {
            return source.lift.call(
              concat_1.concat.apply(void 0, [source].concat(observables))
            );
          };
        }
        exports.concat = concat;
      },
      { "../observable/concat": 354 },
    ],
    394: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var mergeAll_1 = require("./mergeAll");
        function concatAll() {
          return mergeAll_1.mergeAll(1);
        }
        exports.concatAll = concatAll;
      },
      { "./mergeAll": 427 },
    ],
    395: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var mergeMap_1 = require("./mergeMap");
        function concatMap(project, resultSelector) {
          return mergeMap_1.mergeMap(project, resultSelector, 1);
        }
        exports.concatMap = concatMap;
      },
      { "./mergeMap": 428 },
    ],
    396: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var concatMap_1 = require("./concatMap");
        function concatMapTo(innerObservable, resultSelector) {
          return concatMap_1.concatMap(function () {
            return innerObservable;
          }, resultSelector);
        }
        exports.concatMapTo = concatMapTo;
      },
      { "./concatMap": 395 },
    ],
    397: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function count(predicate) {
          return function (source) {
            return source.lift(new CountOperator(predicate, source));
          };
        }
        exports.count = count;
        var CountOperator = (function () {
          function CountOperator(predicate, source) {
            this.predicate = predicate;
            this.source = source;
          }
          CountOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new CountSubscriber(subscriber, this.predicate, this.source)
            );
          };
          return CountOperator;
        })();
        var CountSubscriber = (function (_super) {
          __extends(CountSubscriber, _super);
          function CountSubscriber(destination, predicate, source) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.source = source;
            _this.count = 0;
            _this.index = 0;
            return _this;
          }
          CountSubscriber.prototype._next = function (value) {
            if (this.predicate) {
              this._tryPredicate(value);
            } else {
              this.count++;
            }
          };
          CountSubscriber.prototype._tryPredicate = function (value) {
            var result;
            try {
              result = this.predicate(value, this.index++, this.source);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            if (result) {
              this.count++;
            }
          };
          CountSubscriber.prototype._complete = function () {
            this.destination.next(this.count);
            this.destination.complete();
          };
          return CountSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    398: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function debounce(durationSelector) {
          return function (source) {
            return source.lift(new DebounceOperator(durationSelector));
          };
        }
        exports.debounce = debounce;
        var DebounceOperator = (function () {
          function DebounceOperator(durationSelector) {
            this.durationSelector = durationSelector;
          }
          DebounceOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new DebounceSubscriber(subscriber, this.durationSelector)
            );
          };
          return DebounceOperator;
        })();
        var DebounceSubscriber = (function (_super) {
          __extends(DebounceSubscriber, _super);
          function DebounceSubscriber(destination, durationSelector) {
            var _this = _super.call(this, destination) || this;
            _this.durationSelector = durationSelector;
            _this.hasValue = false;
            _this.durationSubscription = null;
            return _this;
          }
          DebounceSubscriber.prototype._next = function (value) {
            try {
              var result = this.durationSelector.call(this, value);
              if (result) {
                this._tryNext(value, result);
              }
            } catch (err) {
              this.destination.error(err);
            }
          };
          DebounceSubscriber.prototype._complete = function () {
            this.emitValue();
            this.destination.complete();
          };
          DebounceSubscriber.prototype._tryNext = function (value, duration) {
            var subscription = this.durationSubscription;
            this.value = value;
            this.hasValue = true;
            if (subscription) {
              subscription.unsubscribe();
              this.remove(subscription);
            }
            subscription = subscribeToResult_1.subscribeToResult(
              this,
              duration
            );
            if (subscription && !subscription.closed) {
              this.add((this.durationSubscription = subscription));
            }
          };
          DebounceSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.emitValue();
          };
          DebounceSubscriber.prototype.notifyComplete = function () {
            this.emitValue();
          };
          DebounceSubscriber.prototype.emitValue = function () {
            if (this.hasValue) {
              var value = this.value;
              var subscription = this.durationSubscription;
              if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
              }
              this.value = null;
              this.hasValue = false;
              _super.prototype._next.call(this, value);
            }
          };
          return DebounceSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    399: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var async_1 = require("../scheduler/async");
        function debounceTime(dueTime, scheduler) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          return function (source) {
            return source.lift(new DebounceTimeOperator(dueTime, scheduler));
          };
        }
        exports.debounceTime = debounceTime;
        var DebounceTimeOperator = (function () {
          function DebounceTimeOperator(dueTime, scheduler) {
            this.dueTime = dueTime;
            this.scheduler = scheduler;
          }
          DebounceTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new DebounceTimeSubscriber(
                subscriber,
                this.dueTime,
                this.scheduler
              )
            );
          };
          return DebounceTimeOperator;
        })();
        var DebounceTimeSubscriber = (function (_super) {
          __extends(DebounceTimeSubscriber, _super);
          function DebounceTimeSubscriber(destination, dueTime, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.dueTime = dueTime;
            _this.scheduler = scheduler;
            _this.debouncedSubscription = null;
            _this.lastValue = null;
            _this.hasValue = false;
            return _this;
          }
          DebounceTimeSubscriber.prototype._next = function (value) {
            this.clearDebounce();
            this.lastValue = value;
            this.hasValue = true;
            this.add(
              (this.debouncedSubscription = this.scheduler.schedule(
                dispatchNext,
                this.dueTime,
                this
              ))
            );
          };
          DebounceTimeSubscriber.prototype._complete = function () {
            this.debouncedNext();
            this.destination.complete();
          };
          DebounceTimeSubscriber.prototype.debouncedNext = function () {
            this.clearDebounce();
            if (this.hasValue) {
              var lastValue = this.lastValue;
              this.lastValue = null;
              this.hasValue = false;
              this.destination.next(lastValue);
            }
          };
          DebounceTimeSubscriber.prototype.clearDebounce = function () {
            var debouncedSubscription = this.debouncedSubscription;
            if (debouncedSubscription !== null) {
              this.remove(debouncedSubscription);
              debouncedSubscription.unsubscribe();
              this.debouncedSubscription = null;
            }
          };
          return DebounceTimeSubscriber;
        })(Subscriber_1.Subscriber);
        function dispatchNext(subscriber) {
          subscriber.debouncedNext();
        }
      },
      { "../Subscriber": 346, "../scheduler/async": 503 },
    ],
    400: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function defaultIfEmpty(defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = null;
          }
          return function (source) {
            return source.lift(new DefaultIfEmptyOperator(defaultValue));
          };
        }
        exports.defaultIfEmpty = defaultIfEmpty;
        var DefaultIfEmptyOperator = (function () {
          function DefaultIfEmptyOperator(defaultValue) {
            this.defaultValue = defaultValue;
          }
          DefaultIfEmptyOperator.prototype.call = function (
            subscriber,
            source
          ) {
            return source.subscribe(
              new DefaultIfEmptySubscriber(subscriber, this.defaultValue)
            );
          };
          return DefaultIfEmptyOperator;
        })();
        var DefaultIfEmptySubscriber = (function (_super) {
          __extends(DefaultIfEmptySubscriber, _super);
          function DefaultIfEmptySubscriber(destination, defaultValue) {
            var _this = _super.call(this, destination) || this;
            _this.defaultValue = defaultValue;
            _this.isEmpty = true;
            return _this;
          }
          DefaultIfEmptySubscriber.prototype._next = function (value) {
            this.isEmpty = false;
            this.destination.next(value);
          };
          DefaultIfEmptySubscriber.prototype._complete = function () {
            if (this.isEmpty) {
              this.destination.next(this.defaultValue);
            }
            this.destination.complete();
          };
          return DefaultIfEmptySubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    401: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var async_1 = require("../scheduler/async");
        var isDate_1 = require("../util/isDate");
        var Subscriber_1 = require("../Subscriber");
        var Notification_1 = require("../Notification");
        function delay(delay, scheduler) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          var absoluteDelay = isDate_1.isDate(delay);
          var delayFor = absoluteDelay
            ? +delay - scheduler.now()
            : Math.abs(delay);
          return function (source) {
            return source.lift(new DelayOperator(delayFor, scheduler));
          };
        }
        exports.delay = delay;
        var DelayOperator = (function () {
          function DelayOperator(delay, scheduler) {
            this.delay = delay;
            this.scheduler = scheduler;
          }
          DelayOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new DelaySubscriber(subscriber, this.delay, this.scheduler)
            );
          };
          return DelayOperator;
        })();
        var DelaySubscriber = (function (_super) {
          __extends(DelaySubscriber, _super);
          function DelaySubscriber(destination, delay, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.delay = delay;
            _this.scheduler = scheduler;
            _this.queue = [];
            _this.active = false;
            _this.errored = false;
            return _this;
          }
          DelaySubscriber.dispatch = function (state) {
            var source = state.source;
            var queue = source.queue;
            var scheduler = state.scheduler;
            var destination = state.destination;
            while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
              queue.shift().notification.observe(destination);
            }
            if (queue.length > 0) {
              var delay_1 = Math.max(0, queue[0].time - scheduler.now());
              this.schedule(state, delay_1);
            } else {
              this.unsubscribe();
              source.active = false;
            }
          };
          DelaySubscriber.prototype._schedule = function (scheduler) {
            this.active = true;
            var destination = this.destination;
            destination.add(
              scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
                source: this,
                destination: this.destination,
                scheduler: scheduler,
              })
            );
          };
          DelaySubscriber.prototype.scheduleNotification = function (
            notification
          ) {
            if (this.errored === true) {
              return;
            }
            var scheduler = this.scheduler;
            var message = new DelayMessage(
              scheduler.now() + this.delay,
              notification
            );
            this.queue.push(message);
            if (this.active === false) {
              this._schedule(scheduler);
            }
          };
          DelaySubscriber.prototype._next = function (value) {
            this.scheduleNotification(
              Notification_1.Notification.createNext(value)
            );
          };
          DelaySubscriber.prototype._error = function (err) {
            this.errored = true;
            this.queue = [];
            this.destination.error(err);
            this.unsubscribe();
          };
          DelaySubscriber.prototype._complete = function () {
            this.scheduleNotification(
              Notification_1.Notification.createComplete()
            );
            this.unsubscribe();
          };
          return DelaySubscriber;
        })(Subscriber_1.Subscriber);
        var DelayMessage = (function () {
          function DelayMessage(time, notification) {
            this.time = time;
            this.notification = notification;
          }
          return DelayMessage;
        })();
      },
      {
        "../Notification": 338,
        "../Subscriber": 346,
        "../scheduler/async": 503,
        "../util/isDate": 526,
      },
    ],
    402: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var Observable_1 = require("../Observable");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function delayWhen(delayDurationSelector, subscriptionDelay) {
          if (subscriptionDelay) {
            return function (source) {
              return new SubscriptionDelayObservable(
                source,
                subscriptionDelay
              ).lift(new DelayWhenOperator(delayDurationSelector));
            };
          }
          return function (source) {
            return source.lift(new DelayWhenOperator(delayDurationSelector));
          };
        }
        exports.delayWhen = delayWhen;
        var DelayWhenOperator = (function () {
          function DelayWhenOperator(delayDurationSelector) {
            this.delayDurationSelector = delayDurationSelector;
          }
          DelayWhenOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new DelayWhenSubscriber(subscriber, this.delayDurationSelector)
            );
          };
          return DelayWhenOperator;
        })();
        var DelayWhenSubscriber = (function (_super) {
          __extends(DelayWhenSubscriber, _super);
          function DelayWhenSubscriber(destination, delayDurationSelector) {
            var _this = _super.call(this, destination) || this;
            _this.delayDurationSelector = delayDurationSelector;
            _this.completed = false;
            _this.delayNotifierSubscriptions = [];
            _this.index = 0;
            return _this;
          }
          DelayWhenSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.destination.next(outerValue);
            this.removeSubscription(innerSub);
            this.tryComplete();
          };
          DelayWhenSubscriber.prototype.notifyError = function (
            error,
            innerSub
          ) {
            this._error(error);
          };
          DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
            var value = this.removeSubscription(innerSub);
            if (value) {
              this.destination.next(value);
            }
            this.tryComplete();
          };
          DelayWhenSubscriber.prototype._next = function (value) {
            var index = this.index++;
            try {
              var delayNotifier = this.delayDurationSelector(value, index);
              if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
              }
            } catch (err) {
              this.destination.error(err);
            }
          };
          DelayWhenSubscriber.prototype._complete = function () {
            this.completed = true;
            this.tryComplete();
            this.unsubscribe();
          };
          DelayWhenSubscriber.prototype.removeSubscription = function (
            subscription
          ) {
            subscription.unsubscribe();
            var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(
              subscription
            );
            if (subscriptionIdx !== -1) {
              this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            }
            return subscription.outerValue;
          };
          DelayWhenSubscriber.prototype.tryDelay = function (
            delayNotifier,
            value
          ) {
            var notifierSubscription = subscribeToResult_1.subscribeToResult(
              this,
              delayNotifier,
              value
            );
            if (notifierSubscription && !notifierSubscription.closed) {
              var destination = this.destination;
              destination.add(notifierSubscription);
              this.delayNotifierSubscriptions.push(notifierSubscription);
            }
          };
          DelayWhenSubscriber.prototype.tryComplete = function () {
            if (
              this.completed &&
              this.delayNotifierSubscriptions.length === 0
            ) {
              this.destination.complete();
            }
          };
          return DelayWhenSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
        var SubscriptionDelayObservable = (function (_super) {
          __extends(SubscriptionDelayObservable, _super);
          function SubscriptionDelayObservable(source, subscriptionDelay) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subscriptionDelay = subscriptionDelay;
            return _this;
          }
          SubscriptionDelayObservable.prototype._subscribe = function (
            subscriber
          ) {
            this.subscriptionDelay.subscribe(
              new SubscriptionDelaySubscriber(subscriber, this.source)
            );
          };
          return SubscriptionDelayObservable;
        })(Observable_1.Observable);
        var SubscriptionDelaySubscriber = (function (_super) {
          __extends(SubscriptionDelaySubscriber, _super);
          function SubscriptionDelaySubscriber(parent, source) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            _this.source = source;
            _this.sourceSubscribed = false;
            return _this;
          }
          SubscriptionDelaySubscriber.prototype._next = function (unused) {
            this.subscribeToSource();
          };
          SubscriptionDelaySubscriber.prototype._error = function (err) {
            this.unsubscribe();
            this.parent.error(err);
          };
          SubscriptionDelaySubscriber.prototype._complete = function () {
            this.unsubscribe();
            this.subscribeToSource();
          };
          SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
            if (!this.sourceSubscribed) {
              this.sourceSubscribed = true;
              this.unsubscribe();
              this.source.subscribe(this.parent);
            }
          };
          return SubscriptionDelaySubscriber;
        })(Subscriber_1.Subscriber);
      },
      {
        "../Observable": 339,
        "../OuterSubscriber": 341,
        "../Subscriber": 346,
        "../util/subscribeToResult": 544,
      },
    ],
    403: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function dematerialize() {
          return function dematerializeOperatorFunction(source) {
            return source.lift(new DeMaterializeOperator());
          };
        }
        exports.dematerialize = dematerialize;
        var DeMaterializeOperator = (function () {
          function DeMaterializeOperator() {}
          DeMaterializeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DeMaterializeSubscriber(subscriber));
          };
          return DeMaterializeOperator;
        })();
        var DeMaterializeSubscriber = (function (_super) {
          __extends(DeMaterializeSubscriber, _super);
          function DeMaterializeSubscriber(destination) {
            return _super.call(this, destination) || this;
          }
          DeMaterializeSubscriber.prototype._next = function (value) {
            value.observe(this.destination);
          };
          return DeMaterializeSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    404: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function distinct(keySelector, flushes) {
          return function (source) {
            return source.lift(new DistinctOperator(keySelector, flushes));
          };
        }
        exports.distinct = distinct;
        var DistinctOperator = (function () {
          function DistinctOperator(keySelector, flushes) {
            this.keySelector = keySelector;
            this.flushes = flushes;
          }
          DistinctOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new DistinctSubscriber(subscriber, this.keySelector, this.flushes)
            );
          };
          return DistinctOperator;
        })();
        var DistinctSubscriber = (function (_super) {
          __extends(DistinctSubscriber, _super);
          function DistinctSubscriber(destination, keySelector, flushes) {
            var _this = _super.call(this, destination) || this;
            _this.keySelector = keySelector;
            _this.values = new Set();
            if (flushes) {
              _this.add(subscribeToResult_1.subscribeToResult(_this, flushes));
            }
            return _this;
          }
          DistinctSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.values.clear();
          };
          DistinctSubscriber.prototype.notifyError = function (
            error,
            innerSub
          ) {
            this._error(error);
          };
          DistinctSubscriber.prototype._next = function (value) {
            if (this.keySelector) {
              this._useKeySelector(value);
            } else {
              this._finalizeNext(value, value);
            }
          };
          DistinctSubscriber.prototype._useKeySelector = function (value) {
            var key;
            var destination = this.destination;
            try {
              key = this.keySelector(value);
            } catch (err) {
              destination.error(err);
              return;
            }
            this._finalizeNext(key, value);
          };
          DistinctSubscriber.prototype._finalizeNext = function (key, value) {
            var values = this.values;
            if (!values.has(key)) {
              values.add(key);
              this.destination.next(value);
            }
          };
          return DistinctSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
        exports.DistinctSubscriber = DistinctSubscriber;
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    405: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function distinctUntilChanged(compare, keySelector) {
          return function (source) {
            return source.lift(
              new DistinctUntilChangedOperator(compare, keySelector)
            );
          };
        }
        exports.distinctUntilChanged = distinctUntilChanged;
        var DistinctUntilChangedOperator = (function () {
          function DistinctUntilChangedOperator(compare, keySelector) {
            this.compare = compare;
            this.keySelector = keySelector;
          }
          DistinctUntilChangedOperator.prototype.call = function (
            subscriber,
            source
          ) {
            return source.subscribe(
              new DistinctUntilChangedSubscriber(
                subscriber,
                this.compare,
                this.keySelector
              )
            );
          };
          return DistinctUntilChangedOperator;
        })();
        var DistinctUntilChangedSubscriber = (function (_super) {
          __extends(DistinctUntilChangedSubscriber, _super);
          function DistinctUntilChangedSubscriber(
            destination,
            compare,
            keySelector
          ) {
            var _this = _super.call(this, destination) || this;
            _this.keySelector = keySelector;
            _this.hasKey = false;
            if (typeof compare === "function") {
              _this.compare = compare;
            }
            return _this;
          }
          DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
            return x === y;
          };
          DistinctUntilChangedSubscriber.prototype._next = function (value) {
            var key;
            try {
              var keySelector = this.keySelector;
              key = keySelector ? keySelector(value) : value;
            } catch (err) {
              return this.destination.error(err);
            }
            var result = false;
            if (this.hasKey) {
              try {
                var compare = this.compare;
                result = compare(this.key, key);
              } catch (err) {
                return this.destination.error(err);
              }
            } else {
              this.hasKey = true;
            }
            if (!result) {
              this.key = key;
              this.destination.next(value);
            }
          };
          return DistinctUntilChangedSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    406: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var distinctUntilChanged_1 = require("./distinctUntilChanged");
        function distinctUntilKeyChanged(key, compare) {
          return distinctUntilChanged_1.distinctUntilChanged(function (x, y) {
            return compare ? compare(x[key], y[key]) : x[key] === y[key];
          });
        }
        exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
      },
      { "./distinctUntilChanged": 405 },
    ],
    407: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
        var filter_1 = require("./filter");
        var throwIfEmpty_1 = require("./throwIfEmpty");
        var defaultIfEmpty_1 = require("./defaultIfEmpty");
        var take_1 = require("./take");
        function elementAt(index, defaultValue) {
          if (index < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
          }
          var hasDefaultValue = arguments.length >= 2;
          return function (source) {
            return source.pipe(
              filter_1.filter(function (v, i) {
                return i === index;
              }),
              take_1.take(1),
              hasDefaultValue
                ? defaultIfEmpty_1.defaultIfEmpty(defaultValue)
                : throwIfEmpty_1.throwIfEmpty(function () {
                    return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
                  })
            );
          };
        }
        exports.elementAt = elementAt;
      },
      {
        "../util/ArgumentOutOfRangeError": 513,
        "./defaultIfEmpty": 400,
        "./filter": 413,
        "./take": 465,
        "./throwIfEmpty": 472,
      },
    ],
    408: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var concat_1 = require("../observable/concat");
        var of_1 = require("../observable/of");
        function endWith() {
          var array = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
          }
          return function (source) {
            return concat_1.concat(source, of_1.of.apply(void 0, array));
          };
        }
        exports.endWith = endWith;
      },
      { "../observable/concat": 354, "../observable/of": 373 },
    ],
    409: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function every(predicate, thisArg) {
          return function (source) {
            return source.lift(new EveryOperator(predicate, thisArg, source));
          };
        }
        exports.every = every;
        var EveryOperator = (function () {
          function EveryOperator(predicate, thisArg, source) {
            this.predicate = predicate;
            this.thisArg = thisArg;
            this.source = source;
          }
          EveryOperator.prototype.call = function (observer, source) {
            return source.subscribe(
              new EverySubscriber(
                observer,
                this.predicate,
                this.thisArg,
                this.source
              )
            );
          };
          return EveryOperator;
        })();
        var EverySubscriber = (function (_super) {
          __extends(EverySubscriber, _super);
          function EverySubscriber(destination, predicate, thisArg, source) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.thisArg = thisArg;
            _this.source = source;
            _this.index = 0;
            _this.thisArg = thisArg || _this;
            return _this;
          }
          EverySubscriber.prototype.notifyComplete = function (
            everyValueMatch
          ) {
            this.destination.next(everyValueMatch);
            this.destination.complete();
          };
          EverySubscriber.prototype._next = function (value) {
            var result = false;
            try {
              result = this.predicate.call(
                this.thisArg,
                value,
                this.index++,
                this.source
              );
            } catch (err) {
              this.destination.error(err);
              return;
            }
            if (!result) {
              this.notifyComplete(false);
            }
          };
          EverySubscriber.prototype._complete = function () {
            this.notifyComplete(true);
          };
          return EverySubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    410: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function exhaust() {
          return function (source) {
            return source.lift(new SwitchFirstOperator());
          };
        }
        exports.exhaust = exhaust;
        var SwitchFirstOperator = (function () {
          function SwitchFirstOperator() {}
          SwitchFirstOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SwitchFirstSubscriber(subscriber));
          };
          return SwitchFirstOperator;
        })();
        var SwitchFirstSubscriber = (function (_super) {
          __extends(SwitchFirstSubscriber, _super);
          function SwitchFirstSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.hasCompleted = false;
            _this.hasSubscription = false;
            return _this;
          }
          SwitchFirstSubscriber.prototype._next = function (value) {
            if (!this.hasSubscription) {
              this.hasSubscription = true;
              this.add(subscribeToResult_1.subscribeToResult(this, value));
            }
          };
          SwitchFirstSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (!this.hasSubscription) {
              this.destination.complete();
            }
          };
          SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
            this.remove(innerSub);
            this.hasSubscription = false;
            if (this.hasCompleted) {
              this.destination.complete();
            }
          };
          return SwitchFirstSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    411: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var InnerSubscriber_1 = require("../InnerSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var map_1 = require("./map");
        var from_1 = require("../observable/from");
        function exhaustMap(project, resultSelector) {
          if (resultSelector) {
            return function (source) {
              return source.pipe(
                exhaustMap(function (a, i) {
                  return from_1.from(project(a, i)).pipe(
                    map_1.map(function (b, ii) {
                      return resultSelector(a, b, i, ii);
                    })
                  );
                })
              );
            };
          }
          return function (source) {
            return source.lift(new ExhaustMapOperator(project));
          };
        }
        exports.exhaustMap = exhaustMap;
        var ExhaustMapOperator = (function () {
          function ExhaustMapOperator(project) {
            this.project = project;
          }
          ExhaustMapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new ExhaustMapSubscriber(subscriber, this.project)
            );
          };
          return ExhaustMapOperator;
        })();
        var ExhaustMapSubscriber = (function (_super) {
          __extends(ExhaustMapSubscriber, _super);
          function ExhaustMapSubscriber(destination, project) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.hasSubscription = false;
            _this.hasCompleted = false;
            _this.index = 0;
            return _this;
          }
          ExhaustMapSubscriber.prototype._next = function (value) {
            if (!this.hasSubscription) {
              this.tryNext(value);
            }
          };
          ExhaustMapSubscriber.prototype.tryNext = function (value) {
            var result;
            var index = this.index++;
            try {
              result = this.project(value, index);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            this.hasSubscription = true;
            this._innerSub(result, value, index);
          };
          ExhaustMapSubscriber.prototype._innerSub = function (
            result,
            value,
            index
          ) {
            var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(
              this,
              value,
              index
            );
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = subscribeToResult_1.subscribeToResult(
              this,
              result,
              undefined,
              undefined,
              innerSubscriber
            );
            if (innerSubscription !== innerSubscriber) {
              destination.add(innerSubscription);
            }
          };
          ExhaustMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (!this.hasSubscription) {
              this.destination.complete();
            }
            this.unsubscribe();
          };
          ExhaustMapSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.destination.next(innerValue);
          };
          ExhaustMapSubscriber.prototype.notifyError = function (err) {
            this.destination.error(err);
          };
          ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
            var destination = this.destination;
            destination.remove(innerSub);
            this.hasSubscription = false;
            if (this.hasCompleted) {
              this.destination.complete();
            }
          };
          return ExhaustMapSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../InnerSubscriber": 337,
        "../OuterSubscriber": 341,
        "../observable/from": 362,
        "../util/subscribeToResult": 544,
        "./map": 422,
      },
    ],
    412: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function expand(project, concurrent, scheduler) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          if (scheduler === void 0) {
            scheduler = undefined;
          }
          concurrent =
            (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
          return function (source) {
            return source.lift(
              new ExpandOperator(project, concurrent, scheduler)
            );
          };
        }
        exports.expand = expand;
        var ExpandOperator = (function () {
          function ExpandOperator(project, concurrent, scheduler) {
            this.project = project;
            this.concurrent = concurrent;
            this.scheduler = scheduler;
          }
          ExpandOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new ExpandSubscriber(
                subscriber,
                this.project,
                this.concurrent,
                this.scheduler
              )
            );
          };
          return ExpandOperator;
        })();
        exports.ExpandOperator = ExpandOperator;
        var ExpandSubscriber = (function (_super) {
          __extends(ExpandSubscriber, _super);
          function ExpandSubscriber(
            destination,
            project,
            concurrent,
            scheduler
          ) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.concurrent = concurrent;
            _this.scheduler = scheduler;
            _this.index = 0;
            _this.active = 0;
            _this.hasCompleted = false;
            if (concurrent < Number.POSITIVE_INFINITY) {
              _this.buffer = [];
            }
            return _this;
          }
          ExpandSubscriber.dispatch = function (arg) {
            var subscriber = arg.subscriber,
              result = arg.result,
              value = arg.value,
              index = arg.index;
            subscriber.subscribeToProjection(result, value, index);
          };
          ExpandSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            if (destination.closed) {
              this._complete();
              return;
            }
            var index = this.index++;
            if (this.active < this.concurrent) {
              destination.next(value);
              try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                  this.subscribeToProjection(result, value, index);
                } else {
                  var state = {
                    subscriber: this,
                    result: result,
                    value: value,
                    index: index,
                  };
                  var destination_1 = this.destination;
                  destination_1.add(
                    this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state)
                  );
                }
              } catch (e) {
                destination.error(e);
              }
            } else {
              this.buffer.push(value);
            }
          };
          ExpandSubscriber.prototype.subscribeToProjection = function (
            result,
            value,
            index
          ) {
            this.active++;
            var destination = this.destination;
            destination.add(
              subscribeToResult_1.subscribeToResult(this, result, value, index)
            );
          };
          ExpandSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.hasCompleted && this.active === 0) {
              this.destination.complete();
            }
            this.unsubscribe();
          };
          ExpandSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this._next(innerValue);
          };
          ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            var destination = this.destination;
            destination.remove(innerSub);
            this.active--;
            if (buffer && buffer.length > 0) {
              this._next(buffer.shift());
            }
            if (this.hasCompleted && this.active === 0) {
              this.destination.complete();
            }
          };
          return ExpandSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
        exports.ExpandSubscriber = ExpandSubscriber;
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    413: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function filter(predicate, thisArg) {
          return function filterOperatorFunction(source) {
            return source.lift(new FilterOperator(predicate, thisArg));
          };
        }
        exports.filter = filter;
        var FilterOperator = (function () {
          function FilterOperator(predicate, thisArg) {
            this.predicate = predicate;
            this.thisArg = thisArg;
          }
          FilterOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new FilterSubscriber(subscriber, this.predicate, this.thisArg)
            );
          };
          return FilterOperator;
        })();
        var FilterSubscriber = (function (_super) {
          __extends(FilterSubscriber, _super);
          function FilterSubscriber(destination, predicate, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.thisArg = thisArg;
            _this.count = 0;
            return _this;
          }
          FilterSubscriber.prototype._next = function (value) {
            var result;
            try {
              result = this.predicate.call(this.thisArg, value, this.count++);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            if (result) {
              this.destination.next(value);
            }
          };
          return FilterSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    414: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var Subscription_1 = require("../Subscription");
        function finalize(callback) {
          return function (source) {
            return source.lift(new FinallyOperator(callback));
          };
        }
        exports.finalize = finalize;
        var FinallyOperator = (function () {
          function FinallyOperator(callback) {
            this.callback = callback;
          }
          FinallyOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new FinallySubscriber(subscriber, this.callback)
            );
          };
          return FinallyOperator;
        })();
        var FinallySubscriber = (function (_super) {
          __extends(FinallySubscriber, _super);
          function FinallySubscriber(destination, callback) {
            var _this = _super.call(this, destination) || this;
            _this.add(new Subscription_1.Subscription(callback));
            return _this;
          }
          return FinallySubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346, "../Subscription": 347 },
    ],
    415: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function find(predicate, thisArg) {
          if (typeof predicate !== "function") {
            throw new TypeError("predicate is not a function");
          }
          return function (source) {
            return source.lift(
              new FindValueOperator(predicate, source, false, thisArg)
            );
          };
        }
        exports.find = find;
        var FindValueOperator = (function () {
          function FindValueOperator(predicate, source, yieldIndex, thisArg) {
            this.predicate = predicate;
            this.source = source;
            this.yieldIndex = yieldIndex;
            this.thisArg = thisArg;
          }
          FindValueOperator.prototype.call = function (observer, source) {
            return source.subscribe(
              new FindValueSubscriber(
                observer,
                this.predicate,
                this.source,
                this.yieldIndex,
                this.thisArg
              )
            );
          };
          return FindValueOperator;
        })();
        exports.FindValueOperator = FindValueOperator;
        var FindValueSubscriber = (function (_super) {
          __extends(FindValueSubscriber, _super);
          function FindValueSubscriber(
            destination,
            predicate,
            source,
            yieldIndex,
            thisArg
          ) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.source = source;
            _this.yieldIndex = yieldIndex;
            _this.thisArg = thisArg;
            _this.index = 0;
            return _this;
          }
          FindValueSubscriber.prototype.notifyComplete = function (value) {
            var destination = this.destination;
            destination.next(value);
            destination.complete();
            this.unsubscribe();
          };
          FindValueSubscriber.prototype._next = function (value) {
            var _a = this,
              predicate = _a.predicate,
              thisArg = _a.thisArg;
            var index = this.index++;
            try {
              var result = predicate.call(
                thisArg || this,
                value,
                index,
                this.source
              );
              if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
              }
            } catch (err) {
              this.destination.error(err);
            }
          };
          FindValueSubscriber.prototype._complete = function () {
            this.notifyComplete(this.yieldIndex ? -1 : undefined);
          };
          return FindValueSubscriber;
        })(Subscriber_1.Subscriber);
        exports.FindValueSubscriber = FindValueSubscriber;
      },
      { "../Subscriber": 346 },
    ],
    416: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var find_1 = require("../operators/find");
        function findIndex(predicate, thisArg) {
          return function (source) {
            return source.lift(
              new find_1.FindValueOperator(predicate, source, true, thisArg)
            );
          };
        }
        exports.findIndex = findIndex;
      },
      { "../operators/find": 415 },
    ],
    417: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var EmptyError_1 = require("../util/EmptyError");
        var filter_1 = require("./filter");
        var take_1 = require("./take");
        var defaultIfEmpty_1 = require("./defaultIfEmpty");
        var throwIfEmpty_1 = require("./throwIfEmpty");
        var identity_1 = require("../util/identity");
        function first(predicate, defaultValue) {
          var hasDefaultValue = arguments.length >= 2;
          return function (source) {
            return source.pipe(
              predicate
                ? filter_1.filter(function (v, i) {
                    return predicate(v, i, source);
                  })
                : identity_1.identity,
              take_1.take(1),
              hasDefaultValue
                ? defaultIfEmpty_1.defaultIfEmpty(defaultValue)
                : throwIfEmpty_1.throwIfEmpty(function () {
                    return new EmptyError_1.EmptyError();
                  })
            );
          };
        }
        exports.first = first;
      },
      {
        "../util/EmptyError": 514,
        "../util/identity": 523,
        "./defaultIfEmpty": 400,
        "./filter": 413,
        "./take": 465,
        "./throwIfEmpty": 472,
      },
    ],
    418: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var Subscription_1 = require("../Subscription");
        var Observable_1 = require("../Observable");
        var Subject_1 = require("../Subject");
        function groupBy(
          keySelector,
          elementSelector,
          durationSelector,
          subjectSelector
        ) {
          return function (source) {
            return source.lift(
              new GroupByOperator(
                keySelector,
                elementSelector,
                durationSelector,
                subjectSelector
              )
            );
          };
        }
        exports.groupBy = groupBy;
        var GroupByOperator = (function () {
          function GroupByOperator(
            keySelector,
            elementSelector,
            durationSelector,
            subjectSelector
          ) {
            this.keySelector = keySelector;
            this.elementSelector = elementSelector;
            this.durationSelector = durationSelector;
            this.subjectSelector = subjectSelector;
          }
          GroupByOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new GroupBySubscriber(
                subscriber,
                this.keySelector,
                this.elementSelector,
                this.durationSelector,
                this.subjectSelector
              )
            );
          };
          return GroupByOperator;
        })();
        var GroupBySubscriber = (function (_super) {
          __extends(GroupBySubscriber, _super);
          function GroupBySubscriber(
            destination,
            keySelector,
            elementSelector,
            durationSelector,
            subjectSelector
          ) {
            var _this = _super.call(this, destination) || this;
            _this.keySelector = keySelector;
            _this.elementSelector = elementSelector;
            _this.durationSelector = durationSelector;
            _this.subjectSelector = subjectSelector;
            _this.groups = null;
            _this.attemptedToUnsubscribe = false;
            _this.count = 0;
            return _this;
          }
          GroupBySubscriber.prototype._next = function (value) {
            var key;
            try {
              key = this.keySelector(value);
            } catch (err) {
              this.error(err);
              return;
            }
            this._group(value, key);
          };
          GroupBySubscriber.prototype._group = function (value, key) {
            var groups = this.groups;
            if (!groups) {
              groups = this.groups = new Map();
            }
            var group = groups.get(key);
            var element;
            if (this.elementSelector) {
              try {
                element = this.elementSelector(value);
              } catch (err) {
                this.error(err);
              }
            } else {
              element = value;
            }
            if (!group) {
              group = this.subjectSelector
                ? this.subjectSelector()
                : new Subject_1.Subject();
              groups.set(key, group);
              var groupedObservable = new GroupedObservable(key, group, this);
              this.destination.next(groupedObservable);
              if (this.durationSelector) {
                var duration = void 0;
                try {
                  duration = this.durationSelector(
                    new GroupedObservable(key, group)
                  );
                } catch (err) {
                  this.error(err);
                  return;
                }
                this.add(
                  duration.subscribe(
                    new GroupDurationSubscriber(key, group, this)
                  )
                );
              }
            }
            if (!group.closed) {
              group.next(element);
            }
          };
          GroupBySubscriber.prototype._error = function (err) {
            var groups = this.groups;
            if (groups) {
              groups.forEach(function (group, key) {
                group.error(err);
              });
              groups.clear();
            }
            this.destination.error(err);
          };
          GroupBySubscriber.prototype._complete = function () {
            var groups = this.groups;
            if (groups) {
              groups.forEach(function (group, key) {
                group.complete();
              });
              groups.clear();
            }
            this.destination.complete();
          };
          GroupBySubscriber.prototype.removeGroup = function (key) {
            this.groups.delete(key);
          };
          GroupBySubscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
              this.attemptedToUnsubscribe = true;
              if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
              }
            }
          };
          return GroupBySubscriber;
        })(Subscriber_1.Subscriber);
        var GroupDurationSubscriber = (function (_super) {
          __extends(GroupDurationSubscriber, _super);
          function GroupDurationSubscriber(key, group, parent) {
            var _this = _super.call(this, group) || this;
            _this.key = key;
            _this.group = group;
            _this.parent = parent;
            return _this;
          }
          GroupDurationSubscriber.prototype._next = function (value) {
            this.complete();
          };
          GroupDurationSubscriber.prototype._unsubscribe = function () {
            var _a = this,
              parent = _a.parent,
              key = _a.key;
            this.key = this.parent = null;
            if (parent) {
              parent.removeGroup(key);
            }
          };
          return GroupDurationSubscriber;
        })(Subscriber_1.Subscriber);
        var GroupedObservable = (function (_super) {
          __extends(GroupedObservable, _super);
          function GroupedObservable(key, groupSubject, refCountSubscription) {
            var _this = _super.call(this) || this;
            _this.key = key;
            _this.groupSubject = groupSubject;
            _this.refCountSubscription = refCountSubscription;
            return _this;
          }
          GroupedObservable.prototype._subscribe = function (subscriber) {
            var subscription = new Subscription_1.Subscription();
            var _a = this,
              refCountSubscription = _a.refCountSubscription,
              groupSubject = _a.groupSubject;
            if (refCountSubscription && !refCountSubscription.closed) {
              subscription.add(
                new InnerRefCountSubscription(refCountSubscription)
              );
            }
            subscription.add(groupSubject.subscribe(subscriber));
            return subscription;
          };
          return GroupedObservable;
        })(Observable_1.Observable);
        exports.GroupedObservable = GroupedObservable;
        var InnerRefCountSubscription = (function (_super) {
          __extends(InnerRefCountSubscription, _super);
          function InnerRefCountSubscription(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            parent.count++;
            return _this;
          }
          InnerRefCountSubscription.prototype.unsubscribe = function () {
            var parent = this.parent;
            if (!parent.closed && !this.closed) {
              _super.prototype.unsubscribe.call(this);
              parent.count -= 1;
              if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
              }
            }
          };
          return InnerRefCountSubscription;
        })(Subscription_1.Subscription);
      },
      {
        "../Observable": 339,
        "../Subject": 344,
        "../Subscriber": 346,
        "../Subscription": 347,
      },
    ],
    419: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function ignoreElements() {
          return function ignoreElementsOperatorFunction(source) {
            return source.lift(new IgnoreElementsOperator());
          };
        }
        exports.ignoreElements = ignoreElements;
        var IgnoreElementsOperator = (function () {
          function IgnoreElementsOperator() {}
          IgnoreElementsOperator.prototype.call = function (
            subscriber,
            source
          ) {
            return source.subscribe(new IgnoreElementsSubscriber(subscriber));
          };
          return IgnoreElementsOperator;
        })();
        var IgnoreElementsSubscriber = (function (_super) {
          __extends(IgnoreElementsSubscriber, _super);
          function IgnoreElementsSubscriber() {
            return (_super !== null && _super.apply(this, arguments)) || this;
          }
          IgnoreElementsSubscriber.prototype._next = function (unused) {};
          return IgnoreElementsSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    420: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function isEmpty() {
          return function (source) {
            return source.lift(new IsEmptyOperator());
          };
        }
        exports.isEmpty = isEmpty;
        var IsEmptyOperator = (function () {
          function IsEmptyOperator() {}
          IsEmptyOperator.prototype.call = function (observer, source) {
            return source.subscribe(new IsEmptySubscriber(observer));
          };
          return IsEmptyOperator;
        })();
        var IsEmptySubscriber = (function (_super) {
          __extends(IsEmptySubscriber, _super);
          function IsEmptySubscriber(destination) {
            return _super.call(this, destination) || this;
          }
          IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
            var destination = this.destination;
            destination.next(isEmpty);
            destination.complete();
          };
          IsEmptySubscriber.prototype._next = function (value) {
            this.notifyComplete(false);
          };
          IsEmptySubscriber.prototype._complete = function () {
            this.notifyComplete(true);
          };
          return IsEmptySubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    421: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var EmptyError_1 = require("../util/EmptyError");
        var filter_1 = require("./filter");
        var takeLast_1 = require("./takeLast");
        var throwIfEmpty_1 = require("./throwIfEmpty");
        var defaultIfEmpty_1 = require("./defaultIfEmpty");
        var identity_1 = require("../util/identity");
        function last(predicate, defaultValue) {
          var hasDefaultValue = arguments.length >= 2;
          return function (source) {
            return source.pipe(
              predicate
                ? filter_1.filter(function (v, i) {
                    return predicate(v, i, source);
                  })
                : identity_1.identity,
              takeLast_1.takeLast(1),
              hasDefaultValue
                ? defaultIfEmpty_1.defaultIfEmpty(defaultValue)
                : throwIfEmpty_1.throwIfEmpty(function () {
                    return new EmptyError_1.EmptyError();
                  })
            );
          };
        }
        exports.last = last;
      },
      {
        "../util/EmptyError": 514,
        "../util/identity": 523,
        "./defaultIfEmpty": 400,
        "./filter": 413,
        "./takeLast": 466,
        "./throwIfEmpty": 472,
      },
    ],
    422: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function map(project, thisArg) {
          return function mapOperation(source) {
            if (typeof project !== "function") {
              throw new TypeError(
                "argument is not a function. Are you looking for `mapTo()`?"
              );
            }
            return source.lift(new MapOperator(project, thisArg));
          };
        }
        exports.map = map;
        var MapOperator = (function () {
          function MapOperator(project, thisArg) {
            this.project = project;
            this.thisArg = thisArg;
          }
          MapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new MapSubscriber(subscriber, this.project, this.thisArg)
            );
          };
          return MapOperator;
        })();
        exports.MapOperator = MapOperator;
        var MapSubscriber = (function (_super) {
          __extends(MapSubscriber, _super);
          function MapSubscriber(destination, project, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.count = 0;
            _this.thisArg = thisArg || _this;
            return _this;
          }
          MapSubscriber.prototype._next = function (value) {
            var result;
            try {
              result = this.project.call(this.thisArg, value, this.count++);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            this.destination.next(result);
          };
          return MapSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    423: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function mapTo(value) {
          return function (source) {
            return source.lift(new MapToOperator(value));
          };
        }
        exports.mapTo = mapTo;
        var MapToOperator = (function () {
          function MapToOperator(value) {
            this.value = value;
          }
          MapToOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new MapToSubscriber(subscriber, this.value)
            );
          };
          return MapToOperator;
        })();
        var MapToSubscriber = (function (_super) {
          __extends(MapToSubscriber, _super);
          function MapToSubscriber(destination, value) {
            var _this = _super.call(this, destination) || this;
            _this.value = value;
            return _this;
          }
          MapToSubscriber.prototype._next = function (x) {
            this.destination.next(this.value);
          };
          return MapToSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    424: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var Notification_1 = require("../Notification");
        function materialize() {
          return function materializeOperatorFunction(source) {
            return source.lift(new MaterializeOperator());
          };
        }
        exports.materialize = materialize;
        var MaterializeOperator = (function () {
          function MaterializeOperator() {}
          MaterializeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MaterializeSubscriber(subscriber));
          };
          return MaterializeOperator;
        })();
        var MaterializeSubscriber = (function (_super) {
          __extends(MaterializeSubscriber, _super);
          function MaterializeSubscriber(destination) {
            return _super.call(this, destination) || this;
          }
          MaterializeSubscriber.prototype._next = function (value) {
            this.destination.next(
              Notification_1.Notification.createNext(value)
            );
          };
          MaterializeSubscriber.prototype._error = function (err) {
            var destination = this.destination;
            destination.next(Notification_1.Notification.createError(err));
            destination.complete();
          };
          MaterializeSubscriber.prototype._complete = function () {
            var destination = this.destination;
            destination.next(Notification_1.Notification.createComplete());
            destination.complete();
          };
          return MaterializeSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Notification": 338, "../Subscriber": 346 },
    ],
    425: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var reduce_1 = require("./reduce");
        function max(comparer) {
          var max =
            typeof comparer === "function"
              ? function (x, y) {
                  return comparer(x, y) > 0 ? x : y;
                }
              : function (x, y) {
                  return x > y ? x : y;
                };
          return reduce_1.reduce(max);
        }
        exports.max = max;
      },
      { "./reduce": 443 },
    ],
    426: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var merge_1 = require("../observable/merge");
        function merge() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return function (source) {
            return source.lift.call(
              merge_1.merge.apply(void 0, [source].concat(observables))
            );
          };
        }
        exports.merge = merge;
      },
      { "../observable/merge": 371 },
    ],
    427: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var mergeMap_1 = require("./mergeMap");
        var identity_1 = require("../util/identity");
        function mergeAll(concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          return mergeMap_1.mergeMap(identity_1.identity, concurrent);
        }
        exports.mergeAll = mergeAll;
      },
      { "../util/identity": 523, "./mergeMap": 428 },
    ],
    428: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var InnerSubscriber_1 = require("../InnerSubscriber");
        var map_1 = require("./map");
        var from_1 = require("../observable/from");
        function mergeMap(project, resultSelector, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          if (typeof resultSelector === "function") {
            return function (source) {
              return source.pipe(
                mergeMap(function (a, i) {
                  return from_1.from(project(a, i)).pipe(
                    map_1.map(function (b, ii) {
                      return resultSelector(a, b, i, ii);
                    })
                  );
                }, concurrent)
              );
            };
          } else if (typeof resultSelector === "number") {
            concurrent = resultSelector;
          }
          return function (source) {
            return source.lift(new MergeMapOperator(project, concurrent));
          };
        }
        exports.mergeMap = mergeMap;
        var MergeMapOperator = (function () {
          function MergeMapOperator(project, concurrent) {
            if (concurrent === void 0) {
              concurrent = Number.POSITIVE_INFINITY;
            }
            this.project = project;
            this.concurrent = concurrent;
          }
          MergeMapOperator.prototype.call = function (observer, source) {
            return source.subscribe(
              new MergeMapSubscriber(observer, this.project, this.concurrent)
            );
          };
          return MergeMapOperator;
        })();
        exports.MergeMapOperator = MergeMapOperator;
        var MergeMapSubscriber = (function (_super) {
          __extends(MergeMapSubscriber, _super);
          function MergeMapSubscriber(destination, project, concurrent) {
            if (concurrent === void 0) {
              concurrent = Number.POSITIVE_INFINITY;
            }
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.concurrent = concurrent;
            _this.hasCompleted = false;
            _this.buffer = [];
            _this.active = 0;
            _this.index = 0;
            return _this;
          }
          MergeMapSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
              this._tryNext(value);
            } else {
              this.buffer.push(value);
            }
          };
          MergeMapSubscriber.prototype._tryNext = function (value) {
            var result;
            var index = this.index++;
            try {
              result = this.project(value, index);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            this.active++;
            this._innerSub(result, value, index);
          };
          MergeMapSubscriber.prototype._innerSub = function (
            ish,
            value,
            index
          ) {
            var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(
              this,
              value,
              index
            );
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = subscribeToResult_1.subscribeToResult(
              this,
              ish,
              undefined,
              undefined,
              innerSubscriber
            );
            if (innerSubscription !== innerSubscriber) {
              destination.add(innerSubscription);
            }
          };
          MergeMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
              this.destination.complete();
            }
            this.unsubscribe();
          };
          MergeMapSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.destination.next(innerValue);
          };
          MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            this.remove(innerSub);
            this.active--;
            if (buffer.length > 0) {
              this._next(buffer.shift());
            } else if (this.active === 0 && this.hasCompleted) {
              this.destination.complete();
            }
          };
          return MergeMapSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
        exports.MergeMapSubscriber = MergeMapSubscriber;
      },
      {
        "../InnerSubscriber": 337,
        "../OuterSubscriber": 341,
        "../observable/from": 362,
        "../util/subscribeToResult": 544,
        "./map": 422,
      },
    ],
    429: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var mergeMap_1 = require("./mergeMap");
        function mergeMapTo(innerObservable, resultSelector, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          if (typeof resultSelector === "function") {
            return mergeMap_1.mergeMap(
              function () {
                return innerObservable;
              },
              resultSelector,
              concurrent
            );
          }
          if (typeof resultSelector === "number") {
            concurrent = resultSelector;
          }
          return mergeMap_1.mergeMap(function () {
            return innerObservable;
          }, concurrent);
        }
        exports.mergeMapTo = mergeMapTo;
      },
      { "./mergeMap": 428 },
    ],
    430: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var InnerSubscriber_1 = require("../InnerSubscriber");
        function mergeScan(accumulator, seed, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }
          return function (source) {
            return source.lift(
              new MergeScanOperator(accumulator, seed, concurrent)
            );
          };
        }
        exports.mergeScan = mergeScan;
        var MergeScanOperator = (function () {
          function MergeScanOperator(accumulator, seed, concurrent) {
            this.accumulator = accumulator;
            this.seed = seed;
            this.concurrent = concurrent;
          }
          MergeScanOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new MergeScanSubscriber(
                subscriber,
                this.accumulator,
                this.seed,
                this.concurrent
              )
            );
          };
          return MergeScanOperator;
        })();
        exports.MergeScanOperator = MergeScanOperator;
        var MergeScanSubscriber = (function (_super) {
          __extends(MergeScanSubscriber, _super);
          function MergeScanSubscriber(
            destination,
            accumulator,
            acc,
            concurrent
          ) {
            var _this = _super.call(this, destination) || this;
            _this.accumulator = accumulator;
            _this.acc = acc;
            _this.concurrent = concurrent;
            _this.hasValue = false;
            _this.hasCompleted = false;
            _this.buffer = [];
            _this.active = 0;
            _this.index = 0;
            return _this;
          }
          MergeScanSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
              var index = this.index++;
              var destination = this.destination;
              var ish = void 0;
              try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
              } catch (e) {
                return destination.error(e);
              }
              this.active++;
              this._innerSub(ish, value, index);
            } else {
              this.buffer.push(value);
            }
          };
          MergeScanSubscriber.prototype._innerSub = function (
            ish,
            value,
            index
          ) {
            var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(
              this,
              value,
              index
            );
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = subscribeToResult_1.subscribeToResult(
              this,
              ish,
              undefined,
              undefined,
              innerSubscriber
            );
            if (innerSubscription !== innerSubscriber) {
              destination.add(innerSubscription);
            }
          };
          MergeScanSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
              if (this.hasValue === false) {
                this.destination.next(this.acc);
              }
              this.destination.complete();
            }
            this.unsubscribe();
          };
          MergeScanSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            var destination = this.destination;
            this.acc = innerValue;
            this.hasValue = true;
            destination.next(innerValue);
          };
          MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            var destination = this.destination;
            destination.remove(innerSub);
            this.active--;
            if (buffer.length > 0) {
              this._next(buffer.shift());
            } else if (this.active === 0 && this.hasCompleted) {
              if (this.hasValue === false) {
                this.destination.next(this.acc);
              }
              this.destination.complete();
            }
          };
          return MergeScanSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
        exports.MergeScanSubscriber = MergeScanSubscriber;
      },
      {
        "../InnerSubscriber": 337,
        "../OuterSubscriber": 341,
        "../util/subscribeToResult": 544,
      },
    ],
    431: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var reduce_1 = require("./reduce");
        function min(comparer) {
          var min =
            typeof comparer === "function"
              ? function (x, y) {
                  return comparer(x, y) < 0 ? x : y;
                }
              : function (x, y) {
                  return x < y ? x : y;
                };
          return reduce_1.reduce(min);
        }
        exports.min = min;
      },
      { "./reduce": 443 },
    ],
    432: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ConnectableObservable_1 = require("../observable/ConnectableObservable");
        function multicast(subjectOrSubjectFactory, selector) {
          return function multicastOperatorFunction(source) {
            var subjectFactory;
            if (typeof subjectOrSubjectFactory === "function") {
              subjectFactory = subjectOrSubjectFactory;
            } else {
              subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
              };
            }
            if (typeof selector === "function") {
              return source.lift(
                new MulticastOperator(subjectFactory, selector)
              );
            }
            var connectable = Object.create(
              source,
              ConnectableObservable_1.connectableObservableDescriptor
            );
            connectable.source = source;
            connectable.subjectFactory = subjectFactory;
            return connectable;
          };
        }
        exports.multicast = multicast;
        var MulticastOperator = (function () {
          function MulticastOperator(subjectFactory, selector) {
            this.subjectFactory = subjectFactory;
            this.selector = selector;
          }
          MulticastOperator.prototype.call = function (subscriber, source) {
            var selector = this.selector;
            var subject = this.subjectFactory();
            var subscription = selector(subject).subscribe(subscriber);
            subscription.add(source.subscribe(subject));
            return subscription;
          };
          return MulticastOperator;
        })();
        exports.MulticastOperator = MulticastOperator;
      },
      { "../observable/ConnectableObservable": 349 },
    ],
    433: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var Notification_1 = require("../Notification");
        function observeOn(scheduler, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return function observeOnOperatorFunction(source) {
            return source.lift(new ObserveOnOperator(scheduler, delay));
          };
        }
        exports.observeOn = observeOn;
        var ObserveOnOperator = (function () {
          function ObserveOnOperator(scheduler, delay) {
            if (delay === void 0) {
              delay = 0;
            }
            this.scheduler = scheduler;
            this.delay = delay;
          }
          ObserveOnOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new ObserveOnSubscriber(subscriber, this.scheduler, this.delay)
            );
          };
          return ObserveOnOperator;
        })();
        exports.ObserveOnOperator = ObserveOnOperator;
        var ObserveOnSubscriber = (function (_super) {
          __extends(ObserveOnSubscriber, _super);
          function ObserveOnSubscriber(destination, scheduler, delay) {
            if (delay === void 0) {
              delay = 0;
            }
            var _this = _super.call(this, destination) || this;
            _this.scheduler = scheduler;
            _this.delay = delay;
            return _this;
          }
          ObserveOnSubscriber.dispatch = function (arg) {
            var notification = arg.notification,
              destination = arg.destination;
            notification.observe(destination);
            this.unsubscribe();
          };
          ObserveOnSubscriber.prototype.scheduleMessage = function (
            notification
          ) {
            var destination = this.destination;
            destination.add(
              this.scheduler.schedule(
                ObserveOnSubscriber.dispatch,
                this.delay,
                new ObserveOnMessage(notification, this.destination)
              )
            );
          };
          ObserveOnSubscriber.prototype._next = function (value) {
            this.scheduleMessage(Notification_1.Notification.createNext(value));
          };
          ObserveOnSubscriber.prototype._error = function (err) {
            this.scheduleMessage(Notification_1.Notification.createError(err));
            this.unsubscribe();
          };
          ObserveOnSubscriber.prototype._complete = function () {
            this.scheduleMessage(Notification_1.Notification.createComplete());
            this.unsubscribe();
          };
          return ObserveOnSubscriber;
        })(Subscriber_1.Subscriber);
        exports.ObserveOnSubscriber = ObserveOnSubscriber;
        var ObserveOnMessage = (function () {
          function ObserveOnMessage(notification, destination) {
            this.notification = notification;
            this.destination = destination;
          }
          return ObserveOnMessage;
        })();
        exports.ObserveOnMessage = ObserveOnMessage;
      },
      { "../Notification": 338, "../Subscriber": 346 },
    ],
    434: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var from_1 = require("../observable/from");
        var isArray_1 = require("../util/isArray");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var InnerSubscriber_1 = require("../InnerSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function onErrorResumeNext() {
          var nextSources = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            nextSources[_i] = arguments[_i];
          }
          if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
            nextSources = nextSources[0];
          }
          return function (source) {
            return source.lift(new OnErrorResumeNextOperator(nextSources));
          };
        }
        exports.onErrorResumeNext = onErrorResumeNext;
        function onErrorResumeNextStatic() {
          var nextSources = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            nextSources[_i] = arguments[_i];
          }
          var source = null;
          if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
            nextSources = nextSources[0];
          }
          source = nextSources.shift();
          return from_1
            .from(source, null)
            .lift(new OnErrorResumeNextOperator(nextSources));
        }
        exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
        var OnErrorResumeNextOperator = (function () {
          function OnErrorResumeNextOperator(nextSources) {
            this.nextSources = nextSources;
          }
          OnErrorResumeNextOperator.prototype.call = function (
            subscriber,
            source
          ) {
            return source.subscribe(
              new OnErrorResumeNextSubscriber(subscriber, this.nextSources)
            );
          };
          return OnErrorResumeNextOperator;
        })();
        var OnErrorResumeNextSubscriber = (function (_super) {
          __extends(OnErrorResumeNextSubscriber, _super);
          function OnErrorResumeNextSubscriber(destination, nextSources) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.nextSources = nextSources;
            return _this;
          }
          OnErrorResumeNextSubscriber.prototype.notifyError = function (
            error,
            innerSub
          ) {
            this.subscribeToNextSource();
          };
          OnErrorResumeNextSubscriber.prototype.notifyComplete = function (
            innerSub
          ) {
            this.subscribeToNextSource();
          };
          OnErrorResumeNextSubscriber.prototype._error = function (err) {
            this.subscribeToNextSource();
            this.unsubscribe();
          };
          OnErrorResumeNextSubscriber.prototype._complete = function () {
            this.subscribeToNextSource();
            this.unsubscribe();
          };
          OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
            var next = this.nextSources.shift();
            if (!!next) {
              var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(
                this,
                undefined,
                undefined
              );
              var destination = this.destination;
              destination.add(innerSubscriber);
              var innerSubscription = subscribeToResult_1.subscribeToResult(
                this,
                next,
                undefined,
                undefined,
                innerSubscriber
              );
              if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
              }
            } else {
              this.destination.complete();
            }
          };
          return OnErrorResumeNextSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../InnerSubscriber": 337,
        "../OuterSubscriber": 341,
        "../observable/from": 362,
        "../util/isArray": 524,
        "../util/subscribeToResult": 544,
      },
    ],
    435: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function pairwise() {
          return function (source) {
            return source.lift(new PairwiseOperator());
          };
        }
        exports.pairwise = pairwise;
        var PairwiseOperator = (function () {
          function PairwiseOperator() {}
          PairwiseOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new PairwiseSubscriber(subscriber));
          };
          return PairwiseOperator;
        })();
        var PairwiseSubscriber = (function (_super) {
          __extends(PairwiseSubscriber, _super);
          function PairwiseSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.hasPrev = false;
            return _this;
          }
          PairwiseSubscriber.prototype._next = function (value) {
            var pair;
            if (this.hasPrev) {
              pair = [this.prev, value];
            } else {
              this.hasPrev = true;
            }
            this.prev = value;
            if (pair) {
              this.destination.next(pair);
            }
          };
          return PairwiseSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    436: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var not_1 = require("../util/not");
        var filter_1 = require("./filter");
        function partition(predicate, thisArg) {
          return function (source) {
            return [
              filter_1.filter(predicate, thisArg)(source),
              filter_1.filter(not_1.not(predicate, thisArg))(source),
            ];
          };
        }
        exports.partition = partition;
      },
      { "../util/not": 536, "./filter": 413 },
    ],
    437: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var map_1 = require("./map");
        function pluck() {
          var properties = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
          }
          var length = properties.length;
          if (length === 0) {
            throw new Error("list of properties cannot be empty.");
          }
          return function (source) {
            return map_1.map(plucker(properties, length))(source);
          };
        }
        exports.pluck = pluck;
        function plucker(props, length) {
          var mapper = function (x) {
            var currentProp = x;
            for (var i = 0; i < length; i++) {
              var p = currentProp[props[i]];
              if (typeof p !== "undefined") {
                currentProp = p;
              } else {
                return undefined;
              }
            }
            return currentProp;
          };
          return mapper;
        }
      },
      { "./map": 422 },
    ],
    438: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var multicast_1 = require("./multicast");
        function publish(selector) {
          return selector
            ? multicast_1.multicast(function () {
                return new Subject_1.Subject();
              }, selector)
            : multicast_1.multicast(new Subject_1.Subject());
        }
        exports.publish = publish;
      },
      { "../Subject": 344, "./multicast": 432 },
    ],
    439: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var BehaviorSubject_1 = require("../BehaviorSubject");
        var multicast_1 = require("./multicast");
        function publishBehavior(value) {
          return function (source) {
            return multicast_1.multicast(
              new BehaviorSubject_1.BehaviorSubject(value)
            )(source);
          };
        }
        exports.publishBehavior = publishBehavior;
      },
      { "../BehaviorSubject": 336, "./multicast": 432 },
    ],
    440: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncSubject_1 = require("../AsyncSubject");
        var multicast_1 = require("./multicast");
        function publishLast() {
          return function (source) {
            return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(
              source
            );
          };
        }
        exports.publishLast = publishLast;
      },
      { "../AsyncSubject": 335, "./multicast": 432 },
    ],
    441: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ReplaySubject_1 = require("../ReplaySubject");
        var multicast_1 = require("./multicast");
        function publishReplay(
          bufferSize,
          windowTime,
          selectorOrScheduler,
          scheduler
        ) {
          if (
            selectorOrScheduler &&
            typeof selectorOrScheduler !== "function"
          ) {
            scheduler = selectorOrScheduler;
          }
          var selector =
            typeof selectorOrScheduler === "function"
              ? selectorOrScheduler
              : undefined;
          var subject = new ReplaySubject_1.ReplaySubject(
            bufferSize,
            windowTime,
            scheduler
          );
          return function (source) {
            return multicast_1.multicast(function () {
              return subject;
            }, selector)(source);
          };
        }
        exports.publishReplay = publishReplay;
      },
      { "../ReplaySubject": 342, "./multicast": 432 },
    ],
    442: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isArray_1 = require("../util/isArray");
        var race_1 = require("../observable/race");
        function race() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return function raceOperatorFunction(source) {
            if (observables.length === 1 && isArray_1.isArray(observables[0])) {
              observables = observables[0];
            }
            return source.lift.call(
              race_1.race.apply(void 0, [source].concat(observables))
            );
          };
        }
        exports.race = race;
      },
      { "../observable/race": 377, "../util/isArray": 524 },
    ],
    443: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var scan_1 = require("./scan");
        var takeLast_1 = require("./takeLast");
        var defaultIfEmpty_1 = require("./defaultIfEmpty");
        var pipe_1 = require("../util/pipe");
        function reduce(accumulator, seed) {
          if (arguments.length >= 2) {
            return function reduceOperatorFunctionWithSeed(source) {
              return pipe_1.pipe(
                scan_1.scan(accumulator, seed),
                takeLast_1.takeLast(1),
                defaultIfEmpty_1.defaultIfEmpty(seed)
              )(source);
            };
          }
          return function reduceOperatorFunction(source) {
            return pipe_1.pipe(
              scan_1.scan(function (acc, value, index) {
                return accumulator(acc, value, index + 1);
              }),
              takeLast_1.takeLast(1)
            )(source);
          };
        }
        exports.reduce = reduce;
      },
      {
        "../util/pipe": 537,
        "./defaultIfEmpty": 400,
        "./scan": 451,
        "./takeLast": 466,
      },
    ],
    444: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function refCount() {
          return function refCountOperatorFunction(source) {
            return source.lift(new RefCountOperator(source));
          };
        }
        exports.refCount = refCount;
        var RefCountOperator = (function () {
          function RefCountOperator(connectable) {
            this.connectable = connectable;
          }
          RefCountOperator.prototype.call = function (subscriber, source) {
            var connectable = this.connectable;
            connectable._refCount++;
            var refCounter = new RefCountSubscriber(subscriber, connectable);
            var subscription = source.subscribe(refCounter);
            if (!refCounter.closed) {
              refCounter.connection = connectable.connect();
            }
            return subscription;
          };
          return RefCountOperator;
        })();
        var RefCountSubscriber = (function (_super) {
          __extends(RefCountSubscriber, _super);
          function RefCountSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
          }
          RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
              this.connection = null;
              return;
            }
            this.connectable = null;
            var refCount = connectable._refCount;
            if (refCount <= 0) {
              this.connection = null;
              return;
            }
            connectable._refCount = refCount - 1;
            if (refCount > 1) {
              this.connection = null;
              return;
            }
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (
              sharedConnection &&
              (!connection || sharedConnection === connection)
            ) {
              sharedConnection.unsubscribe();
            }
          };
          return RefCountSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    445: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var empty_1 = require("../observable/empty");
        function repeat(count) {
          if (count === void 0) {
            count = -1;
          }
          return function (source) {
            if (count === 0) {
              return empty_1.empty();
            } else if (count < 0) {
              return source.lift(new RepeatOperator(-1, source));
            } else {
              return source.lift(new RepeatOperator(count - 1, source));
            }
          };
        }
        exports.repeat = repeat;
        var RepeatOperator = (function () {
          function RepeatOperator(count, source) {
            this.count = count;
            this.source = source;
          }
          RepeatOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new RepeatSubscriber(subscriber, this.count, this.source)
            );
          };
          return RepeatOperator;
        })();
        var RepeatSubscriber = (function (_super) {
          __extends(RepeatSubscriber, _super);
          function RepeatSubscriber(destination, count, source) {
            var _this = _super.call(this, destination) || this;
            _this.count = count;
            _this.source = source;
            return _this;
          }
          RepeatSubscriber.prototype.complete = function () {
            if (!this.isStopped) {
              var _a = this,
                source = _a.source,
                count = _a.count;
              if (count === 0) {
                return _super.prototype.complete.call(this);
              } else if (count > -1) {
                this.count = count - 1;
              }
              source.subscribe(this._unsubscribeAndRecycle());
            }
          };
          return RepeatSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346, "../observable/empty": 360 },
    ],
    446: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function repeatWhen(notifier) {
          return function (source) {
            return source.lift(new RepeatWhenOperator(notifier));
          };
        }
        exports.repeatWhen = repeatWhen;
        var RepeatWhenOperator = (function () {
          function RepeatWhenOperator(notifier) {
            this.notifier = notifier;
          }
          RepeatWhenOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new RepeatWhenSubscriber(subscriber, this.notifier, source)
            );
          };
          return RepeatWhenOperator;
        })();
        var RepeatWhenSubscriber = (function (_super) {
          __extends(RepeatWhenSubscriber, _super);
          function RepeatWhenSubscriber(destination, notifier, source) {
            var _this = _super.call(this, destination) || this;
            _this.notifier = notifier;
            _this.source = source;
            _this.sourceIsBeingSubscribedTo = true;
            return _this;
          }
          RepeatWhenSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.sourceIsBeingSubscribedTo = true;
            this.source.subscribe(this);
          };
          RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
            if (this.sourceIsBeingSubscribedTo === false) {
              return _super.prototype.complete.call(this);
            }
          };
          RepeatWhenSubscriber.prototype.complete = function () {
            this.sourceIsBeingSubscribedTo = false;
            if (!this.isStopped) {
              if (!this.retries) {
                this.subscribeToRetries();
              }
              if (
                !this.retriesSubscription ||
                this.retriesSubscription.closed
              ) {
                return _super.prototype.complete.call(this);
              }
              this._unsubscribeAndRecycle();
              this.notifications.next();
            }
          };
          RepeatWhenSubscriber.prototype._unsubscribe = function () {
            var _a = this,
              notifications = _a.notifications,
              retriesSubscription = _a.retriesSubscription;
            if (notifications) {
              notifications.unsubscribe();
              this.notifications = null;
            }
            if (retriesSubscription) {
              retriesSubscription.unsubscribe();
              this.retriesSubscription = null;
            }
            this.retries = null;
          };
          RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
            var _unsubscribe = this._unsubscribe;
            this._unsubscribe = null;
            _super.prototype._unsubscribeAndRecycle.call(this);
            this._unsubscribe = _unsubscribe;
            return this;
          };
          RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
            this.notifications = new Subject_1.Subject();
            var retries;
            try {
              var notifier = this.notifier;
              retries = notifier(this.notifications);
            } catch (e) {
              return _super.prototype.complete.call(this);
            }
            this.retries = retries;
            this.retriesSubscription = subscribeToResult_1.subscribeToResult(
              this,
              retries
            );
          };
          return RepeatWhenSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../OuterSubscriber": 341,
        "../Subject": 344,
        "../util/subscribeToResult": 544,
      },
    ],
    447: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function retry(count) {
          if (count === void 0) {
            count = -1;
          }
          return function (source) {
            return source.lift(new RetryOperator(count, source));
          };
        }
        exports.retry = retry;
        var RetryOperator = (function () {
          function RetryOperator(count, source) {
            this.count = count;
            this.source = source;
          }
          RetryOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new RetrySubscriber(subscriber, this.count, this.source)
            );
          };
          return RetryOperator;
        })();
        var RetrySubscriber = (function (_super) {
          __extends(RetrySubscriber, _super);
          function RetrySubscriber(destination, count, source) {
            var _this = _super.call(this, destination) || this;
            _this.count = count;
            _this.source = source;
            return _this;
          }
          RetrySubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
              var _a = this,
                source = _a.source,
                count = _a.count;
              if (count === 0) {
                return _super.prototype.error.call(this, err);
              } else if (count > -1) {
                this.count = count - 1;
              }
              source.subscribe(this._unsubscribeAndRecycle());
            }
          };
          return RetrySubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    448: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function retryWhen(notifier) {
          return function (source) {
            return source.lift(new RetryWhenOperator(notifier, source));
          };
        }
        exports.retryWhen = retryWhen;
        var RetryWhenOperator = (function () {
          function RetryWhenOperator(notifier, source) {
            this.notifier = notifier;
            this.source = source;
          }
          RetryWhenOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new RetryWhenSubscriber(subscriber, this.notifier, this.source)
            );
          };
          return RetryWhenOperator;
        })();
        var RetryWhenSubscriber = (function (_super) {
          __extends(RetryWhenSubscriber, _super);
          function RetryWhenSubscriber(destination, notifier, source) {
            var _this = _super.call(this, destination) || this;
            _this.notifier = notifier;
            _this.source = source;
            return _this;
          }
          RetryWhenSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
              var errors = this.errors;
              var retries = this.retries;
              var retriesSubscription = this.retriesSubscription;
              if (!retries) {
                errors = new Subject_1.Subject();
                try {
                  var notifier = this.notifier;
                  retries = notifier(errors);
                } catch (e) {
                  return _super.prototype.error.call(this, e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(
                  this,
                  retries
                );
              } else {
                this.errors = null;
                this.retriesSubscription = null;
              }
              this._unsubscribeAndRecycle();
              this.errors = errors;
              this.retries = retries;
              this.retriesSubscription = retriesSubscription;
              errors.next(err);
            }
          };
          RetryWhenSubscriber.prototype._unsubscribe = function () {
            var _a = this,
              errors = _a.errors,
              retriesSubscription = _a.retriesSubscription;
            if (errors) {
              errors.unsubscribe();
              this.errors = null;
            }
            if (retriesSubscription) {
              retriesSubscription.unsubscribe();
              this.retriesSubscription = null;
            }
            this.retries = null;
          };
          RetryWhenSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            var _unsubscribe = this._unsubscribe;
            this._unsubscribe = null;
            this._unsubscribeAndRecycle();
            this._unsubscribe = _unsubscribe;
            this.source.subscribe(this);
          };
          return RetryWhenSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../OuterSubscriber": 341,
        "../Subject": 344,
        "../util/subscribeToResult": 544,
      },
    ],
    449: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function sample(notifier) {
          return function (source) {
            return source.lift(new SampleOperator(notifier));
          };
        }
        exports.sample = sample;
        var SampleOperator = (function () {
          function SampleOperator(notifier) {
            this.notifier = notifier;
          }
          SampleOperator.prototype.call = function (subscriber, source) {
            var sampleSubscriber = new SampleSubscriber(subscriber);
            var subscription = source.subscribe(sampleSubscriber);
            subscription.add(
              subscribeToResult_1.subscribeToResult(
                sampleSubscriber,
                this.notifier
              )
            );
            return subscription;
          };
          return SampleOperator;
        })();
        var SampleSubscriber = (function (_super) {
          __extends(SampleSubscriber, _super);
          function SampleSubscriber() {
            var _this =
              (_super !== null && _super.apply(this, arguments)) || this;
            _this.hasValue = false;
            return _this;
          }
          SampleSubscriber.prototype._next = function (value) {
            this.value = value;
            this.hasValue = true;
          };
          SampleSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.emitValue();
          };
          SampleSubscriber.prototype.notifyComplete = function () {
            this.emitValue();
          };
          SampleSubscriber.prototype.emitValue = function () {
            if (this.hasValue) {
              this.hasValue = false;
              this.destination.next(this.value);
            }
          };
          return SampleSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    450: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var async_1 = require("../scheduler/async");
        function sampleTime(period, scheduler) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          return function (source) {
            return source.lift(new SampleTimeOperator(period, scheduler));
          };
        }
        exports.sampleTime = sampleTime;
        var SampleTimeOperator = (function () {
          function SampleTimeOperator(period, scheduler) {
            this.period = period;
            this.scheduler = scheduler;
          }
          SampleTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new SampleTimeSubscriber(subscriber, this.period, this.scheduler)
            );
          };
          return SampleTimeOperator;
        })();
        var SampleTimeSubscriber = (function (_super) {
          __extends(SampleTimeSubscriber, _super);
          function SampleTimeSubscriber(destination, period, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.period = period;
            _this.scheduler = scheduler;
            _this.hasValue = false;
            _this.add(
              scheduler.schedule(dispatchNotification, period, {
                subscriber: _this,
                period: period,
              })
            );
            return _this;
          }
          SampleTimeSubscriber.prototype._next = function (value) {
            this.lastValue = value;
            this.hasValue = true;
          };
          SampleTimeSubscriber.prototype.notifyNext = function () {
            if (this.hasValue) {
              this.hasValue = false;
              this.destination.next(this.lastValue);
            }
          };
          return SampleTimeSubscriber;
        })(Subscriber_1.Subscriber);
        function dispatchNotification(state) {
          var subscriber = state.subscriber,
            period = state.period;
          subscriber.notifyNext();
          this.schedule(state, period);
        }
      },
      { "../Subscriber": 346, "../scheduler/async": 503 },
    ],
    451: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function scan(accumulator, seed) {
          var hasSeed = false;
          if (arguments.length >= 2) {
            hasSeed = true;
          }
          return function scanOperatorFunction(source) {
            return source.lift(new ScanOperator(accumulator, seed, hasSeed));
          };
        }
        exports.scan = scan;
        var ScanOperator = (function () {
          function ScanOperator(accumulator, seed, hasSeed) {
            if (hasSeed === void 0) {
              hasSeed = false;
            }
            this.accumulator = accumulator;
            this.seed = seed;
            this.hasSeed = hasSeed;
          }
          ScanOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new ScanSubscriber(
                subscriber,
                this.accumulator,
                this.seed,
                this.hasSeed
              )
            );
          };
          return ScanOperator;
        })();
        var ScanSubscriber = (function (_super) {
          __extends(ScanSubscriber, _super);
          function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
            var _this = _super.call(this, destination) || this;
            _this.accumulator = accumulator;
            _this._seed = _seed;
            _this.hasSeed = hasSeed;
            _this.index = 0;
            return _this;
          }
          Object.defineProperty(ScanSubscriber.prototype, "seed", {
            get: function () {
              return this._seed;
            },
            set: function (value) {
              this.hasSeed = true;
              this._seed = value;
            },
            enumerable: true,
            configurable: true,
          });
          ScanSubscriber.prototype._next = function (value) {
            if (!this.hasSeed) {
              this.seed = value;
              this.destination.next(value);
            } else {
              return this._tryNext(value);
            }
          };
          ScanSubscriber.prototype._tryNext = function (value) {
            var index = this.index++;
            var result;
            try {
              result = this.accumulator(this.seed, value, index);
            } catch (err) {
              this.destination.error(err);
            }
            this.seed = result;
            this.destination.next(result);
          };
          return ScanSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    452: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function sequenceEqual(compareTo, comparator) {
          return function (source) {
            return source.lift(
              new SequenceEqualOperator(compareTo, comparator)
            );
          };
        }
        exports.sequenceEqual = sequenceEqual;
        var SequenceEqualOperator = (function () {
          function SequenceEqualOperator(compareTo, comparator) {
            this.compareTo = compareTo;
            this.comparator = comparator;
          }
          SequenceEqualOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new SequenceEqualSubscriber(
                subscriber,
                this.compareTo,
                this.comparator
              )
            );
          };
          return SequenceEqualOperator;
        })();
        exports.SequenceEqualOperator = SequenceEqualOperator;
        var SequenceEqualSubscriber = (function (_super) {
          __extends(SequenceEqualSubscriber, _super);
          function SequenceEqualSubscriber(destination, compareTo, comparator) {
            var _this = _super.call(this, destination) || this;
            _this.compareTo = compareTo;
            _this.comparator = comparator;
            _this._a = [];
            _this._b = [];
            _this._oneComplete = false;
            _this.destination.add(
              compareTo.subscribe(
                new SequenceEqualCompareToSubscriber(destination, _this)
              )
            );
            return _this;
          }
          SequenceEqualSubscriber.prototype._next = function (value) {
            if (this._oneComplete && this._b.length === 0) {
              this.emit(false);
            } else {
              this._a.push(value);
              this.checkValues();
            }
          };
          SequenceEqualSubscriber.prototype._complete = function () {
            if (this._oneComplete) {
              this.emit(this._a.length === 0 && this._b.length === 0);
            } else {
              this._oneComplete = true;
            }
            this.unsubscribe();
          };
          SequenceEqualSubscriber.prototype.checkValues = function () {
            var _c = this,
              _a = _c._a,
              _b = _c._b,
              comparator = _c.comparator;
            while (_a.length > 0 && _b.length > 0) {
              var a = _a.shift();
              var b = _b.shift();
              var areEqual = false;
              try {
                areEqual = comparator ? comparator(a, b) : a === b;
              } catch (e) {
                this.destination.error(e);
              }
              if (!areEqual) {
                this.emit(false);
              }
            }
          };
          SequenceEqualSubscriber.prototype.emit = function (value) {
            var destination = this.destination;
            destination.next(value);
            destination.complete();
          };
          SequenceEqualSubscriber.prototype.nextB = function (value) {
            if (this._oneComplete && this._a.length === 0) {
              this.emit(false);
            } else {
              this._b.push(value);
              this.checkValues();
            }
          };
          SequenceEqualSubscriber.prototype.completeB = function () {
            if (this._oneComplete) {
              this.emit(this._a.length === 0 && this._b.length === 0);
            } else {
              this._oneComplete = true;
            }
          };
          return SequenceEqualSubscriber;
        })(Subscriber_1.Subscriber);
        exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
        var SequenceEqualCompareToSubscriber = (function (_super) {
          __extends(SequenceEqualCompareToSubscriber, _super);
          function SequenceEqualCompareToSubscriber(destination, parent) {
            var _this = _super.call(this, destination) || this;
            _this.parent = parent;
            return _this;
          }
          SequenceEqualCompareToSubscriber.prototype._next = function (value) {
            this.parent.nextB(value);
          };
          SequenceEqualCompareToSubscriber.prototype._error = function (err) {
            this.parent.error(err);
            this.unsubscribe();
          };
          SequenceEqualCompareToSubscriber.prototype._complete = function () {
            this.parent.completeB();
            this.unsubscribe();
          };
          return SequenceEqualCompareToSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    453: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var multicast_1 = require("./multicast");
        var refCount_1 = require("./refCount");
        var Subject_1 = require("../Subject");
        function shareSubjectFactory() {
          return new Subject_1.Subject();
        }
        function share() {
          return function (source) {
            return refCount_1.refCount()(
              multicast_1.multicast(shareSubjectFactory)(source)
            );
          };
        }
        exports.share = share;
      },
      { "../Subject": 344, "./multicast": 432, "./refCount": 444 },
    ],
    454: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ReplaySubject_1 = require("../ReplaySubject");
        function shareReplay(configOrBufferSize, windowTime, scheduler) {
          var config;
          if (configOrBufferSize && typeof configOrBufferSize === "object") {
            config = configOrBufferSize;
          } else {
            config = {
              bufferSize: configOrBufferSize,
              windowTime: windowTime,
              refCount: false,
              scheduler: scheduler,
            };
          }
          return function (source) {
            return source.lift(shareReplayOperator(config));
          };
        }
        exports.shareReplay = shareReplay;
        function shareReplayOperator(_a) {
          var _b = _a.bufferSize,
            bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b,
            _c = _a.windowTime,
            windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c,
            useRefCount = _a.refCount,
            scheduler = _a.scheduler;
          var subject;
          var refCount = 0;
          var subscription;
          var hasError = false;
          var isComplete = false;
          return function shareReplayOperation(source) {
            refCount++;
            if (!subject || hasError) {
              hasError = false;
              subject = new ReplaySubject_1.ReplaySubject(
                bufferSize,
                windowTime,
                scheduler
              );
              subscription = source.subscribe({
                next: function (value) {
                  subject.next(value);
                },
                error: function (err) {
                  hasError = true;
                  subject.error(err);
                },
                complete: function () {
                  isComplete = true;
                  subscription = undefined;
                  subject.complete();
                },
              });
            }
            var innerSub = subject.subscribe(this);
            this.add(function () {
              refCount--;
              innerSub.unsubscribe();
              if (
                subscription &&
                !isComplete &&
                useRefCount &&
                refCount === 0
              ) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
              }
            });
          };
        }
      },
      { "../ReplaySubject": 342 },
    ],
    455: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var EmptyError_1 = require("../util/EmptyError");
        function single(predicate) {
          return function (source) {
            return source.lift(new SingleOperator(predicate, source));
          };
        }
        exports.single = single;
        var SingleOperator = (function () {
          function SingleOperator(predicate, source) {
            this.predicate = predicate;
            this.source = source;
          }
          SingleOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new SingleSubscriber(subscriber, this.predicate, this.source)
            );
          };
          return SingleOperator;
        })();
        var SingleSubscriber = (function (_super) {
          __extends(SingleSubscriber, _super);
          function SingleSubscriber(destination, predicate, source) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.source = source;
            _this.seenValue = false;
            _this.index = 0;
            return _this;
          }
          SingleSubscriber.prototype.applySingleValue = function (value) {
            if (this.seenValue) {
              this.destination.error("Sequence contains more than one element");
            } else {
              this.seenValue = true;
              this.singleValue = value;
            }
          };
          SingleSubscriber.prototype._next = function (value) {
            var index = this.index++;
            if (this.predicate) {
              this.tryNext(value, index);
            } else {
              this.applySingleValue(value);
            }
          };
          SingleSubscriber.prototype.tryNext = function (value, index) {
            try {
              if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
              }
            } catch (err) {
              this.destination.error(err);
            }
          };
          SingleSubscriber.prototype._complete = function () {
            var destination = this.destination;
            if (this.index > 0) {
              destination.next(this.seenValue ? this.singleValue : undefined);
              destination.complete();
            } else {
              destination.error(new EmptyError_1.EmptyError());
            }
          };
          return SingleSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346, "../util/EmptyError": 514 },
    ],
    456: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function skip(count) {
          return function (source) {
            return source.lift(new SkipOperator(count));
          };
        }
        exports.skip = skip;
        var SkipOperator = (function () {
          function SkipOperator(total) {
            this.total = total;
          }
          SkipOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SkipSubscriber(subscriber, this.total));
          };
          return SkipOperator;
        })();
        var SkipSubscriber = (function (_super) {
          __extends(SkipSubscriber, _super);
          function SkipSubscriber(destination, total) {
            var _this = _super.call(this, destination) || this;
            _this.total = total;
            _this.count = 0;
            return _this;
          }
          SkipSubscriber.prototype._next = function (x) {
            if (++this.count > this.total) {
              this.destination.next(x);
            }
          };
          return SkipSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    457: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
        function skipLast(count) {
          return function (source) {
            return source.lift(new SkipLastOperator(count));
          };
        }
        exports.skipLast = skipLast;
        var SkipLastOperator = (function () {
          function SkipLastOperator(_skipCount) {
            this._skipCount = _skipCount;
            if (this._skipCount < 0) {
              throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
            }
          }
          SkipLastOperator.prototype.call = function (subscriber, source) {
            if (this._skipCount === 0) {
              return source.subscribe(new Subscriber_1.Subscriber(subscriber));
            } else {
              return source.subscribe(
                new SkipLastSubscriber(subscriber, this._skipCount)
              );
            }
          };
          return SkipLastOperator;
        })();
        var SkipLastSubscriber = (function (_super) {
          __extends(SkipLastSubscriber, _super);
          function SkipLastSubscriber(destination, _skipCount) {
            var _this = _super.call(this, destination) || this;
            _this._skipCount = _skipCount;
            _this._count = 0;
            _this._ring = new Array(_skipCount);
            return _this;
          }
          SkipLastSubscriber.prototype._next = function (value) {
            var skipCount = this._skipCount;
            var count = this._count++;
            if (count < skipCount) {
              this._ring[count] = value;
            } else {
              var currentIndex = count % skipCount;
              var ring = this._ring;
              var oldValue = ring[currentIndex];
              ring[currentIndex] = value;
              this.destination.next(oldValue);
            }
          };
          return SkipLastSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346, "../util/ArgumentOutOfRangeError": 513 },
    ],
    458: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var InnerSubscriber_1 = require("../InnerSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function skipUntil(notifier) {
          return function (source) {
            return source.lift(new SkipUntilOperator(notifier));
          };
        }
        exports.skipUntil = skipUntil;
        var SkipUntilOperator = (function () {
          function SkipUntilOperator(notifier) {
            this.notifier = notifier;
          }
          SkipUntilOperator.prototype.call = function (destination, source) {
            return source.subscribe(
              new SkipUntilSubscriber(destination, this.notifier)
            );
          };
          return SkipUntilOperator;
        })();
        var SkipUntilSubscriber = (function (_super) {
          __extends(SkipUntilSubscriber, _super);
          function SkipUntilSubscriber(destination, notifier) {
            var _this = _super.call(this, destination) || this;
            _this.hasValue = false;
            var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(
              _this,
              undefined,
              undefined
            );
            _this.add(innerSubscriber);
            _this.innerSubscription = innerSubscriber;
            var innerSubscription = subscribeToResult_1.subscribeToResult(
              _this,
              notifier,
              undefined,
              undefined,
              innerSubscriber
            );
            if (innerSubscription !== innerSubscriber) {
              _this.add(innerSubscription);
              _this.innerSubscription = innerSubscription;
            }
            return _this;
          }
          SkipUntilSubscriber.prototype._next = function (value) {
            if (this.hasValue) {
              _super.prototype._next.call(this, value);
            }
          };
          SkipUntilSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.hasValue = true;
            if (this.innerSubscription) {
              this.innerSubscription.unsubscribe();
            }
          };
          SkipUntilSubscriber.prototype.notifyComplete = function () {};
          return SkipUntilSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../InnerSubscriber": 337,
        "../OuterSubscriber": 341,
        "../util/subscribeToResult": 544,
      },
    ],
    459: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function skipWhile(predicate) {
          return function (source) {
            return source.lift(new SkipWhileOperator(predicate));
          };
        }
        exports.skipWhile = skipWhile;
        var SkipWhileOperator = (function () {
          function SkipWhileOperator(predicate) {
            this.predicate = predicate;
          }
          SkipWhileOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new SkipWhileSubscriber(subscriber, this.predicate)
            );
          };
          return SkipWhileOperator;
        })();
        var SkipWhileSubscriber = (function (_super) {
          __extends(SkipWhileSubscriber, _super);
          function SkipWhileSubscriber(destination, predicate) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.skipping = true;
            _this.index = 0;
            return _this;
          }
          SkipWhileSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            if (this.skipping) {
              this.tryCallPredicate(value);
            }
            if (!this.skipping) {
              destination.next(value);
            }
          };
          SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
            try {
              var result = this.predicate(value, this.index++);
              this.skipping = Boolean(result);
            } catch (err) {
              this.destination.error(err);
            }
          };
          return SkipWhileSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    460: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var concat_1 = require("../observable/concat");
        var isScheduler_1 = require("../util/isScheduler");
        function startWith() {
          var array = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
          }
          var scheduler = array[array.length - 1];
          if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
            return function (source) {
              return concat_1.concat(array, source, scheduler);
            };
          } else {
            return function (source) {
              return concat_1.concat(array, source);
            };
          }
        }
        exports.startWith = startWith;
      },
      { "../observable/concat": 354, "../util/isScheduler": 534 },
    ],
    461: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var SubscribeOnObservable_1 = require("../observable/SubscribeOnObservable");
        function subscribeOn(scheduler, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return function subscribeOnOperatorFunction(source) {
            return source.lift(new SubscribeOnOperator(scheduler, delay));
          };
        }
        exports.subscribeOn = subscribeOn;
        var SubscribeOnOperator = (function () {
          function SubscribeOnOperator(scheduler, delay) {
            this.scheduler = scheduler;
            this.delay = delay;
          }
          SubscribeOnOperator.prototype.call = function (subscriber, source) {
            return new SubscribeOnObservable_1.SubscribeOnObservable(
              source,
              this.delay,
              this.scheduler
            ).subscribe(subscriber);
          };
          return SubscribeOnOperator;
        })();
      },
      { "../observable/SubscribeOnObservable": 350 },
    ],
    462: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var switchMap_1 = require("./switchMap");
        var identity_1 = require("../util/identity");
        function switchAll() {
          return switchMap_1.switchMap(identity_1.identity);
        }
        exports.switchAll = switchAll;
      },
      { "../util/identity": 523, "./switchMap": 463 },
    ],
    463: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var InnerSubscriber_1 = require("../InnerSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        var map_1 = require("./map");
        var from_1 = require("../observable/from");
        function switchMap(project, resultSelector) {
          if (typeof resultSelector === "function") {
            return function (source) {
              return source.pipe(
                switchMap(function (a, i) {
                  return from_1.from(project(a, i)).pipe(
                    map_1.map(function (b, ii) {
                      return resultSelector(a, b, i, ii);
                    })
                  );
                })
              );
            };
          }
          return function (source) {
            return source.lift(new SwitchMapOperator(project));
          };
        }
        exports.switchMap = switchMap;
        var SwitchMapOperator = (function () {
          function SwitchMapOperator(project) {
            this.project = project;
          }
          SwitchMapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new SwitchMapSubscriber(subscriber, this.project)
            );
          };
          return SwitchMapOperator;
        })();
        var SwitchMapSubscriber = (function (_super) {
          __extends(SwitchMapSubscriber, _super);
          function SwitchMapSubscriber(destination, project) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.index = 0;
            return _this;
          }
          SwitchMapSubscriber.prototype._next = function (value) {
            var result;
            var index = this.index++;
            try {
              result = this.project(value, index);
            } catch (error) {
              this.destination.error(error);
              return;
            }
            this._innerSub(result, value, index);
          };
          SwitchMapSubscriber.prototype._innerSub = function (
            result,
            value,
            index
          ) {
            var innerSubscription = this.innerSubscription;
            if (innerSubscription) {
              innerSubscription.unsubscribe();
            }
            var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(
              this,
              value,
              index
            );
            var destination = this.destination;
            destination.add(innerSubscriber);
            this.innerSubscription = subscribeToResult_1.subscribeToResult(
              this,
              result,
              undefined,
              undefined,
              innerSubscriber
            );
            if (this.innerSubscription !== innerSubscriber) {
              destination.add(this.innerSubscription);
            }
          };
          SwitchMapSubscriber.prototype._complete = function () {
            var innerSubscription = this.innerSubscription;
            if (!innerSubscription || innerSubscription.closed) {
              _super.prototype._complete.call(this);
            }
            this.unsubscribe();
          };
          SwitchMapSubscriber.prototype._unsubscribe = function () {
            this.innerSubscription = null;
          };
          SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
            var destination = this.destination;
            destination.remove(innerSub);
            this.innerSubscription = null;
            if (this.isStopped) {
              _super.prototype._complete.call(this);
            }
          };
          SwitchMapSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.destination.next(innerValue);
          };
          return SwitchMapSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../InnerSubscriber": 337,
        "../OuterSubscriber": 341,
        "../observable/from": 362,
        "../util/subscribeToResult": 544,
        "./map": 422,
      },
    ],
    464: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var switchMap_1 = require("./switchMap");
        function switchMapTo(innerObservable, resultSelector) {
          return resultSelector
            ? switchMap_1.switchMap(function () {
                return innerObservable;
              }, resultSelector)
            : switchMap_1.switchMap(function () {
                return innerObservable;
              });
        }
        exports.switchMapTo = switchMapTo;
      },
      { "./switchMap": 463 },
    ],
    465: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
        var empty_1 = require("../observable/empty");
        function take(count) {
          return function (source) {
            if (count === 0) {
              return empty_1.empty();
            } else {
              return source.lift(new TakeOperator(count));
            }
          };
        }
        exports.take = take;
        var TakeOperator = (function () {
          function TakeOperator(total) {
            this.total = total;
            if (this.total < 0) {
              throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
            }
          }
          TakeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TakeSubscriber(subscriber, this.total));
          };
          return TakeOperator;
        })();
        var TakeSubscriber = (function (_super) {
          __extends(TakeSubscriber, _super);
          function TakeSubscriber(destination, total) {
            var _this = _super.call(this, destination) || this;
            _this.total = total;
            _this.count = 0;
            return _this;
          }
          TakeSubscriber.prototype._next = function (value) {
            var total = this.total;
            var count = ++this.count;
            if (count <= total) {
              this.destination.next(value);
              if (count === total) {
                this.destination.complete();
                this.unsubscribe();
              }
            }
          };
          return TakeSubscriber;
        })(Subscriber_1.Subscriber);
      },
      {
        "../Subscriber": 346,
        "../observable/empty": 360,
        "../util/ArgumentOutOfRangeError": 513,
      },
    ],
    466: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
        var empty_1 = require("../observable/empty");
        function takeLast(count) {
          return function takeLastOperatorFunction(source) {
            if (count === 0) {
              return empty_1.empty();
            } else {
              return source.lift(new TakeLastOperator(count));
            }
          };
        }
        exports.takeLast = takeLast;
        var TakeLastOperator = (function () {
          function TakeLastOperator(total) {
            this.total = total;
            if (this.total < 0) {
              throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
            }
          }
          TakeLastOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new TakeLastSubscriber(subscriber, this.total)
            );
          };
          return TakeLastOperator;
        })();
        var TakeLastSubscriber = (function (_super) {
          __extends(TakeLastSubscriber, _super);
          function TakeLastSubscriber(destination, total) {
            var _this = _super.call(this, destination) || this;
            _this.total = total;
            _this.ring = new Array();
            _this.count = 0;
            return _this;
          }
          TakeLastSubscriber.prototype._next = function (value) {
            var ring = this.ring;
            var total = this.total;
            var count = this.count++;
            if (ring.length < total) {
              ring.push(value);
            } else {
              var index = count % total;
              ring[index] = value;
            }
          };
          TakeLastSubscriber.prototype._complete = function () {
            var destination = this.destination;
            var count = this.count;
            if (count > 0) {
              var total = this.count >= this.total ? this.total : this.count;
              var ring = this.ring;
              for (var i = 0; i < total; i++) {
                var idx = count++ % total;
                destination.next(ring[idx]);
              }
            }
            destination.complete();
          };
          return TakeLastSubscriber;
        })(Subscriber_1.Subscriber);
      },
      {
        "../Subscriber": 346,
        "../observable/empty": 360,
        "../util/ArgumentOutOfRangeError": 513,
      },
    ],
    467: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function takeUntil(notifier) {
          return function (source) {
            return source.lift(new TakeUntilOperator(notifier));
          };
        }
        exports.takeUntil = takeUntil;
        var TakeUntilOperator = (function () {
          function TakeUntilOperator(notifier) {
            this.notifier = notifier;
          }
          TakeUntilOperator.prototype.call = function (subscriber, source) {
            var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
            var notifierSubscription = subscribeToResult_1.subscribeToResult(
              takeUntilSubscriber,
              this.notifier
            );
            if (notifierSubscription && !takeUntilSubscriber.seenValue) {
              takeUntilSubscriber.add(notifierSubscription);
              return source.subscribe(takeUntilSubscriber);
            }
            return takeUntilSubscriber;
          };
          return TakeUntilOperator;
        })();
        var TakeUntilSubscriber = (function (_super) {
          __extends(TakeUntilSubscriber, _super);
          function TakeUntilSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.seenValue = false;
            return _this;
          }
          TakeUntilSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.seenValue = true;
            this.complete();
          };
          TakeUntilSubscriber.prototype.notifyComplete = function () {};
          return TakeUntilSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    468: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function takeWhile(predicate, inclusive) {
          if (inclusive === void 0) {
            inclusive = false;
          }
          return function (source) {
            return source.lift(new TakeWhileOperator(predicate, inclusive));
          };
        }
        exports.takeWhile = takeWhile;
        var TakeWhileOperator = (function () {
          function TakeWhileOperator(predicate, inclusive) {
            this.predicate = predicate;
            this.inclusive = inclusive;
          }
          TakeWhileOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new TakeWhileSubscriber(
                subscriber,
                this.predicate,
                this.inclusive
              )
            );
          };
          return TakeWhileOperator;
        })();
        var TakeWhileSubscriber = (function (_super) {
          __extends(TakeWhileSubscriber, _super);
          function TakeWhileSubscriber(destination, predicate, inclusive) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.inclusive = inclusive;
            _this.index = 0;
            return _this;
          }
          TakeWhileSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            var result;
            try {
              result = this.predicate(value, this.index++);
            } catch (err) {
              destination.error(err);
              return;
            }
            this.nextOrComplete(value, result);
          };
          TakeWhileSubscriber.prototype.nextOrComplete = function (
            value,
            predicateResult
          ) {
            var destination = this.destination;
            if (Boolean(predicateResult)) {
              destination.next(value);
            } else {
              if (this.inclusive) {
                destination.next(value);
              }
              destination.complete();
            }
          };
          return TakeWhileSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346 },
    ],
    469: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var noop_1 = require("../util/noop");
        var isFunction_1 = require("../util/isFunction");
        function tap(nextOrObserver, error, complete) {
          return function tapOperatorFunction(source) {
            return source.lift(new DoOperator(nextOrObserver, error, complete));
          };
        }
        exports.tap = tap;
        var DoOperator = (function () {
          function DoOperator(nextOrObserver, error, complete) {
            this.nextOrObserver = nextOrObserver;
            this.error = error;
            this.complete = complete;
          }
          DoOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new TapSubscriber(
                subscriber,
                this.nextOrObserver,
                this.error,
                this.complete
              )
            );
          };
          return DoOperator;
        })();
        var TapSubscriber = (function (_super) {
          __extends(TapSubscriber, _super);
          function TapSubscriber(destination, observerOrNext, error, complete) {
            var _this = _super.call(this, destination) || this;
            _this._tapNext = noop_1.noop;
            _this._tapError = noop_1.noop;
            _this._tapComplete = noop_1.noop;
            _this._tapError = error || noop_1.noop;
            _this._tapComplete = complete || noop_1.noop;
            if (isFunction_1.isFunction(observerOrNext)) {
              _this._context = _this;
              _this._tapNext = observerOrNext;
            } else if (observerOrNext) {
              _this._context = observerOrNext;
              _this._tapNext = observerOrNext.next || noop_1.noop;
              _this._tapError = observerOrNext.error || noop_1.noop;
              _this._tapComplete = observerOrNext.complete || noop_1.noop;
            }
            return _this;
          }
          TapSubscriber.prototype._next = function (value) {
            try {
              this._tapNext.call(this._context, value);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            this.destination.next(value);
          };
          TapSubscriber.prototype._error = function (err) {
            try {
              this._tapError.call(this._context, err);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            this.destination.error(err);
          };
          TapSubscriber.prototype._complete = function () {
            try {
              this._tapComplete.call(this._context);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            return this.destination.complete();
          };
          return TapSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subscriber": 346, "../util/isFunction": 527, "../util/noop": 535 },
    ],
    470: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        exports.defaultThrottleConfig = {
          leading: true,
          trailing: false,
        };
        function throttle(durationSelector, config) {
          if (config === void 0) {
            config = exports.defaultThrottleConfig;
          }
          return function (source) {
            return source.lift(
              new ThrottleOperator(
                durationSelector,
                config.leading,
                config.trailing
              )
            );
          };
        }
        exports.throttle = throttle;
        var ThrottleOperator = (function () {
          function ThrottleOperator(durationSelector, leading, trailing) {
            this.durationSelector = durationSelector;
            this.leading = leading;
            this.trailing = trailing;
          }
          ThrottleOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new ThrottleSubscriber(
                subscriber,
                this.durationSelector,
                this.leading,
                this.trailing
              )
            );
          };
          return ThrottleOperator;
        })();
        var ThrottleSubscriber = (function (_super) {
          __extends(ThrottleSubscriber, _super);
          function ThrottleSubscriber(
            destination,
            durationSelector,
            _leading,
            _trailing
          ) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.durationSelector = durationSelector;
            _this._leading = _leading;
            _this._trailing = _trailing;
            _this._hasValue = false;
            return _this;
          }
          ThrottleSubscriber.prototype._next = function (value) {
            this._hasValue = true;
            this._sendValue = value;
            if (!this._throttled) {
              if (this._leading) {
                this.send();
              } else {
                this.throttle(value);
              }
            }
          };
          ThrottleSubscriber.prototype.send = function () {
            var _a = this,
              _hasValue = _a._hasValue,
              _sendValue = _a._sendValue;
            if (_hasValue) {
              this.destination.next(_sendValue);
              this.throttle(_sendValue);
            }
            this._hasValue = false;
            this._sendValue = null;
          };
          ThrottleSubscriber.prototype.throttle = function (value) {
            var duration = this.tryDurationSelector(value);
            if (!!duration) {
              this.add(
                (this._throttled = subscribeToResult_1.subscribeToResult(
                  this,
                  duration
                ))
              );
            }
          };
          ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
            try {
              return this.durationSelector(value);
            } catch (err) {
              this.destination.error(err);
              return null;
            }
          };
          ThrottleSubscriber.prototype.throttlingDone = function () {
            var _a = this,
              _throttled = _a._throttled,
              _trailing = _a._trailing;
            if (_throttled) {
              _throttled.unsubscribe();
            }
            this._throttled = null;
            if (_trailing) {
              this.send();
            }
          };
          ThrottleSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.throttlingDone();
          };
          ThrottleSubscriber.prototype.notifyComplete = function () {
            this.throttlingDone();
          };
          return ThrottleSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    471: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var async_1 = require("../scheduler/async");
        var throttle_1 = require("./throttle");
        function throttleTime(duration, scheduler, config) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          if (config === void 0) {
            config = throttle_1.defaultThrottleConfig;
          }
          return function (source) {
            return source.lift(
              new ThrottleTimeOperator(
                duration,
                scheduler,
                config.leading,
                config.trailing
              )
            );
          };
        }
        exports.throttleTime = throttleTime;
        var ThrottleTimeOperator = (function () {
          function ThrottleTimeOperator(
            duration,
            scheduler,
            leading,
            trailing
          ) {
            this.duration = duration;
            this.scheduler = scheduler;
            this.leading = leading;
            this.trailing = trailing;
          }
          ThrottleTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new ThrottleTimeSubscriber(
                subscriber,
                this.duration,
                this.scheduler,
                this.leading,
                this.trailing
              )
            );
          };
          return ThrottleTimeOperator;
        })();
        var ThrottleTimeSubscriber = (function (_super) {
          __extends(ThrottleTimeSubscriber, _super);
          function ThrottleTimeSubscriber(
            destination,
            duration,
            scheduler,
            leading,
            trailing
          ) {
            var _this = _super.call(this, destination) || this;
            _this.duration = duration;
            _this.scheduler = scheduler;
            _this.leading = leading;
            _this.trailing = trailing;
            _this._hasTrailingValue = false;
            _this._trailingValue = null;
            return _this;
          }
          ThrottleTimeSubscriber.prototype._next = function (value) {
            if (this.throttled) {
              if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
              }
            } else {
              this.add(
                (this.throttled = this.scheduler.schedule(
                  dispatchNext,
                  this.duration,
                  { subscriber: this }
                ))
              );
              if (this.leading) {
                this.destination.next(value);
              } else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
              }
            }
          };
          ThrottleTimeSubscriber.prototype._complete = function () {
            if (this._hasTrailingValue) {
              this.destination.next(this._trailingValue);
              this.destination.complete();
            } else {
              this.destination.complete();
            }
          };
          ThrottleTimeSubscriber.prototype.clearThrottle = function () {
            var throttled = this.throttled;
            if (throttled) {
              if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
              }
              throttled.unsubscribe();
              this.remove(throttled);
              this.throttled = null;
            }
          };
          return ThrottleTimeSubscriber;
        })(Subscriber_1.Subscriber);
        function dispatchNext(arg) {
          var subscriber = arg.subscriber;
          subscriber.clearThrottle();
        }
      },
      { "../Subscriber": 346, "../scheduler/async": 503, "./throttle": 470 },
    ],
    472: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var EmptyError_1 = require("../util/EmptyError");
        var Subscriber_1 = require("../Subscriber");
        function throwIfEmpty(errorFactory) {
          if (errorFactory === void 0) {
            errorFactory = defaultErrorFactory;
          }
          return function (source) {
            return source.lift(new ThrowIfEmptyOperator(errorFactory));
          };
        }
        exports.throwIfEmpty = throwIfEmpty;
        var ThrowIfEmptyOperator = (function () {
          function ThrowIfEmptyOperator(errorFactory) {
            this.errorFactory = errorFactory;
          }
          ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new ThrowIfEmptySubscriber(subscriber, this.errorFactory)
            );
          };
          return ThrowIfEmptyOperator;
        })();
        var ThrowIfEmptySubscriber = (function (_super) {
          __extends(ThrowIfEmptySubscriber, _super);
          function ThrowIfEmptySubscriber(destination, errorFactory) {
            var _this = _super.call(this, destination) || this;
            _this.errorFactory = errorFactory;
            _this.hasValue = false;
            return _this;
          }
          ThrowIfEmptySubscriber.prototype._next = function (value) {
            this.hasValue = true;
            this.destination.next(value);
          };
          ThrowIfEmptySubscriber.prototype._complete = function () {
            if (!this.hasValue) {
              var err = void 0;
              try {
                err = this.errorFactory();
              } catch (e) {
                err = e;
              }
              this.destination.error(err);
            } else {
              return this.destination.complete();
            }
          };
          return ThrowIfEmptySubscriber;
        })(Subscriber_1.Subscriber);
        function defaultErrorFactory() {
          return new EmptyError_1.EmptyError();
        }
      },
      { "../Subscriber": 346, "../util/EmptyError": 514 },
    ],
    473: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var async_1 = require("../scheduler/async");
        var scan_1 = require("./scan");
        var defer_1 = require("../observable/defer");
        var map_1 = require("./map");
        function timeInterval(scheduler) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          return function (source) {
            return defer_1.defer(function () {
              return source.pipe(
                scan_1.scan(
                  function (_a, value) {
                    var current = _a.current;
                    return {
                      value: value,
                      current: scheduler.now(),
                      last: current,
                    };
                  },
                  {
                    current: scheduler.now(),
                    value: undefined,
                    last: undefined,
                  }
                ),
                map_1.map(function (_a) {
                  var current = _a.current,
                    last = _a.last,
                    value = _a.value;
                  return new TimeInterval(value, current - last);
                })
              );
            });
          };
        }
        exports.timeInterval = timeInterval;
        var TimeInterval = (function () {
          function TimeInterval(value, interval) {
            this.value = value;
            this.interval = interval;
          }
          return TimeInterval;
        })();
        exports.TimeInterval = TimeInterval;
      },
      {
        "../observable/defer": 355,
        "../scheduler/async": 503,
        "./map": 422,
        "./scan": 451,
      },
    ],
    474: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var async_1 = require("../scheduler/async");
        var TimeoutError_1 = require("../util/TimeoutError");
        var timeoutWith_1 = require("./timeoutWith");
        var throwError_1 = require("../observable/throwError");
        function timeout(due, scheduler) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          return timeoutWith_1.timeoutWith(
            due,
            throwError_1.throwError(new TimeoutError_1.TimeoutError()),
            scheduler
          );
        }
        exports.timeout = timeout;
      },
      {
        "../observable/throwError": 379,
        "../scheduler/async": 503,
        "../util/TimeoutError": 517,
        "./timeoutWith": 475,
      },
    ],
    475: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var async_1 = require("../scheduler/async");
        var isDate_1 = require("../util/isDate");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function timeoutWith(due, withObservable, scheduler) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          return function (source) {
            var absoluteTimeout = isDate_1.isDate(due);
            var waitFor = absoluteTimeout
              ? +due - scheduler.now()
              : Math.abs(due);
            return source.lift(
              new TimeoutWithOperator(
                waitFor,
                absoluteTimeout,
                withObservable,
                scheduler
              )
            );
          };
        }
        exports.timeoutWith = timeoutWith;
        var TimeoutWithOperator = (function () {
          function TimeoutWithOperator(
            waitFor,
            absoluteTimeout,
            withObservable,
            scheduler
          ) {
            this.waitFor = waitFor;
            this.absoluteTimeout = absoluteTimeout;
            this.withObservable = withObservable;
            this.scheduler = scheduler;
          }
          TimeoutWithOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new TimeoutWithSubscriber(
                subscriber,
                this.absoluteTimeout,
                this.waitFor,
                this.withObservable,
                this.scheduler
              )
            );
          };
          return TimeoutWithOperator;
        })();
        var TimeoutWithSubscriber = (function (_super) {
          __extends(TimeoutWithSubscriber, _super);
          function TimeoutWithSubscriber(
            destination,
            absoluteTimeout,
            waitFor,
            withObservable,
            scheduler
          ) {
            var _this = _super.call(this, destination) || this;
            _this.absoluteTimeout = absoluteTimeout;
            _this.waitFor = waitFor;
            _this.withObservable = withObservable;
            _this.scheduler = scheduler;
            _this.action = null;
            _this.scheduleTimeout();
            return _this;
          }
          TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
            var withObservable = subscriber.withObservable;
            subscriber._unsubscribeAndRecycle();
            subscriber.add(
              subscribeToResult_1.subscribeToResult(subscriber, withObservable)
            );
          };
          TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
            var action = this.action;
            if (action) {
              this.action = action.schedule(this, this.waitFor);
            } else {
              this.add(
                (this.action = this.scheduler.schedule(
                  TimeoutWithSubscriber.dispatchTimeout,
                  this.waitFor,
                  this
                ))
              );
            }
          };
          TimeoutWithSubscriber.prototype._next = function (value) {
            if (!this.absoluteTimeout) {
              this.scheduleTimeout();
            }
            _super.prototype._next.call(this, value);
          };
          TimeoutWithSubscriber.prototype._unsubscribe = function () {
            this.action = null;
            this.scheduler = null;
            this.withObservable = null;
          };
          return TimeoutWithSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../OuterSubscriber": 341,
        "../scheduler/async": 503,
        "../util/isDate": 526,
        "../util/subscribeToResult": 544,
      },
    ],
    476: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var async_1 = require("../scheduler/async");
        var map_1 = require("./map");
        function timestamp(scheduler) {
          if (scheduler === void 0) {
            scheduler = async_1.async;
          }
          return map_1.map(function (value) {
            return new Timestamp(value, scheduler.now());
          });
        }
        exports.timestamp = timestamp;
        var Timestamp = (function () {
          function Timestamp(value, timestamp) {
            this.value = value;
            this.timestamp = timestamp;
          }
          return Timestamp;
        })();
        exports.Timestamp = Timestamp;
      },
      { "../scheduler/async": 503, "./map": 422 },
    ],
    477: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var reduce_1 = require("./reduce");
        function toArrayReducer(arr, item, index) {
          if (index === 0) {
            return [item];
          }
          arr.push(item);
          return arr;
        }
        function toArray() {
          return reduce_1.reduce(toArrayReducer, []);
        }
        exports.toArray = toArray;
      },
      { "./reduce": 443 },
    ],
    478: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function window(windowBoundaries) {
          return function windowOperatorFunction(source) {
            return source.lift(new WindowOperator(windowBoundaries));
          };
        }
        exports.window = window;
        var WindowOperator = (function () {
          function WindowOperator(windowBoundaries) {
            this.windowBoundaries = windowBoundaries;
          }
          WindowOperator.prototype.call = function (subscriber, source) {
            var windowSubscriber = new WindowSubscriber(subscriber);
            var sourceSubscription = source.subscribe(windowSubscriber);
            if (!sourceSubscription.closed) {
              windowSubscriber.add(
                subscribeToResult_1.subscribeToResult(
                  windowSubscriber,
                  this.windowBoundaries
                )
              );
            }
            return sourceSubscription;
          };
          return WindowOperator;
        })();
        var WindowSubscriber = (function (_super) {
          __extends(WindowSubscriber, _super);
          function WindowSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.window = new Subject_1.Subject();
            destination.next(_this.window);
            return _this;
          }
          WindowSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.openWindow();
          };
          WindowSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
          };
          WindowSubscriber.prototype.notifyComplete = function (innerSub) {
            this._complete();
          };
          WindowSubscriber.prototype._next = function (value) {
            this.window.next(value);
          };
          WindowSubscriber.prototype._error = function (err) {
            this.window.error(err);
            this.destination.error(err);
          };
          WindowSubscriber.prototype._complete = function () {
            this.window.complete();
            this.destination.complete();
          };
          WindowSubscriber.prototype._unsubscribe = function () {
            this.window = null;
          };
          WindowSubscriber.prototype.openWindow = function () {
            var prevWindow = this.window;
            if (prevWindow) {
              prevWindow.complete();
            }
            var destination = this.destination;
            var newWindow = (this.window = new Subject_1.Subject());
            destination.next(newWindow);
          };
          return WindowSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../OuterSubscriber": 341,
        "../Subject": 344,
        "../util/subscribeToResult": 544,
      },
    ],
    479: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var Subject_1 = require("../Subject");
        function windowCount(windowSize, startWindowEvery) {
          if (startWindowEvery === void 0) {
            startWindowEvery = 0;
          }
          return function windowCountOperatorFunction(source) {
            return source.lift(
              new WindowCountOperator(windowSize, startWindowEvery)
            );
          };
        }
        exports.windowCount = windowCount;
        var WindowCountOperator = (function () {
          function WindowCountOperator(windowSize, startWindowEvery) {
            this.windowSize = windowSize;
            this.startWindowEvery = startWindowEvery;
          }
          WindowCountOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new WindowCountSubscriber(
                subscriber,
                this.windowSize,
                this.startWindowEvery
              )
            );
          };
          return WindowCountOperator;
        })();
        var WindowCountSubscriber = (function (_super) {
          __extends(WindowCountSubscriber, _super);
          function WindowCountSubscriber(
            destination,
            windowSize,
            startWindowEvery
          ) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.windowSize = windowSize;
            _this.startWindowEvery = startWindowEvery;
            _this.windows = [new Subject_1.Subject()];
            _this.count = 0;
            destination.next(_this.windows[0]);
            return _this;
          }
          WindowCountSubscriber.prototype._next = function (value) {
            var startWindowEvery =
              this.startWindowEvery > 0
                ? this.startWindowEvery
                : this.windowSize;
            var destination = this.destination;
            var windowSize = this.windowSize;
            var windows = this.windows;
            var len = windows.length;
            for (var i = 0; i < len && !this.closed; i++) {
              windows[i].next(value);
            }
            var c = this.count - windowSize + 1;
            if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
              windows.shift().complete();
            }
            if (++this.count % startWindowEvery === 0 && !this.closed) {
              var window_1 = new Subject_1.Subject();
              windows.push(window_1);
              destination.next(window_1);
            }
          };
          WindowCountSubscriber.prototype._error = function (err) {
            var windows = this.windows;
            if (windows) {
              while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
              }
            }
            this.destination.error(err);
          };
          WindowCountSubscriber.prototype._complete = function () {
            var windows = this.windows;
            if (windows) {
              while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
              }
            }
            this.destination.complete();
          };
          WindowCountSubscriber.prototype._unsubscribe = function () {
            this.count = 0;
            this.windows = null;
          };
          return WindowCountSubscriber;
        })(Subscriber_1.Subscriber);
      },
      { "../Subject": 344, "../Subscriber": 346 },
    ],
    480: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var async_1 = require("../scheduler/async");
        var Subscriber_1 = require("../Subscriber");
        var isNumeric_1 = require("../util/isNumeric");
        var isScheduler_1 = require("../util/isScheduler");
        function windowTime(windowTimeSpan) {
          var scheduler = async_1.async;
          var windowCreationInterval = null;
          var maxWindowSize = Number.POSITIVE_INFINITY;
          if (isScheduler_1.isScheduler(arguments[3])) {
            scheduler = arguments[3];
          }
          if (isScheduler_1.isScheduler(arguments[2])) {
            scheduler = arguments[2];
          } else if (isNumeric_1.isNumeric(arguments[2])) {
            maxWindowSize = arguments[2];
          }
          if (isScheduler_1.isScheduler(arguments[1])) {
            scheduler = arguments[1];
          } else if (isNumeric_1.isNumeric(arguments[1])) {
            windowCreationInterval = arguments[1];
          }
          return function windowTimeOperatorFunction(source) {
            return source.lift(
              new WindowTimeOperator(
                windowTimeSpan,
                windowCreationInterval,
                maxWindowSize,
                scheduler
              )
            );
          };
        }
        exports.windowTime = windowTime;
        var WindowTimeOperator = (function () {
          function WindowTimeOperator(
            windowTimeSpan,
            windowCreationInterval,
            maxWindowSize,
            scheduler
          ) {
            this.windowTimeSpan = windowTimeSpan;
            this.windowCreationInterval = windowCreationInterval;
            this.maxWindowSize = maxWindowSize;
            this.scheduler = scheduler;
          }
          WindowTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new WindowTimeSubscriber(
                subscriber,
                this.windowTimeSpan,
                this.windowCreationInterval,
                this.maxWindowSize,
                this.scheduler
              )
            );
          };
          return WindowTimeOperator;
        })();
        var CountedSubject = (function (_super) {
          __extends(CountedSubject, _super);
          function CountedSubject() {
            var _this =
              (_super !== null && _super.apply(this, arguments)) || this;
            _this._numberOfNextedValues = 0;
            return _this;
          }
          CountedSubject.prototype.next = function (value) {
            this._numberOfNextedValues++;
            _super.prototype.next.call(this, value);
          };
          Object.defineProperty(
            CountedSubject.prototype,
            "numberOfNextedValues",
            {
              get: function () {
                return this._numberOfNextedValues;
              },
              enumerable: true,
              configurable: true,
            }
          );
          return CountedSubject;
        })(Subject_1.Subject);
        var WindowTimeSubscriber = (function (_super) {
          __extends(WindowTimeSubscriber, _super);
          function WindowTimeSubscriber(
            destination,
            windowTimeSpan,
            windowCreationInterval,
            maxWindowSize,
            scheduler
          ) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.windowTimeSpan = windowTimeSpan;
            _this.windowCreationInterval = windowCreationInterval;
            _this.maxWindowSize = maxWindowSize;
            _this.scheduler = scheduler;
            _this.windows = [];
            var window = _this.openWindow();
            if (
              windowCreationInterval !== null &&
              windowCreationInterval >= 0
            ) {
              var closeState = {
                subscriber: _this,
                window: window,
                context: null,
              };
              var creationState = {
                windowTimeSpan: windowTimeSpan,
                windowCreationInterval: windowCreationInterval,
                subscriber: _this,
                scheduler: scheduler,
              };
              _this.add(
                scheduler.schedule(
                  dispatchWindowClose,
                  windowTimeSpan,
                  closeState
                )
              );
              _this.add(
                scheduler.schedule(
                  dispatchWindowCreation,
                  windowCreationInterval,
                  creationState
                )
              );
            } else {
              var timeSpanOnlyState = {
                subscriber: _this,
                window: window,
                windowTimeSpan: windowTimeSpan,
              };
              _this.add(
                scheduler.schedule(
                  dispatchWindowTimeSpanOnly,
                  windowTimeSpan,
                  timeSpanOnlyState
                )
              );
            }
            return _this;
          }
          WindowTimeSubscriber.prototype._next = function (value) {
            var windows = this.windows;
            var len = windows.length;
            for (var i = 0; i < len; i++) {
              var window_1 = windows[i];
              if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                  this.closeWindow(window_1);
                }
              }
            }
          };
          WindowTimeSubscriber.prototype._error = function (err) {
            var windows = this.windows;
            while (windows.length > 0) {
              windows.shift().error(err);
            }
            this.destination.error(err);
          };
          WindowTimeSubscriber.prototype._complete = function () {
            var windows = this.windows;
            while (windows.length > 0) {
              var window_2 = windows.shift();
              if (!window_2.closed) {
                window_2.complete();
              }
            }
            this.destination.complete();
          };
          WindowTimeSubscriber.prototype.openWindow = function () {
            var window = new CountedSubject();
            this.windows.push(window);
            var destination = this.destination;
            destination.next(window);
            return window;
          };
          WindowTimeSubscriber.prototype.closeWindow = function (window) {
            window.complete();
            var windows = this.windows;
            windows.splice(windows.indexOf(window), 1);
          };
          return WindowTimeSubscriber;
        })(Subscriber_1.Subscriber);
        function dispatchWindowTimeSpanOnly(state) {
          var subscriber = state.subscriber,
            windowTimeSpan = state.windowTimeSpan,
            window = state.window;
          if (window) {
            subscriber.closeWindow(window);
          }
          state.window = subscriber.openWindow();
          this.schedule(state, windowTimeSpan);
        }
        function dispatchWindowCreation(state) {
          var windowTimeSpan = state.windowTimeSpan,
            subscriber = state.subscriber,
            scheduler = state.scheduler,
            windowCreationInterval = state.windowCreationInterval;
          var window = subscriber.openWindow();
          var action = this;
          var context = { action: action, subscription: null };
          var timeSpanState = {
            subscriber: subscriber,
            window: window,
            context: context,
          };
          context.subscription = scheduler.schedule(
            dispatchWindowClose,
            windowTimeSpan,
            timeSpanState
          );
          action.add(context.subscription);
          action.schedule(state, windowCreationInterval);
        }
        function dispatchWindowClose(state) {
          var subscriber = state.subscriber,
            window = state.window,
            context = state.context;
          if (context && context.action && context.subscription) {
            context.action.remove(context.subscription);
          }
          subscriber.closeWindow(window);
        }
      },
      {
        "../Subject": 344,
        "../Subscriber": 346,
        "../scheduler/async": 503,
        "../util/isNumeric": 530,
        "../util/isScheduler": 534,
      },
    ],
    481: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var Subscription_1 = require("../Subscription");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function windowToggle(openings, closingSelector) {
          return function (source) {
            return source.lift(
              new WindowToggleOperator(openings, closingSelector)
            );
          };
        }
        exports.windowToggle = windowToggle;
        var WindowToggleOperator = (function () {
          function WindowToggleOperator(openings, closingSelector) {
            this.openings = openings;
            this.closingSelector = closingSelector;
          }
          WindowToggleOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new WindowToggleSubscriber(
                subscriber,
                this.openings,
                this.closingSelector
              )
            );
          };
          return WindowToggleOperator;
        })();
        var WindowToggleSubscriber = (function (_super) {
          __extends(WindowToggleSubscriber, _super);
          function WindowToggleSubscriber(
            destination,
            openings,
            closingSelector
          ) {
            var _this = _super.call(this, destination) || this;
            _this.openings = openings;
            _this.closingSelector = closingSelector;
            _this.contexts = [];
            _this.add(
              (_this.openSubscription = subscribeToResult_1.subscribeToResult(
                _this,
                openings,
                openings
              ))
            );
            return _this;
          }
          WindowToggleSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            if (contexts) {
              var len = contexts.length;
              for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
              }
            }
          };
          WindowToggleSubscriber.prototype._error = function (err) {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
              var len = contexts.length;
              var index = -1;
              while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
              }
            }
            _super.prototype._error.call(this, err);
          };
          WindowToggleSubscriber.prototype._complete = function () {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
              var len = contexts.length;
              var index = -1;
              while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
              }
            }
            _super.prototype._complete.call(this);
          };
          WindowToggleSubscriber.prototype._unsubscribe = function () {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
              var len = contexts.length;
              var index = -1;
              while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
              }
            }
          };
          WindowToggleSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            if (outerValue === this.openings) {
              var closingNotifier = void 0;
              try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
              } catch (e) {
                return this.error(e);
              }
              var window_1 = new Subject_1.Subject();
              var subscription = new Subscription_1.Subscription();
              var context_4 = { window: window_1, subscription: subscription };
              this.contexts.push(context_4);
              var innerSubscription = subscribeToResult_1.subscribeToResult(
                this,
                closingNotifier,
                context_4
              );
              if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
              } else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
              }
              this.destination.next(window_1);
            } else {
              this.closeWindow(this.contexts.indexOf(outerValue));
            }
          };
          WindowToggleSubscriber.prototype.notifyError = function (err) {
            this.error(err);
          };
          WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
            if (inner !== this.openSubscription) {
              this.closeWindow(this.contexts.indexOf(inner.context));
            }
          };
          WindowToggleSubscriber.prototype.closeWindow = function (index) {
            if (index === -1) {
              return;
            }
            var contexts = this.contexts;
            var context = contexts[index];
            var window = context.window,
              subscription = context.subscription;
            contexts.splice(index, 1);
            window.complete();
            subscription.unsubscribe();
          };
          return WindowToggleSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../OuterSubscriber": 341,
        "../Subject": 344,
        "../Subscription": 347,
        "../util/subscribeToResult": 544,
      },
    ],
    482: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function windowWhen(closingSelector) {
          return function windowWhenOperatorFunction(source) {
            return source.lift(new WindowOperator(closingSelector));
          };
        }
        exports.windowWhen = windowWhen;
        var WindowOperator = (function () {
          function WindowOperator(closingSelector) {
            this.closingSelector = closingSelector;
          }
          WindowOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(
              new WindowSubscriber(subscriber, this.closingSelector)
            );
          };
          return WindowOperator;
        })();
        var WindowSubscriber = (function (_super) {
          __extends(WindowSubscriber, _super);
          function WindowSubscriber(destination, closingSelector) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.closingSelector = closingSelector;
            _this.openWindow();
            return _this;
          }
          WindowSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.openWindow(innerSub);
          };
          WindowSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
          };
          WindowSubscriber.prototype.notifyComplete = function (innerSub) {
            this.openWindow(innerSub);
          };
          WindowSubscriber.prototype._next = function (value) {
            this.window.next(value);
          };
          WindowSubscriber.prototype._error = function (err) {
            this.window.error(err);
            this.destination.error(err);
            this.unsubscribeClosingNotification();
          };
          WindowSubscriber.prototype._complete = function () {
            this.window.complete();
            this.destination.complete();
            this.unsubscribeClosingNotification();
          };
          WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
            if (this.closingNotification) {
              this.closingNotification.unsubscribe();
            }
          };
          WindowSubscriber.prototype.openWindow = function (innerSub) {
            if (innerSub === void 0) {
              innerSub = null;
            }
            if (innerSub) {
              this.remove(innerSub);
              innerSub.unsubscribe();
            }
            var prevWindow = this.window;
            if (prevWindow) {
              prevWindow.complete();
            }
            var window = (this.window = new Subject_1.Subject());
            this.destination.next(window);
            var closingNotifier;
            try {
              var closingSelector = this.closingSelector;
              closingNotifier = closingSelector();
            } catch (e) {
              this.destination.error(e);
              this.window.error(e);
              return;
            }
            this.add(
              (this.closingNotification = subscribeToResult_1.subscribeToResult(
                this,
                closingNotifier
              ))
            );
          };
          return WindowSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      {
        "../OuterSubscriber": 341,
        "../Subject": 344,
        "../util/subscribeToResult": 544,
      },
    ],
    483: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var OuterSubscriber_1 = require("../OuterSubscriber");
        var subscribeToResult_1 = require("../util/subscribeToResult");
        function withLatestFrom() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return function (source) {
            var project;
            if (typeof args[args.length - 1] === "function") {
              project = args.pop();
            }
            var observables = args;
            return source.lift(
              new WithLatestFromOperator(observables, project)
            );
          };
        }
        exports.withLatestFrom = withLatestFrom;
        var WithLatestFromOperator = (function () {
          function WithLatestFromOperator(observables, project) {
            this.observables = observables;
            this.project = project;
          }
          WithLatestFromOperator.prototype.call = function (
            subscriber,
            source
          ) {
            return source.subscribe(
              new WithLatestFromSubscriber(
                subscriber,
                this.observables,
                this.project
              )
            );
          };
          return WithLatestFromOperator;
        })();
        var WithLatestFromSubscriber = (function (_super) {
          __extends(WithLatestFromSubscriber, _super);
          function WithLatestFromSubscriber(destination, observables, project) {
            var _this = _super.call(this, destination) || this;
            _this.observables = observables;
            _this.project = project;
            _this.toRespond = [];
            var len = observables.length;
            _this.values = new Array(len);
            for (var i = 0; i < len; i++) {
              _this.toRespond.push(i);
            }
            for (var i = 0; i < len; i++) {
              var observable = observables[i];
              _this.add(
                subscribeToResult_1.subscribeToResult(
                  _this,
                  observable,
                  observable,
                  i
                )
              );
            }
            return _this;
          }
          WithLatestFromSubscriber.prototype.notifyNext = function (
            outerValue,
            innerValue,
            outerIndex,
            innerIndex,
            innerSub
          ) {
            this.values[outerIndex] = innerValue;
            var toRespond = this.toRespond;
            if (toRespond.length > 0) {
              var found = toRespond.indexOf(outerIndex);
              if (found !== -1) {
                toRespond.splice(found, 1);
              }
            }
          };
          WithLatestFromSubscriber.prototype.notifyComplete = function () {};
          WithLatestFromSubscriber.prototype._next = function (value) {
            if (this.toRespond.length === 0) {
              var args = [value].concat(this.values);
              if (this.project) {
                this._tryProject(args);
              } else {
                this.destination.next(args);
              }
            }
          };
          WithLatestFromSubscriber.prototype._tryProject = function (args) {
            var result;
            try {
              result = this.project.apply(this, args);
            } catch (err) {
              this.destination.error(err);
              return;
            }
            this.destination.next(result);
          };
          return WithLatestFromSubscriber;
        })(OuterSubscriber_1.OuterSubscriber);
      },
      { "../OuterSubscriber": 341, "../util/subscribeToResult": 544 },
    ],
    484: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var zip_1 = require("../observable/zip");
        function zip() {
          var observables = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }
          return function zipOperatorFunction(source) {
            return source.lift.call(
              zip_1.zip.apply(void 0, [source].concat(observables))
            );
          };
        }
        exports.zip = zip;
      },
      { "../observable/zip": 382 },
    ],
    485: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var zip_1 = require("../observable/zip");
        function zipAll(project) {
          return function (source) {
            return source.lift(new zip_1.ZipOperator(project));
          };
        }
        exports.zipAll = zipAll;
      },
      { "../observable/zip": 382 },
    ],
    486: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        function scheduleArray(input, scheduler) {
          return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            var i = 0;
            sub.add(
              scheduler.schedule(function () {
                if (i === input.length) {
                  subscriber.complete();
                  return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                  sub.add(this.schedule());
                }
              })
            );
            return sub;
          });
        }
        exports.scheduleArray = scheduleArray;
      },
      { "../Observable": 339, "../Subscription": 347 },
    ],
    487: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        var iterator_1 = require("../symbol/iterator");
        function scheduleIterable(input, scheduler) {
          if (!input) {
            throw new Error("Iterable cannot be null");
          }
          return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            var iterator;
            sub.add(function () {
              if (iterator && typeof iterator.return === "function") {
                iterator.return();
              }
            });
            sub.add(
              scheduler.schedule(function () {
                iterator = input[iterator_1.iterator]();
                sub.add(
                  scheduler.schedule(function () {
                    if (subscriber.closed) {
                      return;
                    }
                    var value;
                    var done;
                    try {
                      var result = iterator.next();
                      value = result.value;
                      done = result.done;
                    } catch (err) {
                      subscriber.error(err);
                      return;
                    }
                    if (done) {
                      subscriber.complete();
                    } else {
                      subscriber.next(value);
                      this.schedule();
                    }
                  })
                );
              })
            );
            return sub;
          });
        }
        exports.scheduleIterable = scheduleIterable;
      },
      {
        "../Observable": 339,
        "../Subscription": 347,
        "../symbol/iterator": 505,
      },
    ],
    488: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        var observable_1 = require("../symbol/observable");
        function scheduleObservable(input, scheduler) {
          return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            sub.add(
              scheduler.schedule(function () {
                var observable = input[observable_1.observable]();
                sub.add(
                  observable.subscribe({
                    next: function (value) {
                      sub.add(
                        scheduler.schedule(function () {
                          return subscriber.next(value);
                        })
                      );
                    },
                    error: function (err) {
                      sub.add(
                        scheduler.schedule(function () {
                          return subscriber.error(err);
                        })
                      );
                    },
                    complete: function () {
                      sub.add(
                        scheduler.schedule(function () {
                          return subscriber.complete();
                        })
                      );
                    },
                  })
                );
              })
            );
            return sub;
          });
        }
        exports.scheduleObservable = scheduleObservable;
      },
      {
        "../Observable": 339,
        "../Subscription": 347,
        "../symbol/observable": 506,
      },
    ],
    489: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        function schedulePromise(input, scheduler) {
          return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            sub.add(
              scheduler.schedule(function () {
                return input.then(
                  function (value) {
                    sub.add(
                      scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(
                          scheduler.schedule(function () {
                            return subscriber.complete();
                          })
                        );
                      })
                    );
                  },
                  function (err) {
                    sub.add(
                      scheduler.schedule(function () {
                        return subscriber.error(err);
                      })
                    );
                  }
                );
              })
            );
            return sub;
          });
        }
        exports.schedulePromise = schedulePromise;
      },
      { "../Observable": 339, "../Subscription": 347 },
    ],
    490: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var scheduleObservable_1 = require("./scheduleObservable");
        var schedulePromise_1 = require("./schedulePromise");
        var scheduleArray_1 = require("./scheduleArray");
        var scheduleIterable_1 = require("./scheduleIterable");
        var isInteropObservable_1 = require("../util/isInteropObservable");
        var isPromise_1 = require("../util/isPromise");
        var isArrayLike_1 = require("../util/isArrayLike");
        var isIterable_1 = require("../util/isIterable");
        function scheduled(input, scheduler) {
          if (input != null) {
            if (isInteropObservable_1.isInteropObservable(input)) {
              return scheduleObservable_1.scheduleObservable(input, scheduler);
            } else if (isPromise_1.isPromise(input)) {
              return schedulePromise_1.schedulePromise(input, scheduler);
            } else if (isArrayLike_1.isArrayLike(input)) {
              return scheduleArray_1.scheduleArray(input, scheduler);
            } else if (
              isIterable_1.isIterable(input) ||
              typeof input === "string"
            ) {
              return scheduleIterable_1.scheduleIterable(input, scheduler);
            }
          }
          throw new TypeError(
            ((input !== null && typeof input) || input) + " is not observable"
          );
        }
        exports.scheduled = scheduled;
      },
      {
        "../util/isArrayLike": 525,
        "../util/isInteropObservable": 528,
        "../util/isIterable": 529,
        "../util/isPromise": 533,
        "./scheduleArray": 486,
        "./scheduleIterable": 487,
        "./scheduleObservable": 488,
        "./schedulePromise": 489,
      },
    ],
    491: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscription_1 = require("../Subscription");
        var Action = (function (_super) {
          __extends(Action, _super);
          function Action(scheduler, work) {
            return _super.call(this) || this;
          }
          Action.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
              delay = 0;
            }
            return this;
          };
          return Action;
        })(Subscription_1.Subscription);
        exports.Action = Action;
      },
      { "../Subscription": 347 },
    ],
    492: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncAction_1 = require("./AsyncAction");
        var AnimationFrameAction = (function (_super) {
          __extends(AnimationFrameAction, _super);
          function AnimationFrameAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
          }
          AnimationFrameAction.prototype.requestAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            if (delay !== null && delay > 0) {
              return _super.prototype.requestAsyncId.call(
                this,
                scheduler,
                id,
                delay
              );
            }
            scheduler.actions.push(this);
            return (
              scheduler.scheduled ||
              (scheduler.scheduled = requestAnimationFrame(function () {
                return scheduler.flush(null);
              }))
            );
          };
          AnimationFrameAction.prototype.recycleAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            if (
              (delay !== null && delay > 0) ||
              (delay === null && this.delay > 0)
            ) {
              return _super.prototype.recycleAsyncId.call(
                this,
                scheduler,
                id,
                delay
              );
            }
            if (scheduler.actions.length === 0) {
              cancelAnimationFrame(id);
              scheduler.scheduled = undefined;
            }
            return undefined;
          };
          return AnimationFrameAction;
        })(AsyncAction_1.AsyncAction);
        exports.AnimationFrameAction = AnimationFrameAction;
      },
      { "./AsyncAction": 496 },
    ],
    493: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncScheduler_1 = require("./AsyncScheduler");
        var AnimationFrameScheduler = (function (_super) {
          __extends(AnimationFrameScheduler, _super);
          function AnimationFrameScheduler() {
            return (_super !== null && _super.apply(this, arguments)) || this;
          }
          AnimationFrameScheduler.prototype.flush = function (action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
              if ((error = action.execute(action.state, action.delay))) {
                break;
              }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
              while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
              }
              throw error;
            }
          };
          return AnimationFrameScheduler;
        })(AsyncScheduler_1.AsyncScheduler);
        exports.AnimationFrameScheduler = AnimationFrameScheduler;
      },
      { "./AsyncScheduler": 497 },
    ],
    494: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Immediate_1 = require("../util/Immediate");
        var AsyncAction_1 = require("./AsyncAction");
        var AsapAction = (function (_super) {
          __extends(AsapAction, _super);
          function AsapAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
          }
          AsapAction.prototype.requestAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            if (delay !== null && delay > 0) {
              return _super.prototype.requestAsyncId.call(
                this,
                scheduler,
                id,
                delay
              );
            }
            scheduler.actions.push(this);
            return (
              scheduler.scheduled ||
              (scheduler.scheduled = Immediate_1.Immediate.setImmediate(
                scheduler.flush.bind(scheduler, null)
              ))
            );
          };
          AsapAction.prototype.recycleAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            if (
              (delay !== null && delay > 0) ||
              (delay === null && this.delay > 0)
            ) {
              return _super.prototype.recycleAsyncId.call(
                this,
                scheduler,
                id,
                delay
              );
            }
            if (scheduler.actions.length === 0) {
              Immediate_1.Immediate.clearImmediate(id);
              scheduler.scheduled = undefined;
            }
            return undefined;
          };
          return AsapAction;
        })(AsyncAction_1.AsyncAction);
        exports.AsapAction = AsapAction;
      },
      { "../util/Immediate": 515, "./AsyncAction": 496 },
    ],
    495: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncScheduler_1 = require("./AsyncScheduler");
        var AsapScheduler = (function (_super) {
          __extends(AsapScheduler, _super);
          function AsapScheduler() {
            return (_super !== null && _super.apply(this, arguments)) || this;
          }
          AsapScheduler.prototype.flush = function (action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
              if ((error = action.execute(action.state, action.delay))) {
                break;
              }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
              while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
              }
              throw error;
            }
          };
          return AsapScheduler;
        })(AsyncScheduler_1.AsyncScheduler);
        exports.AsapScheduler = AsapScheduler;
      },
      { "./AsyncScheduler": 497 },
    ],
    496: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Action_1 = require("./Action");
        var AsyncAction = (function (_super) {
          __extends(AsyncAction, _super);
          function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
          }
          AsyncAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
              delay = 0;
            }
            if (this.closed) {
              return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
            return this;
          };
          AsyncAction.prototype.requestAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            return setInterval(scheduler.flush.bind(scheduler, this), delay);
          };
          AsyncAction.prototype.recycleAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            if (
              delay !== null &&
              this.delay === delay &&
              this.pending === false
            ) {
              return id;
            }
            clearInterval(id);
            return undefined;
          };
          AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
              return new Error("executing a cancelled action");
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
              return error;
            } else if (this.pending === false && this.id != null) {
              this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
          };
          AsyncAction.prototype._execute = function (state, delay) {
            var errored = false;
            var errorValue = undefined;
            try {
              this.work(state);
            } catch (e) {
              errored = true;
              errorValue = (!!e && e) || new Error(e);
            }
            if (errored) {
              this.unsubscribe();
              return errorValue;
            }
          };
          AsyncAction.prototype._unsubscribe = function () {
            var id = this.id;
            var scheduler = this.scheduler;
            var actions = scheduler.actions;
            var index = actions.indexOf(this);
            this.work = null;
            this.state = null;
            this.pending = false;
            this.scheduler = null;
            if (index !== -1) {
              actions.splice(index, 1);
            }
            if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
          };
          return AsyncAction;
        })(Action_1.Action);
        exports.AsyncAction = AsyncAction;
      },
      { "./Action": 491 },
    ],
    497: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Scheduler_1 = require("../Scheduler");
        var AsyncScheduler = (function (_super) {
          __extends(AsyncScheduler, _super);
          function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) {
              now = Scheduler_1.Scheduler.now;
            }
            var _this =
              _super.call(this, SchedulerAction, function () {
                if (
                  AsyncScheduler.delegate &&
                  AsyncScheduler.delegate !== _this
                ) {
                  return AsyncScheduler.delegate.now();
                } else {
                  return now();
                }
              }) || this;
            _this.actions = [];
            _this.active = false;
            _this.scheduled = undefined;
            return _this;
          }
          AsyncScheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) {
              delay = 0;
            }
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
              return AsyncScheduler.delegate.schedule(work, delay, state);
            } else {
              return _super.prototype.schedule.call(this, work, delay, state);
            }
          };
          AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this.active) {
              actions.push(action);
              return;
            }
            var error;
            this.active = true;
            do {
              if ((error = action.execute(action.state, action.delay))) {
                break;
              }
            } while ((action = actions.shift()));
            this.active = false;
            if (error) {
              while ((action = actions.shift())) {
                action.unsubscribe();
              }
              throw error;
            }
          };
          return AsyncScheduler;
        })(Scheduler_1.Scheduler);
        exports.AsyncScheduler = AsyncScheduler;
      },
      { "../Scheduler": 343 },
    ],
    498: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncAction_1 = require("./AsyncAction");
        var QueueAction = (function (_super) {
          __extends(QueueAction, _super);
          function QueueAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
          }
          QueueAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
              delay = 0;
            }
            if (delay > 0) {
              return _super.prototype.schedule.call(this, state, delay);
            }
            this.delay = delay;
            this.state = state;
            this.scheduler.flush(this);
            return this;
          };
          QueueAction.prototype.execute = function (state, delay) {
            return delay > 0 || this.closed
              ? _super.prototype.execute.call(this, state, delay)
              : this._execute(state, delay);
          };
          QueueAction.prototype.requestAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            if (
              (delay !== null && delay > 0) ||
              (delay === null && this.delay > 0)
            ) {
              return _super.prototype.requestAsyncId.call(
                this,
                scheduler,
                id,
                delay
              );
            }
            return scheduler.flush(this);
          };
          return QueueAction;
        })(AsyncAction_1.AsyncAction);
        exports.QueueAction = QueueAction;
      },
      { "./AsyncAction": 496 },
    ],
    499: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncScheduler_1 = require("./AsyncScheduler");
        var QueueScheduler = (function (_super) {
          __extends(QueueScheduler, _super);
          function QueueScheduler() {
            return (_super !== null && _super.apply(this, arguments)) || this;
          }
          return QueueScheduler;
        })(AsyncScheduler_1.AsyncScheduler);
        exports.QueueScheduler = QueueScheduler;
      },
      { "./AsyncScheduler": 497 },
    ],
    500: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncAction_1 = require("./AsyncAction");
        var AsyncScheduler_1 = require("./AsyncScheduler");
        var VirtualTimeScheduler = (function (_super) {
          __extends(VirtualTimeScheduler, _super);
          function VirtualTimeScheduler(SchedulerAction, maxFrames) {
            if (SchedulerAction === void 0) {
              SchedulerAction = VirtualAction;
            }
            if (maxFrames === void 0) {
              maxFrames = Number.POSITIVE_INFINITY;
            }
            var _this =
              _super.call(this, SchedulerAction, function () {
                return _this.frame;
              }) || this;
            _this.maxFrames = maxFrames;
            _this.frame = 0;
            _this.index = -1;
            return _this;
          }
          VirtualTimeScheduler.prototype.flush = function () {
            var _a = this,
              actions = _a.actions,
              maxFrames = _a.maxFrames;
            var error, action;
            while ((action = actions[0]) && action.delay <= maxFrames) {
              actions.shift();
              this.frame = action.delay;
              if ((error = action.execute(action.state, action.delay))) {
                break;
              }
            }
            if (error) {
              while ((action = actions.shift())) {
                action.unsubscribe();
              }
              throw error;
            }
          };
          VirtualTimeScheduler.frameTimeFactor = 10;
          return VirtualTimeScheduler;
        })(AsyncScheduler_1.AsyncScheduler);
        exports.VirtualTimeScheduler = VirtualTimeScheduler;
        var VirtualAction = (function (_super) {
          __extends(VirtualAction, _super);
          function VirtualAction(scheduler, work, index) {
            if (index === void 0) {
              index = scheduler.index += 1;
            }
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.index = index;
            _this.active = true;
            _this.index = scheduler.index = index;
            return _this;
          }
          VirtualAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
              delay = 0;
            }
            if (!this.id) {
              return _super.prototype.schedule.call(this, state, delay);
            }
            this.active = false;
            var action = new VirtualAction(this.scheduler, this.work);
            this.add(action);
            return action.schedule(state, delay);
          };
          VirtualAction.prototype.requestAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            this.delay = scheduler.frame + delay;
            var actions = scheduler.actions;
            actions.push(this);
            actions.sort(VirtualAction.sortActions);
            return true;
          };
          VirtualAction.prototype.recycleAsyncId = function (
            scheduler,
            id,
            delay
          ) {
            if (delay === void 0) {
              delay = 0;
            }
            return undefined;
          };
          VirtualAction.prototype._execute = function (state, delay) {
            if (this.active === true) {
              return _super.prototype._execute.call(this, state, delay);
            }
          };
          VirtualAction.sortActions = function (a, b) {
            if (a.delay === b.delay) {
              if (a.index === b.index) {
                return 0;
              } else if (a.index > b.index) {
                return 1;
              } else {
                return -1;
              }
            } else if (a.delay > b.delay) {
              return 1;
            } else {
              return -1;
            }
          };
          return VirtualAction;
        })(AsyncAction_1.AsyncAction);
        exports.VirtualAction = VirtualAction;
      },
      { "./AsyncAction": 496, "./AsyncScheduler": 497 },
    ],
    501: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var AnimationFrameAction_1 = require("./AnimationFrameAction");
        var AnimationFrameScheduler_1 = require("./AnimationFrameScheduler");
        exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(
          AnimationFrameAction_1.AnimationFrameAction
        );
      },
      { "./AnimationFrameAction": 492, "./AnimationFrameScheduler": 493 },
    ],
    502: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsapAction_1 = require("./AsapAction");
        var AsapScheduler_1 = require("./AsapScheduler");
        exports.asap = new AsapScheduler_1.AsapScheduler(
          AsapAction_1.AsapAction
        );
      },
      { "./AsapAction": 494, "./AsapScheduler": 495 },
    ],
    503: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var AsyncAction_1 = require("./AsyncAction");
        var AsyncScheduler_1 = require("./AsyncScheduler");
        exports.async = new AsyncScheduler_1.AsyncScheduler(
          AsyncAction_1.AsyncAction
        );
      },
      { "./AsyncAction": 496, "./AsyncScheduler": 497 },
    ],
    504: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var QueueAction_1 = require("./QueueAction");
        var QueueScheduler_1 = require("./QueueScheduler");
        exports.queue = new QueueScheduler_1.QueueScheduler(
          QueueAction_1.QueueAction
        );
      },
      { "./QueueAction": 498, "./QueueScheduler": 499 },
    ],
    505: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function getSymbolIterator() {
          if (typeof Symbol !== "function" || !Symbol.iterator) {
            return "@@iterator";
          }
          return Symbol.iterator;
        }
        exports.getSymbolIterator = getSymbolIterator;
        exports.iterator = getSymbolIterator();
        exports.$$iterator = exports.iterator;
      },
      {},
    ],
    506: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.observable = (function () {
          return (
            (typeof Symbol === "function" && Symbol.observable) ||
            "@@observable"
          );
        })();
      },
      {},
    ],
    507: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.rxSubscriber = (function () {
          return typeof Symbol === "function"
            ? Symbol("rxSubscriber")
            : "@@rxSubscriber_" + Math.random();
        })();
        exports.$$rxSubscriber = exports.rxSubscriber;
      },
      {},
    ],
    508: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Subscription_1 = require("../Subscription");
        var SubscriptionLoggable_1 = require("./SubscriptionLoggable");
        var applyMixins_1 = require("../util/applyMixins");
        var ColdObservable = (function (_super) {
          __extends(ColdObservable, _super);
          function ColdObservable(messages, scheduler) {
            var _this =
              _super.call(this, function (subscriber) {
                var observable = this;
                var index = observable.logSubscribedFrame();
                var subscription = new Subscription_1.Subscription();
                subscription.add(
                  new Subscription_1.Subscription(function () {
                    observable.logUnsubscribedFrame(index);
                  })
                );
                observable.scheduleMessages(subscriber);
                return subscription;
              }) || this;
            _this.messages = messages;
            _this.subscriptions = [];
            _this.scheduler = scheduler;
            return _this;
          }
          ColdObservable.prototype.scheduleMessages = function (subscriber) {
            var messagesLength = this.messages.length;
            for (var i = 0; i < messagesLength; i++) {
              var message = this.messages[i];
              subscriber.add(
                this.scheduler.schedule(
                  function (_a) {
                    var message = _a.message,
                      subscriber = _a.subscriber;
                    message.notification.observe(subscriber);
                  },
                  message.frame,
                  { message: message, subscriber: subscriber }
                )
              );
            }
          };
          return ColdObservable;
        })(Observable_1.Observable);
        exports.ColdObservable = ColdObservable;
        applyMixins_1.applyMixins(ColdObservable, [
          SubscriptionLoggable_1.SubscriptionLoggable,
        ]);
      },
      {
        "../Observable": 339,
        "../Subscription": 347,
        "../util/applyMixins": 519,
        "./SubscriptionLoggable": 511,
      },
    ],
    509: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subject_1 = require("../Subject");
        var Subscription_1 = require("../Subscription");
        var SubscriptionLoggable_1 = require("./SubscriptionLoggable");
        var applyMixins_1 = require("../util/applyMixins");
        var HotObservable = (function (_super) {
          __extends(HotObservable, _super);
          function HotObservable(messages, scheduler) {
            var _this = _super.call(this) || this;
            _this.messages = messages;
            _this.subscriptions = [];
            _this.scheduler = scheduler;
            return _this;
          }
          HotObservable.prototype._subscribe = function (subscriber) {
            var subject = this;
            var index = subject.logSubscribedFrame();
            var subscription = new Subscription_1.Subscription();
            subscription.add(
              new Subscription_1.Subscription(function () {
                subject.logUnsubscribedFrame(index);
              })
            );
            subscription.add(
              _super.prototype._subscribe.call(this, subscriber)
            );
            return subscription;
          };
          HotObservable.prototype.setup = function () {
            var subject = this;
            var messagesLength = subject.messages.length;
            for (var i = 0; i < messagesLength; i++) {
              (function () {
                var message = subject.messages[i];
                subject.scheduler.schedule(function () {
                  message.notification.observe(subject);
                }, message.frame);
              })();
            }
          };
          return HotObservable;
        })(Subject_1.Subject);
        exports.HotObservable = HotObservable;
        applyMixins_1.applyMixins(HotObservable, [
          SubscriptionLoggable_1.SubscriptionLoggable,
        ]);
      },
      {
        "../Subject": 344,
        "../Subscription": 347,
        "../util/applyMixins": 519,
        "./SubscriptionLoggable": 511,
      },
    ],
    510: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var SubscriptionLog = (function () {
          function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
            if (unsubscribedFrame === void 0) {
              unsubscribedFrame = Number.POSITIVE_INFINITY;
            }
            this.subscribedFrame = subscribedFrame;
            this.unsubscribedFrame = unsubscribedFrame;
          }
          return SubscriptionLog;
        })();
        exports.SubscriptionLog = SubscriptionLog;
      },
      {},
    ],
    511: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var SubscriptionLog_1 = require("./SubscriptionLog");
        var SubscriptionLoggable = (function () {
          function SubscriptionLoggable() {
            this.subscriptions = [];
          }
          SubscriptionLoggable.prototype.logSubscribedFrame = function () {
            this.subscriptions.push(
              new SubscriptionLog_1.SubscriptionLog(this.scheduler.now())
            );
            return this.subscriptions.length - 1;
          };
          SubscriptionLoggable.prototype.logUnsubscribedFrame = function (
            index
          ) {
            var subscriptionLogs = this.subscriptions;
            var oldSubscriptionLog = subscriptionLogs[index];
            subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(
              oldSubscriptionLog.subscribedFrame,
              this.scheduler.now()
            );
          };
          return SubscriptionLoggable;
        })();
        exports.SubscriptionLoggable = SubscriptionLoggable;
      },
      { "./SubscriptionLog": 510 },
    ],
    512: [
      function (require, module, exports) {
        "use strict";
        var __extends =
          (this && this.__extends) ||
          (function () {
            var extendStatics = function (d, b) {
              extendStatics =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (d, b) {
                    d.__proto__ = b;
                  }) ||
                function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };
              return extendStatics(d, b);
            };
            return function (d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype =
                b === null
                  ? Object.create(b)
                  : ((__.prototype = b.prototype), new __());
            };
          })();
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        var Notification_1 = require("../Notification");
        var ColdObservable_1 = require("./ColdObservable");
        var HotObservable_1 = require("./HotObservable");
        var SubscriptionLog_1 = require("./SubscriptionLog");
        var VirtualTimeScheduler_1 = require("../scheduler/VirtualTimeScheduler");
        var AsyncScheduler_1 = require("../scheduler/AsyncScheduler");
        var defaultMaxFrame = 750;
        var TestScheduler = (function (_super) {
          __extends(TestScheduler, _super);
          function TestScheduler(assertDeepEqual) {
            var _this =
              _super.call(
                this,
                VirtualTimeScheduler_1.VirtualAction,
                defaultMaxFrame
              ) || this;
            _this.assertDeepEqual = assertDeepEqual;
            _this.hotObservables = [];
            _this.coldObservables = [];
            _this.flushTests = [];
            _this.runMode = false;
            return _this;
          }
          TestScheduler.prototype.createTime = function (marbles) {
            var indexOf = marbles.indexOf("|");
            if (indexOf === -1) {
              throw new Error(
                'marble diagram for time should have a completion marker "|"'
              );
            }
            return indexOf * TestScheduler.frameTimeFactor;
          };
          TestScheduler.prototype.createColdObservable = function (
            marbles,
            values,
            error
          ) {
            if (marbles.indexOf("^") !== -1) {
              throw new Error(
                'cold observable cannot have subscription offset "^"'
              );
            }
            if (marbles.indexOf("!") !== -1) {
              throw new Error(
                'cold observable cannot have unsubscription marker "!"'
              );
            }
            var messages = TestScheduler.parseMarbles(
              marbles,
              values,
              error,
              undefined,
              this.runMode
            );
            var cold = new ColdObservable_1.ColdObservable(messages, this);
            this.coldObservables.push(cold);
            return cold;
          };
          TestScheduler.prototype.createHotObservable = function (
            marbles,
            values,
            error
          ) {
            if (marbles.indexOf("!") !== -1) {
              throw new Error(
                'hot observable cannot have unsubscription marker "!"'
              );
            }
            var messages = TestScheduler.parseMarbles(
              marbles,
              values,
              error,
              undefined,
              this.runMode
            );
            var subject = new HotObservable_1.HotObservable(messages, this);
            this.hotObservables.push(subject);
            return subject;
          };
          TestScheduler.prototype.materializeInnerObservable = function (
            observable,
            outerFrame
          ) {
            var _this = this;
            var messages = [];
            observable.subscribe(
              function (value) {
                messages.push({
                  frame: _this.frame - outerFrame,
                  notification: Notification_1.Notification.createNext(value),
                });
              },
              function (err) {
                messages.push({
                  frame: _this.frame - outerFrame,
                  notification: Notification_1.Notification.createError(err),
                });
              },
              function () {
                messages.push({
                  frame: _this.frame - outerFrame,
                  notification: Notification_1.Notification.createComplete(),
                });
              }
            );
            return messages;
          };
          TestScheduler.prototype.expectObservable = function (
            observable,
            subscriptionMarbles
          ) {
            var _this = this;
            if (subscriptionMarbles === void 0) {
              subscriptionMarbles = null;
            }
            var actual = [];
            var flushTest = { actual: actual, ready: false };
            var subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(
              subscriptionMarbles,
              this.runMode
            );
            var subscriptionFrame =
              subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY
                ? 0
                : subscriptionParsed.subscribedFrame;
            var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
            var subscription;
            this.schedule(function () {
              subscription = observable.subscribe(
                function (x) {
                  var value = x;
                  if (x instanceof Observable_1.Observable) {
                    value = _this.materializeInnerObservable(
                      value,
                      _this.frame
                    );
                  }
                  actual.push({
                    frame: _this.frame,
                    notification: Notification_1.Notification.createNext(value),
                  });
                },
                function (err) {
                  actual.push({
                    frame: _this.frame,
                    notification: Notification_1.Notification.createError(err),
                  });
                },
                function () {
                  actual.push({
                    frame: _this.frame,
                    notification: Notification_1.Notification.createComplete(),
                  });
                }
              );
            }, subscriptionFrame);
            if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
              this.schedule(function () {
                return subscription.unsubscribe();
              }, unsubscriptionFrame);
            }
            this.flushTests.push(flushTest);
            var runMode = this.runMode;
            return {
              toBe: function (marbles, values, errorValue) {
                flushTest.ready = true;
                flushTest.expected = TestScheduler.parseMarbles(
                  marbles,
                  values,
                  errorValue,
                  true,
                  runMode
                );
              },
            };
          };
          TestScheduler.prototype.expectSubscriptions = function (
            actualSubscriptionLogs
          ) {
            var flushTest = { actual: actualSubscriptionLogs, ready: false };
            this.flushTests.push(flushTest);
            var runMode = this.runMode;
            return {
              toBe: function (marbles) {
                var marblesArray =
                  typeof marbles === "string" ? [marbles] : marbles;
                flushTest.ready = true;
                flushTest.expected = marblesArray.map(function (marbles) {
                  return TestScheduler.parseMarblesAsSubscriptions(
                    marbles,
                    runMode
                  );
                });
              },
            };
          };
          TestScheduler.prototype.flush = function () {
            var _this = this;
            var hotObservables = this.hotObservables;
            while (hotObservables.length > 0) {
              hotObservables.shift().setup();
            }
            _super.prototype.flush.call(this);
            this.flushTests = this.flushTests.filter(function (test) {
              if (test.ready) {
                _this.assertDeepEqual(test.actual, test.expected);
                return false;
              }
              return true;
            });
          };
          TestScheduler.parseMarblesAsSubscriptions = function (
            marbles,
            runMode
          ) {
            var _this = this;
            if (runMode === void 0) {
              runMode = false;
            }
            if (typeof marbles !== "string") {
              return new SubscriptionLog_1.SubscriptionLog(
                Number.POSITIVE_INFINITY
              );
            }
            var len = marbles.length;
            var groupStart = -1;
            var subscriptionFrame = Number.POSITIVE_INFINITY;
            var unsubscriptionFrame = Number.POSITIVE_INFINITY;
            var frame = 0;
            var _loop_1 = function (i) {
              var nextFrame = frame;
              var advanceFrameBy = function (count) {
                nextFrame += count * _this.frameTimeFactor;
              };
              var c = marbles[i];
              switch (c) {
                case " ":
                  if (!runMode) {
                    advanceFrameBy(1);
                  }
                  break;
                case "-":
                  advanceFrameBy(1);
                  break;
                case "(":
                  groupStart = frame;
                  advanceFrameBy(1);
                  break;
                case ")":
                  groupStart = -1;
                  advanceFrameBy(1);
                  break;
                case "^":
                  if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
                    throw new Error(
                      "found a second subscription point '^' in a " +
                        "subscription marble diagram. There can only be one."
                    );
                  }
                  subscriptionFrame = groupStart > -1 ? groupStart : frame;
                  advanceFrameBy(1);
                  break;
                case "!":
                  if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
                    throw new Error(
                      "found a second subscription point '^' in a " +
                        "subscription marble diagram. There can only be one."
                    );
                  }
                  unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                  break;
                default:
                  if (runMode && c.match(/^[0-9]$/)) {
                    if (i === 0 || marbles[i - 1] === " ") {
                      var buffer = marbles.slice(i);
                      var match = buffer.match(
                        /^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /
                      );
                      if (match) {
                        i += match[0].length - 1;
                        var duration = parseFloat(match[1]);
                        var unit = match[2];
                        var durationInMs = void 0;
                        switch (unit) {
                          case "ms":
                            durationInMs = duration;
                            break;
                          case "s":
                            durationInMs = duration * 1000;
                            break;
                          case "m":
                            durationInMs = duration * 1000 * 60;
                            break;
                          default:
                            break;
                        }
                        advanceFrameBy(durationInMs / this_1.frameTimeFactor);
                        break;
                      }
                    }
                  }
                  throw new Error(
                    "there can only be '^' and '!' markers in a " +
                      "subscription marble diagram. Found instead '" +
                      c +
                      "'."
                  );
              }
              frame = nextFrame;
              out_i_1 = i;
            };
            var this_1 = this,
              out_i_1;
            for (var i = 0; i < len; i++) {
              _loop_1(i);
              i = out_i_1;
            }
            if (unsubscriptionFrame < 0) {
              return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
            } else {
              return new SubscriptionLog_1.SubscriptionLog(
                subscriptionFrame,
                unsubscriptionFrame
              );
            }
          };
          TestScheduler.parseMarbles = function (
            marbles,
            values,
            errorValue,
            materializeInnerObservables,
            runMode
          ) {
            var _this = this;
            if (materializeInnerObservables === void 0) {
              materializeInnerObservables = false;
            }
            if (runMode === void 0) {
              runMode = false;
            }
            if (marbles.indexOf("!") !== -1) {
              throw new Error(
                "conventional marble diagrams cannot have the " +
                  'unsubscription marker "!"'
              );
            }
            var len = marbles.length;
            var testMessages = [];
            var subIndex = runMode
              ? marbles.replace(/^[ ]+/, "").indexOf("^")
              : marbles.indexOf("^");
            var frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;
            var getValue =
              typeof values !== "object"
                ? function (x) {
                    return x;
                  }
                : function (x) {
                    if (
                      materializeInnerObservables &&
                      values[x] instanceof ColdObservable_1.ColdObservable
                    ) {
                      return values[x].messages;
                    }
                    return values[x];
                  };
            var groupStart = -1;
            var _loop_2 = function (i) {
              var nextFrame = frame;
              var advanceFrameBy = function (count) {
                nextFrame += count * _this.frameTimeFactor;
              };
              var notification = void 0;
              var c = marbles[i];
              switch (c) {
                case " ":
                  if (!runMode) {
                    advanceFrameBy(1);
                  }
                  break;
                case "-":
                  advanceFrameBy(1);
                  break;
                case "(":
                  groupStart = frame;
                  advanceFrameBy(1);
                  break;
                case ")":
                  groupStart = -1;
                  advanceFrameBy(1);
                  break;
                case "|":
                  notification = Notification_1.Notification.createComplete();
                  advanceFrameBy(1);
                  break;
                case "^":
                  advanceFrameBy(1);
                  break;
                case "#":
                  notification = Notification_1.Notification.createError(
                    errorValue || "error"
                  );
                  advanceFrameBy(1);
                  break;
                default:
                  if (runMode && c.match(/^[0-9]$/)) {
                    if (i === 0 || marbles[i - 1] === " ") {
                      var buffer = marbles.slice(i);
                      var match = buffer.match(
                        /^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /
                      );
                      if (match) {
                        i += match[0].length - 1;
                        var duration = parseFloat(match[1]);
                        var unit = match[2];
                        var durationInMs = void 0;
                        switch (unit) {
                          case "ms":
                            durationInMs = duration;
                            break;
                          case "s":
                            durationInMs = duration * 1000;
                            break;
                          case "m":
                            durationInMs = duration * 1000 * 60;
                            break;
                          default:
                            break;
                        }
                        advanceFrameBy(durationInMs / this_2.frameTimeFactor);
                        break;
                      }
                    }
                  }
                  notification = Notification_1.Notification.createNext(
                    getValue(c)
                  );
                  advanceFrameBy(1);
                  break;
              }
              if (notification) {
                testMessages.push({
                  frame: groupStart > -1 ? groupStart : frame,
                  notification: notification,
                });
              }
              frame = nextFrame;
              out_i_2 = i;
            };
            var this_2 = this,
              out_i_2;
            for (var i = 0; i < len; i++) {
              _loop_2(i);
              i = out_i_2;
            }
            return testMessages;
          };
          TestScheduler.prototype.run = function (callback) {
            var prevFrameTimeFactor = TestScheduler.frameTimeFactor;
            var prevMaxFrames = this.maxFrames;
            TestScheduler.frameTimeFactor = 1;
            this.maxFrames = Number.POSITIVE_INFINITY;
            this.runMode = true;
            AsyncScheduler_1.AsyncScheduler.delegate = this;
            var helpers = {
              cold: this.createColdObservable.bind(this),
              hot: this.createHotObservable.bind(this),
              flush: this.flush.bind(this),
              expectObservable: this.expectObservable.bind(this),
              expectSubscriptions: this.expectSubscriptions.bind(this),
            };
            try {
              var ret = callback(helpers);
              this.flush();
              return ret;
            } finally {
              TestScheduler.frameTimeFactor = prevFrameTimeFactor;
              this.maxFrames = prevMaxFrames;
              this.runMode = false;
              AsyncScheduler_1.AsyncScheduler.delegate = undefined;
            }
          };
          return TestScheduler;
        })(VirtualTimeScheduler_1.VirtualTimeScheduler);
        exports.TestScheduler = TestScheduler;
      },
      {
        "../Notification": 338,
        "../Observable": 339,
        "../scheduler/AsyncScheduler": 497,
        "../scheduler/VirtualTimeScheduler": 500,
        "./ColdObservable": 508,
        "./HotObservable": 509,
        "./SubscriptionLog": 510,
      },
    ],
    513: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ArgumentOutOfRangeErrorImpl = (function () {
          function ArgumentOutOfRangeErrorImpl() {
            Error.call(this);
            this.message = "argument out of range";
            this.name = "ArgumentOutOfRangeError";
            return this;
          }
          ArgumentOutOfRangeErrorImpl.prototype = Object.create(
            Error.prototype
          );
          return ArgumentOutOfRangeErrorImpl;
        })();
        exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
      },
      {},
    ],
    514: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var EmptyErrorImpl = (function () {
          function EmptyErrorImpl() {
            Error.call(this);
            this.message = "no elements in sequence";
            this.name = "EmptyError";
            return this;
          }
          EmptyErrorImpl.prototype = Object.create(Error.prototype);
          return EmptyErrorImpl;
        })();
        exports.EmptyError = EmptyErrorImpl;
      },
      {},
    ],
    515: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var nextHandle = 1;
        var RESOLVED = (function () {
          return Promise.resolve();
        })();
        var activeHandles = {};
        function findAndClearHandle(handle) {
          if (handle in activeHandles) {
            delete activeHandles[handle];
            return true;
          }
          return false;
        }
        exports.Immediate = {
          setImmediate: function (cb) {
            var handle = nextHandle++;
            activeHandles[handle] = true;
            RESOLVED.then(function () {
              return findAndClearHandle(handle) && cb();
            });
            return handle;
          },
          clearImmediate: function (handle) {
            findAndClearHandle(handle);
          },
        };
        exports.TestTools = {
          pending: function () {
            return Object.keys(activeHandles).length;
          },
        };
      },
      {},
    ],
    516: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var ObjectUnsubscribedErrorImpl = (function () {
          function ObjectUnsubscribedErrorImpl() {
            Error.call(this);
            this.message = "object unsubscribed";
            this.name = "ObjectUnsubscribedError";
            return this;
          }
          ObjectUnsubscribedErrorImpl.prototype = Object.create(
            Error.prototype
          );
          return ObjectUnsubscribedErrorImpl;
        })();
        exports.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
      },
      {},
    ],
    517: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var TimeoutErrorImpl = (function () {
          function TimeoutErrorImpl() {
            Error.call(this);
            this.message = "Timeout has occurred";
            this.name = "TimeoutError";
            return this;
          }
          TimeoutErrorImpl.prototype = Object.create(Error.prototype);
          return TimeoutErrorImpl;
        })();
        exports.TimeoutError = TimeoutErrorImpl;
      },
      {},
    ],
    518: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var UnsubscriptionErrorImpl = (function () {
          function UnsubscriptionErrorImpl(errors) {
            Error.call(this);
            this.message = errors
              ? errors.length +
                " errors occurred during unsubscription:\n" +
                errors
                  .map(function (err, i) {
                    return i + 1 + ") " + err.toString();
                  })
                  .join("\n  ")
              : "";
            this.name = "UnsubscriptionError";
            this.errors = errors;
            return this;
          }
          UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
          return UnsubscriptionErrorImpl;
        })();
        exports.UnsubscriptionError = UnsubscriptionErrorImpl;
      },
      {},
    ],
    519: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function applyMixins(derivedCtor, baseCtors) {
          for (var i = 0, len = baseCtors.length; i < len; i++) {
            var baseCtor = baseCtors[i];
            var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
            for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
              var name_1 = propertyKeys[j];
              derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
            }
          }
        }
        exports.applyMixins = applyMixins;
      },
      {},
    ],
    520: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        function canReportError(observer) {
          while (observer) {
            var _a = observer,
              closed_1 = _a.closed,
              destination = _a.destination,
              isStopped = _a.isStopped;
            if (closed_1 || isStopped) {
              return false;
            } else if (
              destination &&
              destination instanceof Subscriber_1.Subscriber
            ) {
              observer = destination;
            } else {
              observer = null;
            }
          }
          return true;
        }
        exports.canReportError = canReportError;
      },
      { "../Subscriber": 346 },
    ],
    521: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.errorObject = { e: {} };
      },
      {},
    ],
    522: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function hostReportError(err) {
          setTimeout(function () {
            throw err;
          }, 0);
        }
        exports.hostReportError = hostReportError;
      },
      {},
    ],
    523: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function identity(x) {
          return x;
        }
        exports.identity = identity;
      },
      {},
    ],
    524: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.isArray = (function () {
          return (
            Array.isArray ||
            function (x) {
              return x && typeof x.length === "number";
            }
          );
        })();
      },
      {},
    ],
    525: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.isArrayLike = function (x) {
          return x && typeof x.length === "number" && typeof x !== "function";
        };
      },
      {},
    ],
    526: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isDate(value) {
          return value instanceof Date && !isNaN(+value);
        }
        exports.isDate = isDate;
      },
      {},
    ],
    527: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isFunction(x) {
          return typeof x === "function";
        }
        exports.isFunction = isFunction;
      },
      {},
    ],
    528: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var observable_1 = require("../symbol/observable");
        function isInteropObservable(input) {
          return input && typeof input[observable_1.observable] === "function";
        }
        exports.isInteropObservable = isInteropObservable;
      },
      { "../symbol/observable": 506 },
    ],
    529: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var iterator_1 = require("../symbol/iterator");
        function isIterable(input) {
          return input && typeof input[iterator_1.iterator] === "function";
        }
        exports.isIterable = isIterable;
      },
      { "../symbol/iterator": 505 },
    ],
    530: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var isArray_1 = require("./isArray");
        function isNumeric(val) {
          return !isArray_1.isArray(val) && val - parseFloat(val) + 1 >= 0;
        }
        exports.isNumeric = isNumeric;
      },
      { "./isArray": 524 },
    ],
    531: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isObject(x) {
          return x !== null && typeof x === "object";
        }
        exports.isObject = isObject;
      },
      {},
    ],
    532: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Observable_1 = require("../Observable");
        function isObservable(obj) {
          return (
            !!obj &&
            (obj instanceof Observable_1.Observable ||
              (typeof obj.lift === "function" &&
                typeof obj.subscribe === "function"))
          );
        }
        exports.isObservable = isObservable;
      },
      { "../Observable": 339 },
    ],
    533: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isPromise(value) {
          return (
            !!value &&
            typeof value.subscribe !== "function" &&
            typeof value.then === "function"
          );
        }
        exports.isPromise = isPromise;
      },
      {},
    ],
    534: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function isScheduler(value) {
          return value && typeof value.schedule === "function";
        }
        exports.isScheduler = isScheduler;
      },
      {},
    ],
    535: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function noop() {}
        exports.noop = noop;
      },
      {},
    ],
    536: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        function not(pred, thisArg) {
          function notPred() {
            return !notPred.pred.apply(notPred.thisArg, arguments);
          }
          notPred.pred = pred;
          notPred.thisArg = thisArg;
          return notPred;
        }
        exports.not = not;
      },
      {},
    ],
    537: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var noop_1 = require("./noop");
        function pipe() {
          var fns = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
          }
          return pipeFromArray(fns);
        }
        exports.pipe = pipe;
        function pipeFromArray(fns) {
          if (!fns) {
            return noop_1.noop;
          }
          if (fns.length === 1) {
            return fns[0];
          }
          return function piped(input) {
            return fns.reduce(function (prev, fn) {
              return fn(prev);
            }, input);
          };
        }
        exports.pipeFromArray = pipeFromArray;
      },
      { "./noop": 535 },
    ],
    538: [
      function (require, module, exports) {
        (function (global) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var __window = typeof window !== "undefined" && window;
          var __self =
            typeof self !== "undefined" &&
            typeof WorkerGlobalScope !== "undefined" &&
            self instanceof WorkerGlobalScope &&
            self;
          var __global = typeof global !== "undefined" && global;
          var _root = __window || __global || __self;
          exports.root = _root;
          (function () {
            if (!_root) {
              throw new Error(
                "RxJS could not find any global context (window, self, global)"
              );
            }
          })();
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {},
    ],
    539: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var subscribeToArray_1 = require("./subscribeToArray");
        var subscribeToPromise_1 = require("./subscribeToPromise");
        var subscribeToIterable_1 = require("./subscribeToIterable");
        var subscribeToObservable_1 = require("./subscribeToObservable");
        var isArrayLike_1 = require("./isArrayLike");
        var isPromise_1 = require("./isPromise");
        var isObject_1 = require("./isObject");
        var iterator_1 = require("../symbol/iterator");
        var observable_1 = require("../symbol/observable");
        exports.subscribeTo = function (result) {
          if (
            !!result &&
            typeof result[observable_1.observable] === "function"
          ) {
            return subscribeToObservable_1.subscribeToObservable(result);
          } else if (isArrayLike_1.isArrayLike(result)) {
            return subscribeToArray_1.subscribeToArray(result);
          } else if (isPromise_1.isPromise(result)) {
            return subscribeToPromise_1.subscribeToPromise(result);
          } else if (
            !!result &&
            typeof result[iterator_1.iterator] === "function"
          ) {
            return subscribeToIterable_1.subscribeToIterable(result);
          } else {
            var value = isObject_1.isObject(result)
              ? "an invalid object"
              : "'" + result + "'";
            var msg =
              "You provided " +
              value +
              " where a stream was expected." +
              " You can provide an Observable, Promise, Array, or Iterable.";
            throw new TypeError(msg);
          }
        };
      },
      {
        "../symbol/iterator": 505,
        "../symbol/observable": 506,
        "./isArrayLike": 525,
        "./isObject": 531,
        "./isPromise": 533,
        "./subscribeToArray": 540,
        "./subscribeToIterable": 541,
        "./subscribeToObservable": 542,
        "./subscribeToPromise": 543,
      },
    ],
    540: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.subscribeToArray = function (array) {
          return function (subscriber) {
            for (
              var i = 0, len = array.length;
              i < len && !subscriber.closed;
              i++
            ) {
              subscriber.next(array[i]);
            }
            subscriber.complete();
          };
        };
      },
      {},
    ],
    541: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var iterator_1 = require("../symbol/iterator");
        exports.subscribeToIterable = function (iterable) {
          return function (subscriber) {
            var iterator = iterable[iterator_1.iterator]();
            do {
              var item = iterator.next();
              if (item.done) {
                subscriber.complete();
                break;
              }
              subscriber.next(item.value);
              if (subscriber.closed) {
                break;
              }
            } while (true);
            if (typeof iterator.return === "function") {
              subscriber.add(function () {
                if (iterator.return) {
                  iterator.return();
                }
              });
            }
            return subscriber;
          };
        };
      },
      { "../symbol/iterator": 505 },
    ],
    542: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var observable_1 = require("../symbol/observable");
        exports.subscribeToObservable = function (obj) {
          return function (subscriber) {
            var obs = obj[observable_1.observable]();
            if (typeof obs.subscribe !== "function") {
              throw new TypeError(
                "Provided object does not correctly implement Symbol.observable"
              );
            } else {
              return obs.subscribe(subscriber);
            }
          };
        };
      },
      { "../symbol/observable": 506 },
    ],
    543: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var hostReportError_1 = require("./hostReportError");
        exports.subscribeToPromise = function (promise) {
          return function (subscriber) {
            promise
              .then(
                function (value) {
                  if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                  }
                },
                function (err) {
                  return subscriber.error(err);
                }
              )
              .then(null, hostReportError_1.hostReportError);
            return subscriber;
          };
        };
      },
      { "./hostReportError": 522 },
    ],
    544: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var InnerSubscriber_1 = require("../InnerSubscriber");
        var subscribeTo_1 = require("./subscribeTo");
        var Observable_1 = require("../Observable");
        function subscribeToResult(
          outerSubscriber,
          result,
          outerValue,
          outerIndex,
          innerSubscriber
        ) {
          if (innerSubscriber === void 0) {
            innerSubscriber = new InnerSubscriber_1.InnerSubscriber(
              outerSubscriber,
              outerValue,
              outerIndex
            );
          }
          if (innerSubscriber.closed) {
            return undefined;
          }
          if (result instanceof Observable_1.Observable) {
            return result.subscribe(innerSubscriber);
          }
          return subscribeTo_1.subscribeTo(result)(innerSubscriber);
        }
        exports.subscribeToResult = subscribeToResult;
      },
      { "../InnerSubscriber": 337, "../Observable": 339, "./subscribeTo": 539 },
    ],
    545: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var Subscriber_1 = require("../Subscriber");
        var rxSubscriber_1 = require("../symbol/rxSubscriber");
        var Observer_1 = require("../Observer");
        function toSubscriber(nextOrObserver, error, complete) {
          if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber_1.Subscriber) {
              return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
              return nextOrObserver[rxSubscriber_1.rxSubscriber]();
            }
          }
          if (!nextOrObserver && !error && !complete) {
            return new Subscriber_1.Subscriber(Observer_1.empty);
          }
          return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        }
        exports.toSubscriber = toSubscriber;
      },
      {
        "../Observer": 340,
        "../Subscriber": 346,
        "../symbol/rxSubscriber": 507,
      },
    ],
    546: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var errorObject_1 = require("./errorObject");
        var tryCatchTarget;
        function tryCatcher() {
          errorObject_1.errorObject.e = undefined;
          try {
            return tryCatchTarget.apply(this, arguments);
          } catch (e) {
            errorObject_1.errorObject.e = e;
            return errorObject_1.errorObject;
          } finally {
            tryCatchTarget = undefined;
          }
        }
        function tryCatch(fn) {
          tryCatchTarget = fn;
          return tryCatcher;
        }
        exports.tryCatch = tryCatch;
      },
      { "./errorObject": 521 },
    ],
    547: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var audit_1 = require("../internal/operators/audit");
        exports.audit = audit_1.audit;
        var auditTime_1 = require("../internal/operators/auditTime");
        exports.auditTime = auditTime_1.auditTime;
        var buffer_1 = require("../internal/operators/buffer");
        exports.buffer = buffer_1.buffer;
        var bufferCount_1 = require("../internal/operators/bufferCount");
        exports.bufferCount = bufferCount_1.bufferCount;
        var bufferTime_1 = require("../internal/operators/bufferTime");
        exports.bufferTime = bufferTime_1.bufferTime;
        var bufferToggle_1 = require("../internal/operators/bufferToggle");
        exports.bufferToggle = bufferToggle_1.bufferToggle;
        var bufferWhen_1 = require("../internal/operators/bufferWhen");
        exports.bufferWhen = bufferWhen_1.bufferWhen;
        var catchError_1 = require("../internal/operators/catchError");
        exports.catchError = catchError_1.catchError;
        var combineAll_1 = require("../internal/operators/combineAll");
        exports.combineAll = combineAll_1.combineAll;
        var combineLatest_1 = require("../internal/operators/combineLatest");
        exports.combineLatest = combineLatest_1.combineLatest;
        var concat_1 = require("../internal/operators/concat");
        exports.concat = concat_1.concat;
        var concatAll_1 = require("../internal/operators/concatAll");
        exports.concatAll = concatAll_1.concatAll;
        var concatMap_1 = require("../internal/operators/concatMap");
        exports.concatMap = concatMap_1.concatMap;
        var concatMapTo_1 = require("../internal/operators/concatMapTo");
        exports.concatMapTo = concatMapTo_1.concatMapTo;
        var count_1 = require("../internal/operators/count");
        exports.count = count_1.count;
        var debounce_1 = require("../internal/operators/debounce");
        exports.debounce = debounce_1.debounce;
        var debounceTime_1 = require("../internal/operators/debounceTime");
        exports.debounceTime = debounceTime_1.debounceTime;
        var defaultIfEmpty_1 = require("../internal/operators/defaultIfEmpty");
        exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
        var delay_1 = require("../internal/operators/delay");
        exports.delay = delay_1.delay;
        var delayWhen_1 = require("../internal/operators/delayWhen");
        exports.delayWhen = delayWhen_1.delayWhen;
        var dematerialize_1 = require("../internal/operators/dematerialize");
        exports.dematerialize = dematerialize_1.dematerialize;
        var distinct_1 = require("../internal/operators/distinct");
        exports.distinct = distinct_1.distinct;
        var distinctUntilChanged_1 = require("../internal/operators/distinctUntilChanged");
        exports.distinctUntilChanged =
          distinctUntilChanged_1.distinctUntilChanged;
        var distinctUntilKeyChanged_1 = require("../internal/operators/distinctUntilKeyChanged");
        exports.distinctUntilKeyChanged =
          distinctUntilKeyChanged_1.distinctUntilKeyChanged;
        var elementAt_1 = require("../internal/operators/elementAt");
        exports.elementAt = elementAt_1.elementAt;
        var endWith_1 = require("../internal/operators/endWith");
        exports.endWith = endWith_1.endWith;
        var every_1 = require("../internal/operators/every");
        exports.every = every_1.every;
        var exhaust_1 = require("../internal/operators/exhaust");
        exports.exhaust = exhaust_1.exhaust;
        var exhaustMap_1 = require("../internal/operators/exhaustMap");
        exports.exhaustMap = exhaustMap_1.exhaustMap;
        var expand_1 = require("../internal/operators/expand");
        exports.expand = expand_1.expand;
        var filter_1 = require("../internal/operators/filter");
        exports.filter = filter_1.filter;
        var finalize_1 = require("../internal/operators/finalize");
        exports.finalize = finalize_1.finalize;
        var find_1 = require("../internal/operators/find");
        exports.find = find_1.find;
        var findIndex_1 = require("../internal/operators/findIndex");
        exports.findIndex = findIndex_1.findIndex;
        var first_1 = require("../internal/operators/first");
        exports.first = first_1.first;
        var groupBy_1 = require("../internal/operators/groupBy");
        exports.groupBy = groupBy_1.groupBy;
        var ignoreElements_1 = require("../internal/operators/ignoreElements");
        exports.ignoreElements = ignoreElements_1.ignoreElements;
        var isEmpty_1 = require("../internal/operators/isEmpty");
        exports.isEmpty = isEmpty_1.isEmpty;
        var last_1 = require("../internal/operators/last");
        exports.last = last_1.last;
        var map_1 = require("../internal/operators/map");
        exports.map = map_1.map;
        var mapTo_1 = require("../internal/operators/mapTo");
        exports.mapTo = mapTo_1.mapTo;
        var materialize_1 = require("../internal/operators/materialize");
        exports.materialize = materialize_1.materialize;
        var max_1 = require("../internal/operators/max");
        exports.max = max_1.max;
        var merge_1 = require("../internal/operators/merge");
        exports.merge = merge_1.merge;
        var mergeAll_1 = require("../internal/operators/mergeAll");
        exports.mergeAll = mergeAll_1.mergeAll;
        var mergeMap_1 = require("../internal/operators/mergeMap");
        exports.mergeMap = mergeMap_1.mergeMap;
        var mergeMap_2 = require("../internal/operators/mergeMap");
        exports.flatMap = mergeMap_2.mergeMap;
        var mergeMapTo_1 = require("../internal/operators/mergeMapTo");
        exports.mergeMapTo = mergeMapTo_1.mergeMapTo;
        var mergeScan_1 = require("../internal/operators/mergeScan");
        exports.mergeScan = mergeScan_1.mergeScan;
        var min_1 = require("../internal/operators/min");
        exports.min = min_1.min;
        var multicast_1 = require("../internal/operators/multicast");
        exports.multicast = multicast_1.multicast;
        var observeOn_1 = require("../internal/operators/observeOn");
        exports.observeOn = observeOn_1.observeOn;
        var onErrorResumeNext_1 = require("../internal/operators/onErrorResumeNext");
        exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
        var pairwise_1 = require("../internal/operators/pairwise");
        exports.pairwise = pairwise_1.pairwise;
        var partition_1 = require("../internal/operators/partition");
        exports.partition = partition_1.partition;
        var pluck_1 = require("../internal/operators/pluck");
        exports.pluck = pluck_1.pluck;
        var publish_1 = require("../internal/operators/publish");
        exports.publish = publish_1.publish;
        var publishBehavior_1 = require("../internal/operators/publishBehavior");
        exports.publishBehavior = publishBehavior_1.publishBehavior;
        var publishLast_1 = require("../internal/operators/publishLast");
        exports.publishLast = publishLast_1.publishLast;
        var publishReplay_1 = require("../internal/operators/publishReplay");
        exports.publishReplay = publishReplay_1.publishReplay;
        var race_1 = require("../internal/operators/race");
        exports.race = race_1.race;
        var reduce_1 = require("../internal/operators/reduce");
        exports.reduce = reduce_1.reduce;
        var repeat_1 = require("../internal/operators/repeat");
        exports.repeat = repeat_1.repeat;
        var repeatWhen_1 = require("../internal/operators/repeatWhen");
        exports.repeatWhen = repeatWhen_1.repeatWhen;
        var retry_1 = require("../internal/operators/retry");
        exports.retry = retry_1.retry;
        var retryWhen_1 = require("../internal/operators/retryWhen");
        exports.retryWhen = retryWhen_1.retryWhen;
        var refCount_1 = require("../internal/operators/refCount");
        exports.refCount = refCount_1.refCount;
        var sample_1 = require("../internal/operators/sample");
        exports.sample = sample_1.sample;
        var sampleTime_1 = require("../internal/operators/sampleTime");
        exports.sampleTime = sampleTime_1.sampleTime;
        var scan_1 = require("../internal/operators/scan");
        exports.scan = scan_1.scan;
        var sequenceEqual_1 = require("../internal/operators/sequenceEqual");
        exports.sequenceEqual = sequenceEqual_1.sequenceEqual;
        var share_1 = require("../internal/operators/share");
        exports.share = share_1.share;
        var shareReplay_1 = require("../internal/operators/shareReplay");
        exports.shareReplay = shareReplay_1.shareReplay;
        var single_1 = require("../internal/operators/single");
        exports.single = single_1.single;
        var skip_1 = require("../internal/operators/skip");
        exports.skip = skip_1.skip;
        var skipLast_1 = require("../internal/operators/skipLast");
        exports.skipLast = skipLast_1.skipLast;
        var skipUntil_1 = require("../internal/operators/skipUntil");
        exports.skipUntil = skipUntil_1.skipUntil;
        var skipWhile_1 = require("../internal/operators/skipWhile");
        exports.skipWhile = skipWhile_1.skipWhile;
        var startWith_1 = require("../internal/operators/startWith");
        exports.startWith = startWith_1.startWith;
        var subscribeOn_1 = require("../internal/operators/subscribeOn");
        exports.subscribeOn = subscribeOn_1.subscribeOn;
        var switchAll_1 = require("../internal/operators/switchAll");
        exports.switchAll = switchAll_1.switchAll;
        var switchMap_1 = require("../internal/operators/switchMap");
        exports.switchMap = switchMap_1.switchMap;
        var switchMapTo_1 = require("../internal/operators/switchMapTo");
        exports.switchMapTo = switchMapTo_1.switchMapTo;
        var take_1 = require("../internal/operators/take");
        exports.take = take_1.take;
        var takeLast_1 = require("../internal/operators/takeLast");
        exports.takeLast = takeLast_1.takeLast;
        var takeUntil_1 = require("../internal/operators/takeUntil");
        exports.takeUntil = takeUntil_1.takeUntil;
        var takeWhile_1 = require("../internal/operators/takeWhile");
        exports.takeWhile = takeWhile_1.takeWhile;
        var tap_1 = require("../internal/operators/tap");
        exports.tap = tap_1.tap;
        var throttle_1 = require("../internal/operators/throttle");
        exports.throttle = throttle_1.throttle;
        var throttleTime_1 = require("../internal/operators/throttleTime");
        exports.throttleTime = throttleTime_1.throttleTime;
        var throwIfEmpty_1 = require("../internal/operators/throwIfEmpty");
        exports.throwIfEmpty = throwIfEmpty_1.throwIfEmpty;
        var timeInterval_1 = require("../internal/operators/timeInterval");
        exports.timeInterval = timeInterval_1.timeInterval;
        var timeout_1 = require("../internal/operators/timeout");
        exports.timeout = timeout_1.timeout;
        var timeoutWith_1 = require("../internal/operators/timeoutWith");
        exports.timeoutWith = timeoutWith_1.timeoutWith;
        var timestamp_1 = require("../internal/operators/timestamp");
        exports.timestamp = timestamp_1.timestamp;
        var toArray_1 = require("../internal/operators/toArray");
        exports.toArray = toArray_1.toArray;
        var window_1 = require("../internal/operators/window");
        exports.window = window_1.window;
        var windowCount_1 = require("../internal/operators/windowCount");
        exports.windowCount = windowCount_1.windowCount;
        var windowTime_1 = require("../internal/operators/windowTime");
        exports.windowTime = windowTime_1.windowTime;
        var windowToggle_1 = require("../internal/operators/windowToggle");
        exports.windowToggle = windowToggle_1.windowToggle;
        var windowWhen_1 = require("../internal/operators/windowWhen");
        exports.windowWhen = windowWhen_1.windowWhen;
        var withLatestFrom_1 = require("../internal/operators/withLatestFrom");
        exports.withLatestFrom = withLatestFrom_1.withLatestFrom;
        var zip_1 = require("../internal/operators/zip");
        exports.zip = zip_1.zip;
        var zipAll_1 = require("../internal/operators/zipAll");
        exports.zipAll = zipAll_1.zipAll;
      },
      {
        "../internal/operators/audit": 383,
        "../internal/operators/auditTime": 384,
        "../internal/operators/buffer": 385,
        "../internal/operators/bufferCount": 386,
        "../internal/operators/bufferTime": 387,
        "../internal/operators/bufferToggle": 388,
        "../internal/operators/bufferWhen": 389,
        "../internal/operators/catchError": 390,
        "../internal/operators/combineAll": 391,
        "../internal/operators/combineLatest": 392,
        "../internal/operators/concat": 393,
        "../internal/operators/concatAll": 394,
        "../internal/operators/concatMap": 395,
        "../internal/operators/concatMapTo": 396,
        "../internal/operators/count": 397,
        "../internal/operators/debounce": 398,
        "../internal/operators/debounceTime": 399,
        "../internal/operators/defaultIfEmpty": 400,
        "../internal/operators/delay": 401,
        "../internal/operators/delayWhen": 402,
        "../internal/operators/dematerialize": 403,
        "../internal/operators/distinct": 404,
        "../internal/operators/distinctUntilChanged": 405,
        "../internal/operators/distinctUntilKeyChanged": 406,
        "../internal/operators/elementAt": 407,
        "../internal/operators/endWith": 408,
        "../internal/operators/every": 409,
        "../internal/operators/exhaust": 410,
        "../internal/operators/exhaustMap": 411,
        "../internal/operators/expand": 412,
        "../internal/operators/filter": 413,
        "../internal/operators/finalize": 414,
        "../internal/operators/find": 415,
        "../internal/operators/findIndex": 416,
        "../internal/operators/first": 417,
        "../internal/operators/groupBy": 418,
        "../internal/operators/ignoreElements": 419,
        "../internal/operators/isEmpty": 420,
        "../internal/operators/last": 421,
        "../internal/operators/map": 422,
        "../internal/operators/mapTo": 423,
        "../internal/operators/materialize": 424,
        "../internal/operators/max": 425,
        "../internal/operators/merge": 426,
        "../internal/operators/mergeAll": 427,
        "../internal/operators/mergeMap": 428,
        "../internal/operators/mergeMapTo": 429,
        "../internal/operators/mergeScan": 430,
        "../internal/operators/min": 431,
        "../internal/operators/multicast": 432,
        "../internal/operators/observeOn": 433,
        "../internal/operators/onErrorResumeNext": 434,
        "../internal/operators/pairwise": 435,
        "../internal/operators/partition": 436,
        "../internal/operators/pluck": 437,
        "../internal/operators/publish": 438,
        "../internal/operators/publishBehavior": 439,
        "../internal/operators/publishLast": 440,
        "../internal/operators/publishReplay": 441,
        "../internal/operators/race": 442,
        "../internal/operators/reduce": 443,
        "../internal/operators/refCount": 444,
        "../internal/operators/repeat": 445,
        "../internal/operators/repeatWhen": 446,
        "../internal/operators/retry": 447,
        "../internal/operators/retryWhen": 448,
        "../internal/operators/sample": 449,
        "../internal/operators/sampleTime": 450,
        "../internal/operators/scan": 451,
        "../internal/operators/sequenceEqual": 452,
        "../internal/operators/share": 453,
        "../internal/operators/shareReplay": 454,
        "../internal/operators/single": 455,
        "../internal/operators/skip": 456,
        "../internal/operators/skipLast": 457,
        "../internal/operators/skipUntil": 458,
        "../internal/operators/skipWhile": 459,
        "../internal/operators/startWith": 460,
        "../internal/operators/subscribeOn": 461,
        "../internal/operators/switchAll": 462,
        "../internal/operators/switchMap": 463,
        "../internal/operators/switchMapTo": 464,
        "../internal/operators/take": 465,
        "../internal/operators/takeLast": 466,
        "../internal/operators/takeUntil": 467,
        "../internal/operators/takeWhile": 468,
        "../internal/operators/tap": 469,
        "../internal/operators/throttle": 470,
        "../internal/operators/throttleTime": 471,
        "../internal/operators/throwIfEmpty": 472,
        "../internal/operators/timeInterval": 473,
        "../internal/operators/timeout": 474,
        "../internal/operators/timeoutWith": 475,
        "../internal/operators/timestamp": 476,
        "../internal/operators/toArray": 477,
        "../internal/operators/window": 478,
        "../internal/operators/windowCount": 479,
        "../internal/operators/windowTime": 480,
        "../internal/operators/windowToggle": 481,
        "../internal/operators/windowWhen": 482,
        "../internal/operators/withLatestFrom": 483,
        "../internal/operators/zip": 484,
        "../internal/operators/zipAll": 485,
      },
    ],
    548: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var TestScheduler_1 = require("../internal/testing/TestScheduler");
        exports.TestScheduler = TestScheduler_1.TestScheduler;
      },
      { "../internal/testing/TestScheduler": 512 },
    ],
    549: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var webSocket_1 = require("../internal/observable/dom/webSocket");
        exports.webSocket = webSocket_1.webSocket;
        var WebSocketSubject_1 = require("../internal/observable/dom/WebSocketSubject");
        exports.WebSocketSubject = WebSocketSubject_1.WebSocketSubject;
      },
      {
        "../internal/observable/dom/WebSocketSubject": 357,
        "../internal/observable/dom/webSocket": 359,
      },
    ],
    550: [
      function (require, module, exports) {
        /* eslint-disable node/no-deprecated-api */
        var buffer = require("buffer");
        var Buffer = buffer.Buffer;

        // alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (
          Buffer.from &&
          Buffer.alloc &&
          Buffer.allocUnsafe &&
          Buffer.allocUnsafeSlow
        ) {
          module.exports = buffer;
        } else {
          // Copy properties from require('buffer')
          copyProps(buffer, exports);
          exports.Buffer = SafeBuffer;
        }

        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }

        // Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer);

        SafeBuffer.from = function (arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };

        SafeBuffer.alloc = function (size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== undefined) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };

        SafeBuffer.allocUnsafe = function (size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };

        SafeBuffer.allocUnsafeSlow = function (size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      },
      { buffer: 50 },
    ],
    551: [
      function (require, module, exports) {
        (function (Buffer) {
          (function (sax) {
            // wrapper for non-node envs
            sax.parser = function (strict, opt) {
              return new SAXParser(strict, opt);
            };
            sax.SAXParser = SAXParser;
            sax.SAXStream = SAXStream;
            sax.createStream = createStream;

            // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
            // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
            // since that's the earliest that a buffer overrun could occur.  This way, checks are
            // as rare as required, but as often as necessary to ensure never crossing this bound.
            // Furthermore, buffers are only tested at most once per write(), so passing a very
            // large string into write() might have undesirable effects, but this is manageable by
            // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
            // edge case, result in creating at most one complete copy of the string passed in.
            // Set to Infinity to have unlimited buffers.
            sax.MAX_BUFFER_LENGTH = 64 * 1024;

            var buffers = [
              "comment",
              "sgmlDecl",
              "textNode",
              "tagName",
              "doctype",
              "procInstName",
              "procInstBody",
              "entity",
              "attribName",
              "attribValue",
              "cdata",
              "script",
            ];

            sax.EVENTS = [
              "text",
              "processinginstruction",
              "sgmldeclaration",
              "doctype",
              "comment",
              "opentagstart",
              "attribute",
              "opentag",
              "closetag",
              "opencdata",
              "cdata",
              "closecdata",
              "error",
              "end",
              "ready",
              "script",
              "opennamespace",
              "closenamespace",
            ];

            function SAXParser(strict, opt) {
              if (!(this instanceof SAXParser)) {
                return new SAXParser(strict, opt);
              }

              var parser = this;
              clearBuffers(parser);
              parser.q = parser.c = "";
              parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
              parser.opt = opt || {};
              parser.opt.lowercase =
                parser.opt.lowercase || parser.opt.lowercasetags;
              parser.looseCase = parser.opt.lowercase
                ? "toLowerCase"
                : "toUpperCase";
              parser.tags = [];
              parser.closed = parser.closedRoot = parser.sawRoot = false;
              parser.tag = parser.error = null;
              parser.strict = !!strict;
              parser.noscript = !!(strict || parser.opt.noscript);
              parser.state = S.BEGIN;
              parser.strictEntities = parser.opt.strictEntities;
              parser.ENTITIES = parser.strictEntities
                ? Object.create(sax.XML_ENTITIES)
                : Object.create(sax.ENTITIES);
              parser.attribList = [];

              // namespaces form a prototype chain.
              // it always points at the current tag,
              // which protos to its parent tag.
              if (parser.opt.xmlns) {
                parser.ns = Object.create(rootNS);
              }

              // mostly just for error reporting
              parser.trackPosition = parser.opt.position !== false;
              if (parser.trackPosition) {
                parser.position = parser.line = parser.column = 0;
              }
              emit(parser, "onready");
            }

            if (!Object.create) {
              Object.create = function (o) {
                function F() {}
                F.prototype = o;
                var newf = new F();
                return newf;
              };
            }

            if (!Object.keys) {
              Object.keys = function (o) {
                var a = [];
                for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
                return a;
              };
            }

            function checkBufferLength(parser) {
              var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
              var maxActual = 0;
              for (var i = 0, l = buffers.length; i < l; i++) {
                var len = parser[buffers[i]].length;
                if (len > maxAllowed) {
                  // Text/cdata nodes can get big, and since they're buffered,
                  // we can get here under normal conditions.
                  // Avoid issues by emitting the text node now,
                  // so at least it won't get any bigger.
                  switch (buffers[i]) {
                    case "textNode":
                      closeText(parser);
                      break;

                    case "cdata":
                      emitNode(parser, "oncdata", parser.cdata);
                      parser.cdata = "";
                      break;

                    case "script":
                      emitNode(parser, "onscript", parser.script);
                      parser.script = "";
                      break;

                    default:
                      error(
                        parser,
                        "Max buffer length exceeded: " + buffers[i]
                      );
                  }
                }
                maxActual = Math.max(maxActual, len);
              }
              // schedule the next check for the earliest possible buffer overrun.
              var m = sax.MAX_BUFFER_LENGTH - maxActual;
              parser.bufferCheckPosition = m + parser.position;
            }

            function clearBuffers(parser) {
              for (var i = 0, l = buffers.length; i < l; i++) {
                parser[buffers[i]] = "";
              }
            }

            function flushBuffers(parser) {
              closeText(parser);
              if (parser.cdata !== "") {
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
              }
              if (parser.script !== "") {
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
              }
            }

            SAXParser.prototype = {
              end: function () {
                end(this);
              },
              write: write,
              resume: function () {
                this.error = null;
                return this;
              },
              close: function () {
                return this.write(null);
              },
              flush: function () {
                flushBuffers(this);
              },
            };

            var Stream;
            try {
              Stream = require("stream").Stream;
            } catch (ex) {
              Stream = function () {};
            }

            var streamWraps = sax.EVENTS.filter(function (ev) {
              return ev !== "error" && ev !== "end";
            });

            function createStream(strict, opt) {
              return new SAXStream(strict, opt);
            }

            function SAXStream(strict, opt) {
              if (!(this instanceof SAXStream)) {
                return new SAXStream(strict, opt);
              }

              Stream.apply(this);

              this._parser = new SAXParser(strict, opt);
              this.writable = true;
              this.readable = true;

              var me = this;

              this._parser.onend = function () {
                me.emit("end");
              };

              this._parser.onerror = function (er) {
                me.emit("error", er);

                // if didn't throw, then means error was handled.
                // go ahead and clear error, so we can write again.
                me._parser.error = null;
              };

              this._decoder = null;

              streamWraps.forEach(function (ev) {
                Object.defineProperty(me, "on" + ev, {
                  get: function () {
                    return me._parser["on" + ev];
                  },
                  set: function (h) {
                    if (!h) {
                      me.removeAllListeners(ev);
                      me._parser["on" + ev] = h;
                      return h;
                    }
                    me.on(ev, h);
                  },
                  enumerable: true,
                  configurable: false,
                });
              });
            }

            SAXStream.prototype = Object.create(Stream.prototype, {
              constructor: {
                value: SAXStream,
              },
            });

            SAXStream.prototype.write = function (data) {
              if (
                typeof Buffer === "function" &&
                typeof Buffer.isBuffer === "function" &&
                Buffer.isBuffer(data)
              ) {
                if (!this._decoder) {
                  var SD = require("string_decoder").StringDecoder;
                  this._decoder = new SD("utf8");
                }
                data = this._decoder.write(data);
              }

              this._parser.write(data.toString());
              this.emit("data", data);
              return true;
            };

            SAXStream.prototype.end = function (chunk) {
              if (chunk && chunk.length) {
                this.write(chunk);
              }
              this._parser.end();
              return true;
            };

            SAXStream.prototype.on = function (ev, handler) {
              var me = this;
              if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
                me._parser["on" + ev] = function () {
                  var args =
                    arguments.length === 1
                      ? [arguments[0]]
                      : Array.apply(null, arguments);
                  args.splice(0, 0, ev);
                  me.emit.apply(me, args);
                };
              }

              return Stream.prototype.on.call(me, ev, handler);
            };

            // this really needs to be replaced with character classes.
            // XML allows all manner of ridiculous numbers and digits.
            var CDATA = "[CDATA[";
            var DOCTYPE = "DOCTYPE";
            var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
            var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
            var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };

            // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
            // This implementation works on strings, a single character at a time
            // as such, it cannot ever support astral-plane characters (10000-EFFFF)
            // without a significant breaking change to either this  parser, or the
            // JavaScript language.  Implementation of an emoji-capable xml parser
            // is left as an exercise for the reader.
            var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

            var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

            var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

            function isWhitespace(c) {
              return c === " " || c === "\n" || c === "\r" || c === "\t";
            }

            function isQuote(c) {
              return c === '"' || c === "'";
            }

            function isAttribEnd(c) {
              return c === ">" || isWhitespace(c);
            }

            function isMatch(regex, c) {
              return regex.test(c);
            }

            function notMatch(regex, c) {
              return !isMatch(regex, c);
            }

            var S = 0;
            sax.STATE = {
              BEGIN: S++, // leading byte order mark or whitespace
              BEGIN_WHITESPACE: S++, // leading whitespace
              TEXT: S++, // general stuff
              TEXT_ENTITY: S++, // &amp and such.
              OPEN_WAKA: S++, // <
              SGML_DECL: S++, // <!BLARG
              SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
              DOCTYPE: S++, // <!DOCTYPE
              DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
              DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
              DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
              COMMENT_STARTING: S++, // <!-
              COMMENT: S++, // <!--
              COMMENT_ENDING: S++, // <!-- blah -
              COMMENT_ENDED: S++, // <!-- blah --
              CDATA: S++, // <![CDATA[ something
              CDATA_ENDING: S++, // ]
              CDATA_ENDING_2: S++, // ]]
              PROC_INST: S++, // <?hi
              PROC_INST_BODY: S++, // <?hi there
              PROC_INST_ENDING: S++, // <?hi "there" ?
              OPEN_TAG: S++, // <strong
              OPEN_TAG_SLASH: S++, // <strong /
              ATTRIB: S++, // <a
              ATTRIB_NAME: S++, // <a foo
              ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
              ATTRIB_VALUE: S++, // <a foo=
              ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
              ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
              ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
              ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
              ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
              CLOSE_TAG: S++, // </a
              CLOSE_TAG_SAW_WHITE: S++, // </a   >
              SCRIPT: S++, // <script> ...
              SCRIPT_ENDING: S++, // <script> ... <
            };

            sax.XML_ENTITIES = {
              amp: "&",
              gt: ">",
              lt: "<",
              quot: '"',
              apos: "'",
            };

            sax.ENTITIES = {
              amp: "&",
              gt: ">",
              lt: "<",
              quot: '"',
              apos: "'",
              AElig: 198,
              Aacute: 193,
              Acirc: 194,
              Agrave: 192,
              Aring: 197,
              Atilde: 195,
              Auml: 196,
              Ccedil: 199,
              ETH: 208,
              Eacute: 201,
              Ecirc: 202,
              Egrave: 200,
              Euml: 203,
              Iacute: 205,
              Icirc: 206,
              Igrave: 204,
              Iuml: 207,
              Ntilde: 209,
              Oacute: 211,
              Ocirc: 212,
              Ograve: 210,
              Oslash: 216,
              Otilde: 213,
              Ouml: 214,
              THORN: 222,
              Uacute: 218,
              Ucirc: 219,
              Ugrave: 217,
              Uuml: 220,
              Yacute: 221,
              aacute: 225,
              acirc: 226,
              aelig: 230,
              agrave: 224,
              aring: 229,
              atilde: 227,
              auml: 228,
              ccedil: 231,
              eacute: 233,
              ecirc: 234,
              egrave: 232,
              eth: 240,
              euml: 235,
              iacute: 237,
              icirc: 238,
              igrave: 236,
              iuml: 239,
              ntilde: 241,
              oacute: 243,
              ocirc: 244,
              ograve: 242,
              oslash: 248,
              otilde: 245,
              ouml: 246,
              szlig: 223,
              thorn: 254,
              uacute: 250,
              ucirc: 251,
              ugrave: 249,
              uuml: 252,
              yacute: 253,
              yuml: 255,
              copy: 169,
              reg: 174,
              nbsp: 160,
              iexcl: 161,
              cent: 162,
              pound: 163,
              curren: 164,
              yen: 165,
              brvbar: 166,
              sect: 167,
              uml: 168,
              ordf: 170,
              laquo: 171,
              not: 172,
              shy: 173,
              macr: 175,
              deg: 176,
              plusmn: 177,
              sup1: 185,
              sup2: 178,
              sup3: 179,
              acute: 180,
              micro: 181,
              para: 182,
              middot: 183,
              cedil: 184,
              ordm: 186,
              raquo: 187,
              frac14: 188,
              frac12: 189,
              frac34: 190,
              iquest: 191,
              times: 215,
              divide: 247,
              OElig: 338,
              oelig: 339,
              Scaron: 352,
              scaron: 353,
              Yuml: 376,
              fnof: 402,
              circ: 710,
              tilde: 732,
              Alpha: 913,
              Beta: 914,
              Gamma: 915,
              Delta: 916,
              Epsilon: 917,
              Zeta: 918,
              Eta: 919,
              Theta: 920,
              Iota: 921,
              Kappa: 922,
              Lambda: 923,
              Mu: 924,
              Nu: 925,
              Xi: 926,
              Omicron: 927,
              Pi: 928,
              Rho: 929,
              Sigma: 931,
              Tau: 932,
              Upsilon: 933,
              Phi: 934,
              Chi: 935,
              Psi: 936,
              Omega: 937,
              alpha: 945,
              beta: 946,
              gamma: 947,
              delta: 948,
              epsilon: 949,
              zeta: 950,
              eta: 951,
              theta: 952,
              iota: 953,
              kappa: 954,
              lambda: 955,
              mu: 956,
              nu: 957,
              xi: 958,
              omicron: 959,
              pi: 960,
              rho: 961,
              sigmaf: 962,
              sigma: 963,
              tau: 964,
              upsilon: 965,
              phi: 966,
              chi: 967,
              psi: 968,
              omega: 969,
              thetasym: 977,
              upsih: 978,
              piv: 982,
              ensp: 8194,
              emsp: 8195,
              thinsp: 8201,
              zwnj: 8204,
              zwj: 8205,
              lrm: 8206,
              rlm: 8207,
              ndash: 8211,
              mdash: 8212,
              lsquo: 8216,
              rsquo: 8217,
              sbquo: 8218,
              ldquo: 8220,
              rdquo: 8221,
              bdquo: 8222,
              dagger: 8224,
              Dagger: 8225,
              bull: 8226,
              hellip: 8230,
              permil: 8240,
              prime: 8242,
              Prime: 8243,
              lsaquo: 8249,
              rsaquo: 8250,
              oline: 8254,
              frasl: 8260,
              euro: 8364,
              image: 8465,
              weierp: 8472,
              real: 8476,
              trade: 8482,
              alefsym: 8501,
              larr: 8592,
              uarr: 8593,
              rarr: 8594,
              darr: 8595,
              harr: 8596,
              crarr: 8629,
              lArr: 8656,
              uArr: 8657,
              rArr: 8658,
              dArr: 8659,
              hArr: 8660,
              forall: 8704,
              part: 8706,
              exist: 8707,
              empty: 8709,
              nabla: 8711,
              isin: 8712,
              notin: 8713,
              ni: 8715,
              prod: 8719,
              sum: 8721,
              minus: 8722,
              lowast: 8727,
              radic: 8730,
              prop: 8733,
              infin: 8734,
              ang: 8736,
              and: 8743,
              or: 8744,
              cap: 8745,
              cup: 8746,
              int: 8747,
              there4: 8756,
              sim: 8764,
              cong: 8773,
              asymp: 8776,
              ne: 8800,
              equiv: 8801,
              le: 8804,
              ge: 8805,
              sub: 8834,
              sup: 8835,
              nsub: 8836,
              sube: 8838,
              supe: 8839,
              oplus: 8853,
              otimes: 8855,
              perp: 8869,
              sdot: 8901,
              lceil: 8968,
              rceil: 8969,
              lfloor: 8970,
              rfloor: 8971,
              lang: 9001,
              rang: 9002,
              loz: 9674,
              spades: 9824,
              clubs: 9827,
              hearts: 9829,
              diams: 9830,
            };

            Object.keys(sax.ENTITIES).forEach(function (key) {
              var e = sax.ENTITIES[key];
              var s = typeof e === "number" ? String.fromCharCode(e) : e;
              sax.ENTITIES[key] = s;
            });

            for (var s in sax.STATE) {
              sax.STATE[sax.STATE[s]] = s;
            }

            // shorthand
            S = sax.STATE;

            function emit(parser, event, data) {
              parser[event] && parser[event](data);
            }

            function emitNode(parser, nodeType, data) {
              if (parser.textNode) closeText(parser);
              emit(parser, nodeType, data);
            }

            function closeText(parser) {
              parser.textNode = textopts(parser.opt, parser.textNode);
              if (parser.textNode) emit(parser, "ontext", parser.textNode);
              parser.textNode = "";
            }

            function textopts(opt, text) {
              if (opt.trim) text = text.trim();
              if (opt.normalize) text = text.replace(/\s+/g, " ");
              return text;
            }

            function error(parser, er) {
              closeText(parser);
              if (parser.trackPosition) {
                er +=
                  "\nLine: " +
                  parser.line +
                  "\nColumn: " +
                  parser.column +
                  "\nChar: " +
                  parser.c;
              }
              er = new Error(er);
              parser.error = er;
              emit(parser, "onerror", er);
              return parser;
            }

            function end(parser) {
              if (parser.sawRoot && !parser.closedRoot)
                strictFail(parser, "Unclosed root tag");
              if (
                parser.state !== S.BEGIN &&
                parser.state !== S.BEGIN_WHITESPACE &&
                parser.state !== S.TEXT
              ) {
                error(parser, "Unexpected end");
              }
              closeText(parser);
              parser.c = "";
              parser.closed = true;
              emit(parser, "onend");
              SAXParser.call(parser, parser.strict, parser.opt);
              return parser;
            }

            function strictFail(parser, message) {
              if (
                typeof parser !== "object" ||
                !(parser instanceof SAXParser)
              ) {
                throw new Error("bad call to strictFail");
              }
              if (parser.strict) {
                error(parser, message);
              }
            }

            function newTag(parser) {
              if (!parser.strict)
                parser.tagName = parser.tagName[parser.looseCase]();
              var parent = parser.tags[parser.tags.length - 1] || parser;
              var tag = (parser.tag = { name: parser.tagName, attributes: {} });

              // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
              if (parser.opt.xmlns) {
                tag.ns = parent.ns;
              }
              parser.attribList.length = 0;
              emitNode(parser, "onopentagstart", tag);
            }

            function qname(name, attribute) {
              var i = name.indexOf(":");
              var qualName = i < 0 ? ["", name] : name.split(":");
              var prefix = qualName[0];
              var local = qualName[1];

              // <x "xmlns"="http://foo">
              if (attribute && name === "xmlns") {
                prefix = "xmlns";
                local = "";
              }

              return { prefix: prefix, local: local };
            }

            function attrib(parser) {
              if (!parser.strict) {
                parser.attribName = parser.attribName[parser.looseCase]();
              }

              if (
                parser.attribList.indexOf(parser.attribName) !== -1 ||
                parser.tag.attributes.hasOwnProperty(parser.attribName)
              ) {
                parser.attribName = parser.attribValue = "";
                return;
              }

              if (parser.opt.xmlns) {
                var qn = qname(parser.attribName, true);
                var prefix = qn.prefix;
                var local = qn.local;

                if (prefix === "xmlns") {
                  // namespace binding attribute. push the binding into scope
                  if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                    strictFail(
                      parser,
                      "xml: prefix must be bound to " +
                        XML_NAMESPACE +
                        "\n" +
                        "Actual: " +
                        parser.attribValue
                    );
                  } else if (
                    local === "xmlns" &&
                    parser.attribValue !== XMLNS_NAMESPACE
                  ) {
                    strictFail(
                      parser,
                      "xmlns: prefix must be bound to " +
                        XMLNS_NAMESPACE +
                        "\n" +
                        "Actual: " +
                        parser.attribValue
                    );
                  } else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) {
                      tag.ns = Object.create(parent.ns);
                    }
                    tag.ns[local] = parser.attribValue;
                  }
                }

                // defer onattribute events until all attributes have been seen
                // so any new bindings can take effect. preserve attribute order
                // so deferred events can be emitted in document order
                parser.attribList.push([parser.attribName, parser.attribValue]);
              } else {
                // in non-xmlns mode, we can emit the event right away
                parser.tag.attributes[parser.attribName] = parser.attribValue;
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: parser.attribValue,
                });
              }

              parser.attribName = parser.attribValue = "";
            }

            function openTag(parser, selfClosing) {
              if (parser.opt.xmlns) {
                // emit namespace binding events
                var tag = parser.tag;

                // add namespace info to tag
                var qn = qname(parser.tagName);
                tag.prefix = qn.prefix;
                tag.local = qn.local;
                tag.uri = tag.ns[qn.prefix] || "";

                if (tag.prefix && !tag.uri) {
                  strictFail(
                    parser,
                    "Unbound namespace prefix: " +
                      JSON.stringify(parser.tagName)
                  );
                  tag.uri = qn.prefix;
                }

                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns && parent.ns !== tag.ns) {
                  Object.keys(tag.ns).forEach(function (p) {
                    emitNode(parser, "onopennamespace", {
                      prefix: p,
                      uri: tag.ns[p],
                    });
                  });
                }

                // handle deferred onattribute events
                // Note: do not apply default ns to attributes:
                //   http://www.w3.org/TR/REC-xml-names/#defaulting
                for (var i = 0, l = parser.attribList.length; i < l; i++) {
                  var nv = parser.attribList[i];
                  var name = nv[0];
                  var value = nv[1];
                  var qualName = qname(name, true);
                  var prefix = qualName.prefix;
                  var local = qualName.local;
                  var uri = prefix === "" ? "" : tag.ns[prefix] || "";
                  var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri,
                  };

                  // if there's any attributes with an undefined namespace,
                  // then fail on them now.
                  if (prefix && prefix !== "xmlns" && !uri) {
                    strictFail(
                      parser,
                      "Unbound namespace prefix: " + JSON.stringify(prefix)
                    );
                    a.uri = prefix;
                  }
                  parser.tag.attributes[name] = a;
                  emitNode(parser, "onattribute", a);
                }
                parser.attribList.length = 0;
              }

              parser.tag.isSelfClosing = !!selfClosing;

              // process the tag
              parser.sawRoot = true;
              parser.tags.push(parser.tag);
              emitNode(parser, "onopentag", parser.tag);
              if (!selfClosing) {
                // special case for <script> in non-strict mode.
                if (
                  !parser.noscript &&
                  parser.tagName.toLowerCase() === "script"
                ) {
                  parser.state = S.SCRIPT;
                } else {
                  parser.state = S.TEXT;
                }
                parser.tag = null;
                parser.tagName = "";
              }
              parser.attribName = parser.attribValue = "";
              parser.attribList.length = 0;
            }

            function closeTag(parser) {
              if (!parser.tagName) {
                strictFail(parser, "Weird empty close tag.");
                parser.textNode += "</>";
                parser.state = S.TEXT;
                return;
              }

              if (parser.script) {
                if (parser.tagName !== "script") {
                  parser.script += "</" + parser.tagName + ">";
                  parser.tagName = "";
                  parser.state = S.SCRIPT;
                  return;
                }
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
              }

              // first make sure that the closing tag actually exists.
              // <a><b></c></b></a> will close everything, otherwise.
              var t = parser.tags.length;
              var tagName = parser.tagName;
              if (!parser.strict) {
                tagName = tagName[parser.looseCase]();
              }
              var closeTo = tagName;
              while (t--) {
                var close = parser.tags[t];
                if (close.name !== closeTo) {
                  // fail the first time in strict mode
                  strictFail(parser, "Unexpected close tag");
                } else {
                  break;
                }
              }

              // didn't find it.  we already failed for strict, so just abort.
              if (t < 0) {
                strictFail(parser, "Unmatched closing tag: " + parser.tagName);
                parser.textNode += "</" + parser.tagName + ">";
                parser.state = S.TEXT;
                return;
              }
              parser.tagName = tagName;
              var s = parser.tags.length;
              while (s-- > t) {
                var tag = (parser.tag = parser.tags.pop());
                parser.tagName = parser.tag.name;
                emitNode(parser, "onclosetag", parser.tagName);

                var x = {};
                for (var i in tag.ns) {
                  x[i] = tag.ns[i];
                }

                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (parser.opt.xmlns && tag.ns !== parent.ns) {
                  // remove namespace bindings introduced by tag
                  Object.keys(tag.ns).forEach(function (p) {
                    var n = tag.ns[p];
                    emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
                  });
                }
              }
              if (t === 0) parser.closedRoot = true;
              parser.tagName = parser.attribValue = parser.attribName = "";
              parser.attribList.length = 0;
              parser.state = S.TEXT;
            }

            function parseEntity(parser) {
              var entity = parser.entity;
              var entityLC = entity.toLowerCase();
              var num;
              var numStr = "";

              if (parser.ENTITIES[entity]) {
                return parser.ENTITIES[entity];
              }
              if (parser.ENTITIES[entityLC]) {
                return parser.ENTITIES[entityLC];
              }
              entity = entityLC;
              if (entity.charAt(0) === "#") {
                if (entity.charAt(1) === "x") {
                  entity = entity.slice(2);
                  num = parseInt(entity, 16);
                  numStr = num.toString(16);
                } else {
                  entity = entity.slice(1);
                  num = parseInt(entity, 10);
                  numStr = num.toString(10);
                }
              }
              entity = entity.replace(/^0+/, "");
              if (isNaN(num) || numStr.toLowerCase() !== entity) {
                strictFail(parser, "Invalid character entity");
                return "&" + parser.entity + ";";
              }

              return String.fromCodePoint(num);
            }

            function beginWhiteSpace(parser, c) {
              if (c === "<") {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (!isWhitespace(c)) {
                // have to process this as a text node.
                // weird, but happens.
                strictFail(parser, "Non-whitespace before first tag.");
                parser.textNode = c;
                parser.state = S.TEXT;
              }
            }

            function charAt(chunk, i) {
              var result = "";
              if (i < chunk.length) {
                result = chunk.charAt(i);
              }
              return result;
            }

            function write(chunk) {
              var parser = this;
              if (this.error) {
                throw this.error;
              }
              if (parser.closed) {
                return error(
                  parser,
                  "Cannot write after close. Assign an onready handler."
                );
              }
              if (chunk === null) {
                return end(parser);
              }
              if (typeof chunk === "object") {
                chunk = chunk.toString();
              }
              var i = 0;
              var c = "";
              while (true) {
                c = charAt(chunk, i++);
                parser.c = c;

                if (!c) {
                  break;
                }

                if (parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }

                switch (parser.state) {
                  case S.BEGIN:
                    parser.state = S.BEGIN_WHITESPACE;
                    if (c === "\uFEFF") {
                      continue;
                    }
                    beginWhiteSpace(parser, c);
                    continue;

                  case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(parser, c);
                    continue;

                  case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                      var starti = i - 1;
                      while (c && c !== "<" && c !== "&") {
                        c = charAt(chunk, i++);
                        if (c && parser.trackPosition) {
                          parser.position++;
                          if (c === "\n") {
                            parser.line++;
                            parser.column = 0;
                          } else {
                            parser.column++;
                          }
                        }
                      }
                      parser.textNode += chunk.substring(starti, i - 1);
                    }
                    if (
                      c === "<" &&
                      !(parser.sawRoot && parser.closedRoot && !parser.strict)
                    ) {
                      parser.state = S.OPEN_WAKA;
                      parser.startTagPosition = parser.position;
                    } else {
                      if (
                        !isWhitespace(c) &&
                        (!parser.sawRoot || parser.closedRoot)
                      ) {
                        strictFail(parser, "Text data outside of root node.");
                      }
                      if (c === "&") {
                        parser.state = S.TEXT_ENTITY;
                      } else {
                        parser.textNode += c;
                      }
                    }
                    continue;

                  case S.SCRIPT:
                    // only non-strict
                    if (c === "<") {
                      parser.state = S.SCRIPT_ENDING;
                    } else {
                      parser.script += c;
                    }
                    continue;

                  case S.SCRIPT_ENDING:
                    if (c === "/") {
                      parser.state = S.CLOSE_TAG;
                    } else {
                      parser.script += "<" + c;
                      parser.state = S.SCRIPT;
                    }
                    continue;

                  case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === "!") {
                      parser.state = S.SGML_DECL;
                      parser.sgmlDecl = "";
                    } else if (isWhitespace(c)) {
                      // wait for it...
                    } else if (isMatch(nameStart, c)) {
                      parser.state = S.OPEN_TAG;
                      parser.tagName = c;
                    } else if (c === "/") {
                      parser.state = S.CLOSE_TAG;
                      parser.tagName = "";
                    } else if (c === "?") {
                      parser.state = S.PROC_INST;
                      parser.procInstName = parser.procInstBody = "";
                    } else {
                      strictFail(parser, "Unencoded <");
                      // if there was some whitespace, then add that in.
                      if (parser.startTagPosition + 1 < parser.position) {
                        var pad = parser.position - parser.startTagPosition;
                        c = new Array(pad).join(" ") + c;
                      }
                      parser.textNode += "<" + c;
                      parser.state = S.TEXT;
                    }
                    continue;

                  case S.SGML_DECL:
                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                      emitNode(parser, "onopencdata");
                      parser.state = S.CDATA;
                      parser.sgmlDecl = "";
                      parser.cdata = "";
                    } else if (parser.sgmlDecl + c === "--") {
                      parser.state = S.COMMENT;
                      parser.comment = "";
                      parser.sgmlDecl = "";
                    } else if (
                      (parser.sgmlDecl + c).toUpperCase() === DOCTYPE
                    ) {
                      parser.state = S.DOCTYPE;
                      if (parser.doctype || parser.sawRoot) {
                        strictFail(
                          parser,
                          "Inappropriately located doctype declaration"
                        );
                      }
                      parser.doctype = "";
                      parser.sgmlDecl = "";
                    } else if (c === ">") {
                      emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                      parser.sgmlDecl = "";
                      parser.state = S.TEXT;
                    } else if (isQuote(c)) {
                      parser.state = S.SGML_DECL_QUOTED;
                      parser.sgmlDecl += c;
                    } else {
                      parser.sgmlDecl += c;
                    }
                    continue;

                  case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                      parser.state = S.SGML_DECL;
                      parser.q = "";
                    }
                    parser.sgmlDecl += c;
                    continue;

                  case S.DOCTYPE:
                    if (c === ">") {
                      parser.state = S.TEXT;
                      emitNode(parser, "ondoctype", parser.doctype);
                      parser.doctype = true; // just remember that we saw it.
                    } else {
                      parser.doctype += c;
                      if (c === "[") {
                        parser.state = S.DOCTYPE_DTD;
                      } else if (isQuote(c)) {
                        parser.state = S.DOCTYPE_QUOTED;
                        parser.q = c;
                      }
                    }
                    continue;

                  case S.DOCTYPE_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                      parser.q = "";
                      parser.state = S.DOCTYPE;
                    }
                    continue;

                  case S.DOCTYPE_DTD:
                    parser.doctype += c;
                    if (c === "]") {
                      parser.state = S.DOCTYPE;
                    } else if (isQuote(c)) {
                      parser.state = S.DOCTYPE_DTD_QUOTED;
                      parser.q = c;
                    }
                    continue;

                  case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                      parser.state = S.DOCTYPE_DTD;
                      parser.q = "";
                    }
                    continue;

                  case S.COMMENT:
                    if (c === "-") {
                      parser.state = S.COMMENT_ENDING;
                    } else {
                      parser.comment += c;
                    }
                    continue;

                  case S.COMMENT_ENDING:
                    if (c === "-") {
                      parser.state = S.COMMENT_ENDED;
                      parser.comment = textopts(parser.opt, parser.comment);
                      if (parser.comment) {
                        emitNode(parser, "oncomment", parser.comment);
                      }
                      parser.comment = "";
                    } else {
                      parser.comment += "-" + c;
                      parser.state = S.COMMENT;
                    }
                    continue;

                  case S.COMMENT_ENDED:
                    if (c !== ">") {
                      strictFail(parser, "Malformed comment");
                      // allow <!-- blah -- bloo --> in non-strict mode,
                      // which is a comment of " blah -- bloo "
                      parser.comment += "--" + c;
                      parser.state = S.COMMENT;
                    } else {
                      parser.state = S.TEXT;
                    }
                    continue;

                  case S.CDATA:
                    if (c === "]") {
                      parser.state = S.CDATA_ENDING;
                    } else {
                      parser.cdata += c;
                    }
                    continue;

                  case S.CDATA_ENDING:
                    if (c === "]") {
                      parser.state = S.CDATA_ENDING_2;
                    } else {
                      parser.cdata += "]" + c;
                      parser.state = S.CDATA;
                    }
                    continue;

                  case S.CDATA_ENDING_2:
                    if (c === ">") {
                      if (parser.cdata) {
                        emitNode(parser, "oncdata", parser.cdata);
                      }
                      emitNode(parser, "onclosecdata");
                      parser.cdata = "";
                      parser.state = S.TEXT;
                    } else if (c === "]") {
                      parser.cdata += "]";
                    } else {
                      parser.cdata += "]]" + c;
                      parser.state = S.CDATA;
                    }
                    continue;

                  case S.PROC_INST:
                    if (c === "?") {
                      parser.state = S.PROC_INST_ENDING;
                    } else if (isWhitespace(c)) {
                      parser.state = S.PROC_INST_BODY;
                    } else {
                      parser.procInstName += c;
                    }
                    continue;

                  case S.PROC_INST_BODY:
                    if (!parser.procInstBody && isWhitespace(c)) {
                      continue;
                    } else if (c === "?") {
                      parser.state = S.PROC_INST_ENDING;
                    } else {
                      parser.procInstBody += c;
                    }
                    continue;

                  case S.PROC_INST_ENDING:
                    if (c === ">") {
                      emitNode(parser, "onprocessinginstruction", {
                        name: parser.procInstName,
                        body: parser.procInstBody,
                      });
                      parser.procInstName = parser.procInstBody = "";
                      parser.state = S.TEXT;
                    } else {
                      parser.procInstBody += "?" + c;
                      parser.state = S.PROC_INST_BODY;
                    }
                    continue;

                  case S.OPEN_TAG:
                    if (isMatch(nameBody, c)) {
                      parser.tagName += c;
                    } else {
                      newTag(parser);
                      if (c === ">") {
                        openTag(parser);
                      } else if (c === "/") {
                        parser.state = S.OPEN_TAG_SLASH;
                      } else {
                        if (!isWhitespace(c)) {
                          strictFail(parser, "Invalid character in tag name");
                        }
                        parser.state = S.ATTRIB;
                      }
                    }
                    continue;

                  case S.OPEN_TAG_SLASH:
                    if (c === ">") {
                      openTag(parser, true);
                      closeTag(parser);
                    } else {
                      strictFail(
                        parser,
                        "Forward-slash in opening tag not followed by >"
                      );
                      parser.state = S.ATTRIB;
                    }
                    continue;

                  case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (isWhitespace(c)) {
                      continue;
                    } else if (c === ">") {
                      openTag(parser);
                    } else if (c === "/") {
                      parser.state = S.OPEN_TAG_SLASH;
                    } else if (isMatch(nameStart, c)) {
                      parser.attribName = c;
                      parser.attribValue = "";
                      parser.state = S.ATTRIB_NAME;
                    } else {
                      strictFail(parser, "Invalid attribute name");
                    }
                    continue;

                  case S.ATTRIB_NAME:
                    if (c === "=") {
                      parser.state = S.ATTRIB_VALUE;
                    } else if (c === ">") {
                      strictFail(parser, "Attribute without value");
                      parser.attribValue = parser.attribName;
                      attrib(parser);
                      openTag(parser);
                    } else if (isWhitespace(c)) {
                      parser.state = S.ATTRIB_NAME_SAW_WHITE;
                    } else if (isMatch(nameBody, c)) {
                      parser.attribName += c;
                    } else {
                      strictFail(parser, "Invalid attribute name");
                    }
                    continue;

                  case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === "=") {
                      parser.state = S.ATTRIB_VALUE;
                    } else if (isWhitespace(c)) {
                      continue;
                    } else {
                      strictFail(parser, "Attribute without value");
                      parser.tag.attributes[parser.attribName] = "";
                      parser.attribValue = "";
                      emitNode(parser, "onattribute", {
                        name: parser.attribName,
                        value: "",
                      });
                      parser.attribName = "";
                      if (c === ">") {
                        openTag(parser);
                      } else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.state = S.ATTRIB_NAME;
                      } else {
                        strictFail(parser, "Invalid attribute name");
                        parser.state = S.ATTRIB;
                      }
                    }
                    continue;

                  case S.ATTRIB_VALUE:
                    if (isWhitespace(c)) {
                      continue;
                    } else if (isQuote(c)) {
                      parser.q = c;
                      parser.state = S.ATTRIB_VALUE_QUOTED;
                    } else {
                      strictFail(parser, "Unquoted attribute value");
                      parser.state = S.ATTRIB_VALUE_UNQUOTED;
                      parser.attribValue = c;
                    }
                    continue;

                  case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                      if (c === "&") {
                        parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                      } else {
                        parser.attribValue += c;
                      }
                      continue;
                    }
                    attrib(parser);
                    parser.q = "";
                    parser.state = S.ATTRIB_VALUE_CLOSED;
                    continue;

                  case S.ATTRIB_VALUE_CLOSED:
                    if (isWhitespace(c)) {
                      parser.state = S.ATTRIB;
                    } else if (c === ">") {
                      openTag(parser);
                    } else if (c === "/") {
                      parser.state = S.OPEN_TAG_SLASH;
                    } else if (isMatch(nameStart, c)) {
                      strictFail(parser, "No whitespace between attributes");
                      parser.attribName = c;
                      parser.attribValue = "";
                      parser.state = S.ATTRIB_NAME;
                    } else {
                      strictFail(parser, "Invalid attribute name");
                    }
                    continue;

                  case S.ATTRIB_VALUE_UNQUOTED:
                    if (!isAttribEnd(c)) {
                      if (c === "&") {
                        parser.state = S.ATTRIB_VALUE_ENTITY_U;
                      } else {
                        parser.attribValue += c;
                      }
                      continue;
                    }
                    attrib(parser);
                    if (c === ">") {
                      openTag(parser);
                    } else {
                      parser.state = S.ATTRIB;
                    }
                    continue;

                  case S.CLOSE_TAG:
                    if (!parser.tagName) {
                      if (isWhitespace(c)) {
                        continue;
                      } else if (notMatch(nameStart, c)) {
                        if (parser.script) {
                          parser.script += "</" + c;
                          parser.state = S.SCRIPT;
                        } else {
                          strictFail(parser, "Invalid tagname in closing tag.");
                        }
                      } else {
                        parser.tagName = c;
                      }
                    } else if (c === ">") {
                      closeTag(parser);
                    } else if (isMatch(nameBody, c)) {
                      parser.tagName += c;
                    } else if (parser.script) {
                      parser.script += "</" + parser.tagName;
                      parser.tagName = "";
                      parser.state = S.SCRIPT;
                    } else {
                      if (!isWhitespace(c)) {
                        strictFail(parser, "Invalid tagname in closing tag");
                      }
                      parser.state = S.CLOSE_TAG_SAW_WHITE;
                    }
                    continue;

                  case S.CLOSE_TAG_SAW_WHITE:
                    if (isWhitespace(c)) {
                      continue;
                    }
                    if (c === ">") {
                      closeTag(parser);
                    } else {
                      strictFail(parser, "Invalid characters in closing tag");
                    }
                    continue;

                  case S.TEXT_ENTITY:
                  case S.ATTRIB_VALUE_ENTITY_Q:
                  case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState;
                    var buffer;
                    switch (parser.state) {
                      case S.TEXT_ENTITY:
                        returnState = S.TEXT;
                        buffer = "textNode";
                        break;

                      case S.ATTRIB_VALUE_ENTITY_Q:
                        returnState = S.ATTRIB_VALUE_QUOTED;
                        buffer = "attribValue";
                        break;

                      case S.ATTRIB_VALUE_ENTITY_U:
                        returnState = S.ATTRIB_VALUE_UNQUOTED;
                        buffer = "attribValue";
                        break;
                    }

                    if (c === ";") {
                      parser[buffer] += parseEntity(parser);
                      parser.entity = "";
                      parser.state = returnState;
                    } else if (
                      isMatch(
                        parser.entity.length ? entityBody : entityStart,
                        c
                      )
                    ) {
                      parser.entity += c;
                    } else {
                      strictFail(parser, "Invalid character in entity name");
                      parser[buffer] += "&" + parser.entity + c;
                      parser.entity = "";
                      parser.state = returnState;
                    }

                    continue;

                  default:
                    throw new Error(parser, "Unknown state: " + parser.state);
                }
              } // while

              if (parser.position >= parser.bufferCheckPosition) {
                checkBufferLength(parser);
              }
              return parser;
            }

            /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
            /* istanbul ignore next */
            if (!String.fromCodePoint) {
              (function () {
                var stringFromCharCode = String.fromCharCode;
                var floor = Math.floor;
                var fromCodePoint = function () {
                  var MAX_SIZE = 0x4000;
                  var codeUnits = [];
                  var highSurrogate;
                  var lowSurrogate;
                  var index = -1;
                  var length = arguments.length;
                  if (!length) {
                    return "";
                  }
                  var result = "";
                  while (++index < length) {
                    var codePoint = Number(arguments[index]);
                    if (
                      !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                      codePoint < 0 || // not a valid Unicode code point
                      codePoint > 0x10ffff || // not a valid Unicode code point
                      floor(codePoint) !== codePoint // not an integer
                    ) {
                      throw RangeError("Invalid code point: " + codePoint);
                    }
                    if (codePoint <= 0xffff) {
                      // BMP code point
                      codeUnits.push(codePoint);
                    } else {
                      // Astral code point; split in surrogate halves
                      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                      codePoint -= 0x10000;
                      highSurrogate = (codePoint >> 10) + 0xd800;
                      lowSurrogate = (codePoint % 0x400) + 0xdc00;
                      codeUnits.push(highSurrogate, lowSurrogate);
                    }
                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                      result += stringFromCharCode.apply(null, codeUnits);
                      codeUnits.length = 0;
                    }
                  }
                  return result;
                };
                /* istanbul ignore next */
                if (Object.defineProperty) {
                  Object.defineProperty(String, "fromCodePoint", {
                    value: fromCodePoint,
                    configurable: true,
                    writable: true,
                  });
                } else {
                  String.fromCodePoint = fromCodePoint;
                }
              })();
            }
          })(typeof exports === "undefined" ? (this.sax = {}) : exports);
        }.call(this, require("buffer").Buffer));
      },
      { buffer: 50, stream: 555, string_decoder: 561 },
    ],
    552: [
      function (require, module, exports) {
        (function (Buffer) {
          /*!
           * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
           *
           * Copyright (c) 2015-present, Jon Schlinkert.
           * Released under the MIT License.
           */

          "use strict";

          const valueOf = Symbol.prototype.valueOf;
          const typeOf = require("kind-of");

          function clone(val, deep) {
            switch (typeOf(val)) {
              case "array":
                return val.slice();
              case "object":
                return Object.assign({}, val);
              case "date":
                return new val.constructor(Number(val));
              case "map":
                return new Map(val);
              case "set":
                return new Set(val);
              case "buffer":
                return cloneBuffer(val);
              case "symbol":
                return cloneSymbol(val);
              case "arraybuffer":
                return cloneArrayBuffer(val);
              case "float32array":
              case "float64array":
              case "int16array":
              case "int32array":
              case "int8array":
              case "uint16array":
              case "uint32array":
              case "uint8clampedarray":
              case "uint8array":
                return cloneTypedArray(val);
              case "regexp":
                return cloneRegExp(val);
              case "error":
                return Object.create(val);
              default: {
                return val;
              }
            }
          }

          function cloneRegExp(val) {
            const flags =
              val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
            const re = new val.constructor(val.source, flags);
            re.lastIndex = val.lastIndex;
            return re;
          }

          function cloneArrayBuffer(val) {
            const res = new val.constructor(val.byteLength);
            new Uint8Array(res).set(new Uint8Array(val));
            return res;
          }

          function cloneTypedArray(val, deep) {
            return new val.constructor(val.buffer, val.byteOffset, val.length);
          }

          function cloneBuffer(val) {
            const len = val.length;
            const buf = Buffer.allocUnsafe
              ? Buffer.allocUnsafe(len)
              : Buffer.from(len);
            val.copy(buf);
            return buf;
          }

          function cloneSymbol(val) {
            return valueOf ? Object(valueOf.call(val)) : {};
          }

          /**
           * Expose `clone`
           */

          module.exports = clone;
        }.call(this, require("buffer").Buffer));
      },
      { buffer: 50, "kind-of": 68 },
    ],
    553: [
      function (require, module, exports) {
        "use strict";

        module.exports = (string, separator) => {
          if (!(typeof string === "string" && typeof separator === "string")) {
            throw new TypeError(
              "Expected the arguments to be of type `string`"
            );
          }

          if (separator === "") {
            return [string];
          }

          const separatorIndex = string.indexOf(separator);

          if (separatorIndex === -1) {
            return [string];
          }

          return [
            string.slice(0, separatorIndex),
            string.slice(separatorIndex + separator.length),
          ];
        };
      },
      {},
    ],
    554: [
      function (require, module, exports) {
        /* global window, exports, define */

        !(function () {
          "use strict";

          var re = {
            not_string: /[^s]/,
            not_bool: /[^t]/,
            not_type: /[^T]/,
            not_primitive: /[^v]/,
            number: /[diefg]/,
            numeric_arg: /[bcdiefguxX]/,
            json: /[j]/,
            not_json: /[^j]/,
            text: /^[^\x25]+/,
            modulo: /^\x25{2}/,
            placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
            key: /^([a-z_][a-z_\d]*)/i,
            key_access: /^\.([a-z_][a-z_\d]*)/i,
            index_access: /^\[(\d+)\]/,
            sign: /^[+-]/,
          };

          function sprintf(key) {
            // `arguments` is not an array, but should be fine for this call
            return sprintf_format(sprintf_parse(key), arguments);
          }

          function vsprintf(fmt, argv) {
            return sprintf.apply(null, [fmt].concat(argv || []));
          }

          function sprintf_format(parse_tree, argv) {
            var cursor = 1,
              tree_length = parse_tree.length,
              arg,
              output = "",
              i,
              k,
              ph,
              pad,
              pad_character,
              pad_length,
              is_positive,
              sign;
            for (i = 0; i < tree_length; i++) {
              if (typeof parse_tree[i] === "string") {
                output += parse_tree[i];
              } else if (typeof parse_tree[i] === "object") {
                ph = parse_tree[i]; // convenience purposes only
                if (ph.keys) {
                  // keyword argument
                  arg = argv[cursor];
                  for (k = 0; k < ph.keys.length; k++) {
                    if (arg == undefined) {
                      throw new Error(
                        sprintf(
                          '[sprintf] Cannot access property "%s" of undefined value "%s"',
                          ph.keys[k],
                          ph.keys[k - 1]
                        )
                      );
                    }
                    arg = arg[ph.keys[k]];
                  }
                } else if (ph.param_no) {
                  // positional argument (explicit)
                  arg = argv[ph.param_no];
                } else {
                  // positional argument (implicit)
                  arg = argv[cursor++];
                }

                if (
                  re.not_type.test(ph.type) &&
                  re.not_primitive.test(ph.type) &&
                  arg instanceof Function
                ) {
                  arg = arg();
                }

                if (
                  re.numeric_arg.test(ph.type) &&
                  typeof arg !== "number" &&
                  isNaN(arg)
                ) {
                  throw new TypeError(
                    sprintf("[sprintf] expecting number but found %T", arg)
                  );
                }

                if (re.number.test(ph.type)) {
                  is_positive = arg >= 0;
                }

                switch (ph.type) {
                  case "b":
                    arg = parseInt(arg, 10).toString(2);
                    break;
                  case "c":
                    arg = String.fromCharCode(parseInt(arg, 10));
                    break;
                  case "d":
                  case "i":
                    arg = parseInt(arg, 10);
                    break;
                  case "j":
                    arg = JSON.stringify(
                      arg,
                      null,
                      ph.width ? parseInt(ph.width) : 0
                    );
                    break;
                  case "e":
                    arg = ph.precision
                      ? parseFloat(arg).toExponential(ph.precision)
                      : parseFloat(arg).toExponential();
                    break;
                  case "f":
                    arg = ph.precision
                      ? parseFloat(arg).toFixed(ph.precision)
                      : parseFloat(arg);
                    break;
                  case "g":
                    arg = ph.precision
                      ? String(Number(arg.toPrecision(ph.precision)))
                      : parseFloat(arg);
                    break;
                  case "o":
                    arg = (parseInt(arg, 10) >>> 0).toString(8);
                    break;
                  case "s":
                    arg = String(arg);
                    arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                    break;
                  case "t":
                    arg = String(!!arg);
                    arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                    break;
                  case "T":
                    arg = Object.prototype.toString
                      .call(arg)
                      .slice(8, -1)
                      .toLowerCase();
                    arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                    break;
                  case "u":
                    arg = parseInt(arg, 10) >>> 0;
                    break;
                  case "v":
                    arg = arg.valueOf();
                    arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                    break;
                  case "x":
                    arg = (parseInt(arg, 10) >>> 0).toString(16);
                    break;
                  case "X":
                    arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                    break;
                }
                if (re.json.test(ph.type)) {
                  output += arg;
                } else {
                  if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                    sign = is_positive ? "+" : "-";
                    arg = arg.toString().replace(re.sign, "");
                  } else {
                    sign = "";
                  }
                  pad_character = ph.pad_char
                    ? ph.pad_char === "0"
                      ? "0"
                      : ph.pad_char.charAt(1)
                    : " ";
                  pad_length = ph.width - (sign + arg).length;
                  pad = ph.width
                    ? pad_length > 0
                      ? pad_character.repeat(pad_length)
                      : ""
                    : "";
                  output += ph.align
                    ? sign + arg + pad
                    : pad_character === "0"
                    ? sign + pad + arg
                    : pad + sign + arg;
                }
              }
            }
            return output;
          }

          var sprintf_cache = Object.create(null);

          function sprintf_parse(fmt) {
            if (sprintf_cache[fmt]) {
              return sprintf_cache[fmt];
            }

            var _fmt = fmt,
              match,
              parse_tree = [],
              arg_names = 0;
            while (_fmt) {
              if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0]);
              } else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push("%");
              } else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                  arg_names |= 1;
                  var field_list = [],
                    replacement_field = match[2],
                    field_match = [];
                  if ((field_match = re.key.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                    while (
                      (replacement_field = replacement_field.substring(
                        field_match[0].length
                      )) !== ""
                    ) {
                      if (
                        (field_match = re.key_access.exec(
                          replacement_field
                        )) !== null
                      ) {
                        field_list.push(field_match[1]);
                      } else if (
                        (field_match = re.index_access.exec(
                          replacement_field
                        )) !== null
                      ) {
                        field_list.push(field_match[1]);
                      } else {
                        throw new SyntaxError(
                          "[sprintf] failed to parse named argument key"
                        );
                      }
                    }
                  } else {
                    throw new SyntaxError(
                      "[sprintf] failed to parse named argument key"
                    );
                  }
                  match[2] = field_list;
                } else {
                  arg_names |= 2;
                }
                if (arg_names === 3) {
                  throw new Error(
                    "[sprintf] mixing positional and named placeholders is not (yet) supported"
                  );
                }

                parse_tree.push({
                  placeholder: match[0],
                  param_no: match[1],
                  keys: match[2],
                  sign: match[3],
                  pad_char: match[4],
                  align: match[5],
                  width: match[6],
                  precision: match[7],
                  type: match[8],
                });
              } else {
                throw new SyntaxError("[sprintf] unexpected placeholder");
              }
              _fmt = _fmt.substring(match[0].length);
            }
            return (sprintf_cache[fmt] = parse_tree);
          }

          /**
           * export to either browser or node.js
           */
          /* eslint-disable quote-props */
          if (typeof exports !== "undefined") {
            exports["sprintf"] = sprintf;
            exports["vsprintf"] = vsprintf;
          }
          if (typeof window !== "undefined") {
            window["sprintf"] = sprintf;
            window["vsprintf"] = vsprintf;

            if (typeof define === "function" && define["amd"]) {
              define(function () {
                return {
                  sprintf: sprintf,
                  vsprintf: vsprintf,
                };
              });
            }
          }
          /* eslint-enable quote-props */
        })(); // eslint-disable-line
      },
      {},
    ],
    555: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        module.exports = Stream;

        var EE = require("events").EventEmitter;
        var inherits = require("inherits");

        inherits(Stream, EE);
        Stream.Readable = require("readable-stream/readable.js");
        Stream.Writable = require("readable-stream/writable.js");
        Stream.Duplex = require("readable-stream/duplex.js");
        Stream.Transform = require("readable-stream/transform.js");
        Stream.PassThrough = require("readable-stream/passthrough.js");

        // Backwards-compat with node 0.4.x
        Stream.Stream = Stream;

        // old-style streams.  Note that the pipe method (the only relevant
        // part of this class) is overridden in the Readable class.

        function Stream() {
          EE.call(this);
        }

        Stream.prototype.pipe = function (dest, options) {
          var source = this;

          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }

          source.on("data", ondata);

          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }

          dest.on("drain", ondrain);

          // If the 'end' option is not supplied, dest.end() will be called when
          // source gets the 'end' or 'close' events.  Only dest.end() once.
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on("end", onend);
            source.on("close", onclose);
          }

          var didOnEnd = false;
          function onend() {
            if (didOnEnd) return;
            didOnEnd = true;

            dest.end();
          }

          function onclose() {
            if (didOnEnd) return;
            didOnEnd = true;

            if (typeof dest.destroy === "function") dest.destroy();
          }

          // don't leave dangling pipes when there are errors.
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, "error") === 0) {
              throw er; // Unhandled stream error in pipe.
            }
          }

          source.on("error", onerror);
          dest.on("error", onerror);

          // remove all the event listeners that were added.
          function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);

            source.removeListener("end", onend);
            source.removeListener("close", onclose);

            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);

            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);

            dest.removeListener("close", cleanup);
          }

          source.on("end", cleanup);
          source.on("close", cleanup);

          dest.on("close", cleanup);

          dest.emit("pipe", source);

          // Allow for unix-like usage: A.pipe(B).pipe(C)
          return dest;
        };
      },
      {
        events: 56,
        inherits: 63,
        "readable-stream/duplex.js": 86,
        "readable-stream/passthrough.js": 96,
        "readable-stream/readable.js": 97,
        "readable-stream/transform.js": 98,
        "readable-stream/writable.js": 99,
      },
    ],
    556: [
      function (require, module, exports) {
        "use strict";
        module.exports = (str) =>
          encodeURIComponent(str).replace(
            /[!'()*]/g,
            (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`
          );
      },
      {},
    ],
    557: [
      function (require, module, exports) {
        function count(self, substr) {
          var count = 0;
          var pos = self.indexOf(substr);

          while (pos >= 0) {
            count += 1;
            pos = self.indexOf(substr, pos + 1);
          }

          return count;
        }

        module.exports = count;
      },
      {},
    ],
    558: [
      function (require, module, exports) {
        function splitLeft(self, sep, maxSplit, limit) {
          if (typeof maxSplit === "undefined") {
            var maxSplit = -1;
          }

          var splitResult = self.split(sep);
          var splitPart1 = splitResult.slice(0, maxSplit);
          var splitPart2 = splitResult.slice(maxSplit);

          if (splitPart2.length === 0) {
            splitResult = splitPart1;
          } else {
            splitResult = splitPart1.concat(splitPart2.join(sep));
          }

          if (typeof limit === "undefined") {
            return splitResult;
          } else if (limit < 0) {
            return splitResult.slice(limit);
          } else {
            return splitResult.slice(0, limit);
          }
        }

        module.exports = splitLeft;
      },
      {},
    ],
    559: [
      function (require, module, exports) {
        function splitRight(self, sep, maxSplit, limit) {
          if (typeof maxSplit === "undefined") {
            var maxSplit = -1;
          }
          if (typeof limit === "undefined") {
            var limit = 0;
          }

          var splitResult = [self];

          for (var i = self.length - 1; i >= 0; i--) {
            if (
              splitResult[0].slice(i).indexOf(sep) === 0 &&
              (splitResult.length <= maxSplit || maxSplit === -1)
            ) {
              splitResult.splice(1, 0, splitResult[0].slice(i + sep.length)); // insert
              splitResult[0] = splitResult[0].slice(0, i);
            }
          }

          if (limit >= 0) {
            return splitResult.slice(-limit);
          } else {
            return splitResult.slice(0, -limit);
          }
        }

        module.exports = splitRight;
      },
      {},
    ],
    560: [
      function (require, module, exports) {
        /*
string.js - Copyright (C) 2012-2014, JP Richardson <jprichardson@gmail.com>
*/

        !function () {
          "use strict";

          var VERSION = "3.3.3";

          var ENTITIES = {};

          // from http://semplicewebsites.com/removing-accents-javascript
          var latin_map = {
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "AA",
            : "AE",
            : "AE",
            : "AE",
            : "AO",
            : "AU",
            : "AV",
            : "AV",
            : "AY",
            : "B",
            : "B",
            : "B",
            : "B",
            : "B",
            : "B",
            : "C",
            : "C",
            : "C",
            : "C",
            : "C",
            : "C",
            : "C",
            : "C",
            : "D",
            : "D",
            : "D",
            : "D",
            : "D",
            : "D",
            : "D",
            : "D",
            : "D",
            : "D",
            : "D",
            : "DZ",
            : "DZ",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "ET",
            : "F",
            : "F",
            : "G",
            : "G",
            : "G",
            : "G",
            : "G",
            : "G",
            : "G",
            : "G",
            : "G",
            : "H",
            : "H",
            : "H",
            : "H",
            : "H",
            : "H",
            : "H",
            : "H",
            : "H",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "D",
            : "F",
            : "G",
            : "R",
            : "S",
            : "T",
            : "IS",
            : "J",
            : "J",
            : "K",
            : "K",
            : "K",
            : "K",
            : "K",
            : "K",
            : "K",
            : "K",
            : "K",
            : "K",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "LJ",
            : "M",
            : "M",
            : "M",
            : "M",
            : "N",
            : "N",
            : "N",
            : "N",
            : "N",
            : "N",
            : "N",
            : "N",
            : "N",
            : "N",
            : "N",
            : "N",
            : "NJ",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "OI",
            : "OO",
            : "E",
            : "O",
            : "OU",
            : "P",
            : "P",
            : "P",
            : "P",
            : "P",
            : "P",
            : "P",
            : "Q",
            : "Q",
            : "R",
            : "R",
            : "R",
            : "R",
            : "R",
            : "R",
            : "R",
            : "R",
            : "R",
            : "R",
            : "R",
            : "C",
            : "E",
            : "S",
            : "S",
            : "S",
            : "S",
            : "S",
            : "S",
            : "S",
            : "S",
            : "S",
            : "S",
            : "SS",
            : "T",
            : "T",
            : "T",
            : "T",
            : "T",
            : "T",
            : "T",
            : "T",
            : "T",
            : "T",
            : "T",
            : "A",
            : "L",
            : "M",
            : "V",
            : "TZ",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "V",
            : "V",
            : "V",
            : "V",
            : "VY",
            : "W",
            : "W",
            : "W",
            : "W",
            : "W",
            : "W",
            : "W",
            : "X",
            : "X",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Y",
            : "Z",
            : "Z",
            : "Z",
            : "Z",
            : "Z",
            : "Z",
            : "Z",
            : "Z",
            : "Z",
            : "IJ",
            : "OE",
            : "A",
            : "AE",
            : "B",
            : "B",
            : "C",
            : "D",
            : "E",
            : "F",
            : "G",
            : "G",
            : "H",
            : "I",
            : "R",
            : "J",
            : "K",
            : "L",
            : "L",
            : "M",
            : "N",
            : "O",
            : "OE",
            : "O",
            : "OU",
            : "P",
            : "R",
            : "N",
            : "R",
            : "S",
            : "T",
            : "E",
            : "R",
            : "U",
            : "V",
            : "W",
            : "Y",
            : "Z",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "aa",
            : "ae",
            : "ae",
            : "ae",
            : "ao",
            : "au",
            : "av",
            : "av",
            : "ay",
            : "b",
            : "b",
            : "b",
            : "b",
            : "b",
            : "b",
            : "b",
            : "b",
            : "o",
            : "c",
            : "c",
            : "c",
            : "c",
            : "c",
            : "c",
            : "c",
            : "c",
            : "c",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "d",
            : "i",
            : "j",
            : "j",
            : "j",
            : "dz",
            : "dz",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "et",
            : "f",
            : "f",
            : "f",
            : "f",
            : "g",
            : "g",
            : "g",
            : "g",
            : "g",
            : "g",
            : "g",
            : "g",
            : "g",
            : "g",
            : "h",
            : "h",
            : "h",
            : "h",
            : "h",
            : "h",
            : "h",
            : "h",
            : "h",
            : "h",
            : "h",
            : "hv",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "d",
            : "f",
            : "g",
            : "r",
            : "s",
            : "t",
            : "is",
            : "j",
            : "j",
            : "j",
            : "j",
            : "k",
            : "k",
            : "k",
            : "k",
            : "k",
            : "k",
            : "k",
            : "k",
            : "k",
            : "k",
            : "k",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "lj",
            : "s",
            : "s",
            : "s",
            : "s",
            : "m",
            : "m",
            : "m",
            : "m",
            : "m",
            : "m",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "n",
            : "nj",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "oi",
            : "oo",
            : "e",
            : "e",
            : "o",
            : "o",
            : "ou",
            : "p",
            : "p",
            : "p",
            : "p",
            : "p",
            : "p",
            : "p",
            : "p",
            : "p",
            : "q",
            : "q",
            : "q",
            : "q",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "r",
            : "c",
            : "c",
            : "e",
            : "r",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "s",
            : "g",
            : "ss",
            : "o",
            : "o",
            : "u",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "t",
            : "th",
            : "a",
            : "ae",
            : "e",
            : "g",
            : "h",
            : "h",
            : "h",
            : "i",
            : "k",
            : "l",
            : "m",
            : "m",
            : "oe",
            : "r",
            : "r",
            : "r",
            : "r",
            : "t",
            : "v",
            : "w",
            : "y",
            : "tz",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "ue",
            : "um",
            : "v",
            : "v",
            : "v",
            : "v",
            : "v",
            : "v",
            : "v",
            : "vy",
            : "w",
            : "w",
            : "w",
            : "w",
            : "w",
            : "w",
            : "w",
            : "w",
            : "x",
            : "x",
            : "x",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "y",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "z",
            : "ff",
            : "ffi",
            : "ffl",
            : "fi",
            : "fl",
            : "ij",
            : "oe",
            : "st",
            : "a",
            : "e",
            : "i",
            : "j",
            : "o",
            : "r",
            : "u",
            : "v",
            : "x",
          };

          //******************************************************************************
          // Added an initialize function which is essentially the code from the S
          // constructor.  Now, the S constructor calls this and a new method named
          // setValue calls it as well.  The setValue function allows constructors for
          // modules that extend string.js to set the initial value of an object without
          // knowing the internal workings of string.js.
          //
          // Also, all methods which return a new S object now call:
          //
          //      return new this.constructor(s);
          //
          // instead of:
          //
          //      return new S(s);
          //
          // This allows extended objects to keep their proper instanceOf and constructor.
          //******************************************************************************

          function initialize(object, s) {
            if (s !== null && s !== undefined) {
              if (typeof s === "string") object.s = s;
              else object.s = s.toString();
            } else {
              object.s = s; //null or undefined
            }

            object.orig = s; //original object, currently only used by toCSV() and toBoolean()

            if (s !== null && s !== undefined) {
              if (object.__defineGetter__) {
                object.__defineGetter__("length", function () {
                  return object.s.length;
                });
              } else {
                object.length = s.length;
              }
            } else {
              object.length = -1;
            }
          }

          function S(s) {
            initialize(this, s);
          }

          var __nsp = String.prototype;
          var __sp = (S.prototype = {
            between: function (left, right) {
              var s = this.s;
              var startPos = s.indexOf(left);
              var endPos = s.indexOf(right, startPos + left.length);
              if (endPos == -1 && right != null)
                return new this.constructor("");
              else if (endPos == -1 && right == null)
                return new this.constructor(
                  s.substring(startPos + left.length)
                );
              else
                return new this.constructor(
                  s.slice(startPos + left.length, endPos)
                );
            },

            //# modified slightly from https://github.com/epeli/underscore.string
            camelize: function () {
              var s = this.trim().s.replace(/(\-|_|\s)+(.)?/g, function (
                mathc,
                sep,
                c
              ) {
                return c ? c.toUpperCase() : "";
              });
              return new this.constructor(s);
            },

            capitalize: function () {
              return new this.constructor(
                this.s.substr(0, 1).toUpperCase() +
                  this.s.substring(1).toLowerCase()
              );
            },

            charAt: function (index) {
              return this.s.charAt(index);
            },

            chompLeft: function (prefix) {
              var s = this.s;
              if (s.indexOf(prefix) === 0) {
                s = s.slice(prefix.length);
                return new this.constructor(s);
              } else {
                return this;
              }
            },

            chompRight: function (suffix) {
              if (this.endsWith(suffix)) {
                var s = this.s;
                s = s.slice(0, s.length - suffix.length);
                return new this.constructor(s);
              } else {
                return this;
              }
            },

            //#thanks Google
            collapseWhitespace: function () {
              var s = this.s
                .replace(/[\s\xa0]+/g, " ")
                .replace(/^\s+|\s+$/g, "");
              return new this.constructor(s);
            },

            contains: function (ss) {
              return this.s.indexOf(ss) >= 0;
            },

            count: function (ss) {
              return require("./_count")(this.s, ss);
            },

            //#modified from https://github.com/epeli/underscore.string
            dasherize: function () {
              var s = this.trim()
                .s.replace(/[_\s]+/g, "-")
                .replace(/([A-Z])/g, "-$1")
                .replace(/-+/g, "-")
                .toLowerCase();
              return new this.constructor(s);
            },

            equalsIgnoreCase: function (prefix) {
              var s = this.s;
              return s.toLowerCase() == prefix.toLowerCase();
            },

            latinise: function () {
              var s = this.replace(/[^A-Za-z0-9\[\] ]/g, function (x) {
                return latin_map[x] || x;
              });
              return new this.constructor(s);
            },

            decodeHtmlEntities: function () {
              //https://github.com/substack/node-ent/blob/master/index.js
              var s = this.s;
              s = s
                .replace(/&#(\d+);?/g, function (_, code) {
                  return String.fromCharCode(code);
                })
                .replace(/&#[xX]([A-Fa-f0-9]+);?/g, function (_, hex) {
                  return String.fromCharCode(parseInt(hex, 16));
                })
                .replace(/&([^;\W]+;?)/g, function (m, e) {
                  var ee = e.replace(/;$/, "");
                  var target = ENTITIES[e] || (e.match(/;$/) && ENTITIES[ee]);

                  if (typeof target === "number") {
                    return String.fromCharCode(target);
                  } else if (typeof target === "string") {
                    return target;
                  } else {
                    return m;
                  }
                });

              return new this.constructor(s);
            },

            endsWith: function () {
              var suffixes = Array.prototype.slice.call(arguments, 0);
              for (var i = 0; i < suffixes.length; ++i) {
                var l = this.s.length - suffixes[i].length;
                if (l >= 0 && this.s.indexOf(suffixes[i], l) === l) return true;
              }
              return false;
            },

            escapeHTML: function () {
              //from underscore.string
              return new this.constructor(
                this.s.replace(/[&<>"']/g, function (m) {
                  return "&" + reversedEscapeChars[m] + ";";
                })
              );
            },

            ensureLeft: function (prefix) {
              var s = this.s;
              if (s.indexOf(prefix) === 0) {
                return this;
              } else {
                return new this.constructor(prefix + s);
              }
            },

            ensureRight: function (suffix) {
              var s = this.s;
              if (this.endsWith(suffix)) {
                return this;
              } else {
                return new this.constructor(s + suffix);
              }
            },

            humanize: function () {
              //modified from underscore.string
              if (this.s === null || this.s === undefined)
                return new this.constructor("");
              var s = this.underscore()
                .replace(/_id$/, "")
                .replace(/_/g, " ")
                .trim()
                .capitalize();
              return new this.constructor(s);
            },

            isAlpha: function () {
              return !/[^a-z\xDF-\xFF]|^$/.test(this.s.toLowerCase());
            },

            isAlphaNumeric: function () {
              return !/[^0-9a-z\xDF-\xFF]/.test(this.s.toLowerCase());
            },

            isEmpty: function () {
              return this.s === null || this.s === undefined
                ? true
                : /^[\s\xa0]*$/.test(this.s);
            },

            isLower: function () {
              return this.isAlpha() && this.s.toLowerCase() === this.s;
            },

            isNumeric: function () {
              return !/[^0-9]/.test(this.s);
            },

            isUpper: function () {
              return this.isAlpha() && this.s.toUpperCase() === this.s;
            },

            left: function (N) {
              if (N >= 0) {
                var s = this.s.substr(0, N);
                return new this.constructor(s);
              } else {
                return this.right(-N);
              }
            },

            lines: function () {
              //convert windows newlines to unix newlines then convert to an Array of lines
              return this.replaceAll("\r\n", "\n").s.split("\n");
            },

            pad: function (len, ch) {
              //https://github.com/component/pad
              if (ch == null) ch = " ";
              if (this.s.length >= len) return new this.constructor(this.s);
              len = len - this.s.length;
              var left = Array(Math.ceil(len / 2) + 1).join(ch);
              var right = Array(Math.floor(len / 2) + 1).join(ch);
              return new this.constructor(left + this.s + right);
            },

            padLeft: function (len, ch) {
              //https://github.com/component/pad
              if (ch == null) ch = " ";
              if (this.s.length >= len) return new this.constructor(this.s);
              return new this.constructor(
                Array(len - this.s.length + 1).join(ch) + this.s
              );
            },

            padRight: function (len, ch) {
              //https://github.com/component/pad
              if (ch == null) ch = " ";
              if (this.s.length >= len) return new this.constructor(this.s);
              return new this.constructor(
                this.s + Array(len - this.s.length + 1).join(ch)
              );
            },

            parseCSV: function (delimiter, qualifier, escape, lineDelimiter) {
              //try to parse no matter what
              delimiter = delimiter || ",";
              escape = escape || "\\";
              if (typeof qualifier == "undefined") qualifier = '"';

              var i = 0,
                fieldBuffer = [],
                fields = [],
                len = this.s.length,
                inField = false,
                inUnqualifiedString = false,
                self = this;
              var ca = function (i) {
                return self.s.charAt(i);
              };
              if (typeof lineDelimiter !== "undefined") var rows = [];

              if (!qualifier) inField = true;

              while (i < len) {
                var current = ca(i);
                switch (current) {
                  case escape:
                    //fix for issues #32 and #35
                    if (
                      inField &&
                      (escape !== qualifier || ca(i + 1) === qualifier)
                    ) {
                      i += 1;
                      fieldBuffer.push(ca(i));
                      break;
                    }
                    if (escape !== qualifier) break;
                  case qualifier:
                    inField = !inField;
                    break;
                  case delimiter:
                    if (inUnqualifiedString) {
                      inField = false;
                      inUnqualifiedString = false;
                    }
                    if (inField && qualifier) fieldBuffer.push(current);
                    else {
                      fields.push(fieldBuffer.join(""));
                      fieldBuffer.length = 0;
                    }
                    break;
                  case lineDelimiter:
                    if (inUnqualifiedString) {
                      inField = false;
                      inUnqualifiedString = false;
                      fields.push(fieldBuffer.join(""));
                      rows.push(fields);
                      fields = [];
                      fieldBuffer.length = 0;
                    } else if (inField) {
                      fieldBuffer.push(current);
                    } else {
                      if (rows) {
                        fields.push(fieldBuffer.join(""));
                        rows.push(fields);
                        fields = [];
                        fieldBuffer.length = 0;
                      }
                    }
                    break;
                  case " ":
                    if (inField) fieldBuffer.push(current);
                    break;
                  default:
                    if (inField) fieldBuffer.push(current);
                    else if (current !== qualifier) {
                      fieldBuffer.push(current);
                      inField = true;
                      inUnqualifiedString = true;
                    }
                    break;
                }
                i += 1;
              }

              fields.push(fieldBuffer.join(""));
              if (rows) {
                rows.push(fields);
                return rows;
              }
              return fields;
            },

            replaceAll: function (ss, r) {
              //var s = this.s.replace(new RegExp(ss, 'g'), r);
              var s = this.s.split(ss).join(r);
              return new this.constructor(s);
            },

            splitLeft: function (sep, maxSplit, limit) {
              return require("./_splitLeft")(this.s, sep, maxSplit, limit);
            },

            splitRight: function (sep, maxSplit, limit) {
              return require("./_splitRight")(this.s, sep, maxSplit, limit);
            },

            strip: function () {
              var ss = this.s;
              for (var i = 0, n = arguments.length; i < n; i++) {
                ss = ss.split(arguments[i]).join("");
              }
              return new this.constructor(ss);
            },

            stripLeft: function (chars) {
              var regex;
              var pattern;
              var ss = ensureString(this.s);

              if (chars === undefined) {
                pattern = /^\s+/g;
              } else {
                regex = escapeRegExp(chars);
                pattern = new RegExp("^[" + regex + "]+", "g");
              }

              return new this.constructor(ss.replace(pattern, ""));
            },

            stripRight: function (chars) {
              var regex;
              var pattern;
              var ss = ensureString(this.s);

              if (chars === undefined) {
                pattern = /\s+$/g;
              } else {
                regex = escapeRegExp(chars);
                pattern = new RegExp("[" + regex + "]+$", "g");
              }

              return new this.constructor(ss.replace(pattern, ""));
            },

            right: function (N) {
              if (N >= 0) {
                var s = this.s.substr(this.s.length - N, N);
                return new this.constructor(s);
              } else {
                return this.left(-N);
              }
            },

            setValue: function (s) {
              initialize(this, s);
              return this;
            },

            slugify: function () {
              var sl = new S(
                new S(this.s)
                  .latinise()
                  .s.replace(/[^\w\s-]/g, "")
                  .toLowerCase()
              ).dasherize().s;
              if (sl.charAt(0) === "-") sl = sl.substr(1);
              return new this.constructor(sl);
            },

            startsWith: function () {
              var prefixes = Array.prototype.slice.call(arguments, 0);
              for (var i = 0; i < prefixes.length; ++i) {
                if (this.s.lastIndexOf(prefixes[i], 0) === 0) return true;
              }
              return false;
            },

            stripPunctuation: function () {
              //return new this.constructor(this.s.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g,""));
              return new this.constructor(
                this.s.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ")
              );
            },

            stripTags: function () {
              //from sugar.js
              var s = this.s,
                args = arguments.length > 0 ? arguments : [""];
              multiArgs(args, function (tag) {
                s = s.replace(RegExp("</?" + tag + "[^<>]*>", "gi"), "");
              });
              return new this.constructor(s);
            },

            template: function (values, opening, closing) {
              var s = this.s;
              var opening = opening || Export.TMPL_OPEN;
              var closing = closing || Export.TMPL_CLOSE;

              var open = opening
                .replace(/[-[\]()*\s]/g, "\\$&")
                .replace(/\$/g, "\\$");
              var close = closing
                .replace(/[-[\]()*\s]/g, "\\$&")
                .replace(/\$/g, "\\$");
              var r = new RegExp(open + "(.+?)" + close, "g");
              //, r = /\{\{(.+?)\}\}/g
              var matches = s.match(r) || [];

              matches.forEach(function (match) {
                var key = match
                  .substring(opening.length, match.length - closing.length)
                  .trim(); //chop {{ and }}
                var value =
                  typeof values[key] == "undefined" ? "" : values[key];
                s = s.replace(match, value);
              });
              return new this.constructor(s);
            },

            times: function (n) {
              return new this.constructor(new Array(n + 1).join(this.s));
            },

            titleCase: function () {
              var s = this.s;
              if (s) {
                s = s.replace(/(^[a-z]| [a-z]|-[a-z]|_[a-z])/g, function ($1) {
                  return $1.toUpperCase();
                });
              }
              return new this.constructor(s);
            },

            toBoolean: function () {
              if (typeof this.orig === "string") {
                var s = this.s.toLowerCase();
                return s === "true" || s === "yes" || s === "on" || s === "1";
              } else return this.orig === true || this.orig === 1;
            },

            toFloat: function (precision) {
              var num = parseFloat(this.s);
              if (precision) return parseFloat(num.toFixed(precision));
              else return num;
            },

            toInt: function () {
              //thanks Google
              // If the string starts with '0x' or '-0x', parse as hex.
              return /^\s*-?0x/i.test(this.s)
                ? parseInt(this.s, 16)
                : parseInt(this.s, 10);
            },

            trim: function () {
              var s;
              if (typeof __nsp.trim === "undefined")
                s = this.s.replace(/(^\s*|\s*$)/g, "");
              else s = this.s.trim();
              return new this.constructor(s);
            },

            trimLeft: function () {
              var s;
              if (__nsp.trimLeft) s = this.s.trimLeft();
              else s = this.s.replace(/(^\s*)/g, "");
              return new this.constructor(s);
            },

            trimRight: function () {
              var s;
              if (__nsp.trimRight) s = this.s.trimRight();
              else s = this.s.replace(/\s+$/, "");
              return new this.constructor(s);
            },

            truncate: function (length, pruneStr) {
              //from underscore.string, author: github.com/rwz
              var str = this.s;

              length = ~~length;
              pruneStr = pruneStr || "...";

              if (str.length <= length) return new this.constructor(str);

              var tmpl = function (c) {
                  return c.toUpperCase() !== c.toLowerCase() ? "A" : " ";
                },
                template = str
                  .slice(0, length + 1)
                  .replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

              if (template.slice(template.length - 2).match(/\w\w/))
                template = template.replace(/\s*\S+$/, "");
              else
                template = new S(
                  template.slice(0, template.length - 1)
                ).trimRight().s;

              return (template + pruneStr).length > str.length
                ? new S(str)
                : new S(str.slice(0, template.length) + pruneStr);
            },

            toCSV: function () {
              var delim = ",",
                qualifier = '"',
                escape = "\\",
                encloseNumbers = true,
                keys = false;
              var dataArray = [];

              function hasVal(it) {
                return it !== null && it !== "";
              }

              if (typeof arguments[0] === "object") {
                delim = arguments[0].delimiter || delim;
                delim = arguments[0].separator || delim;
                qualifier = arguments[0].qualifier || qualifier;
                encloseNumbers = !!arguments[0].encloseNumbers;
                escape = arguments[0].escape || escape;
                keys = !!arguments[0].keys;
              } else if (typeof arguments[0] === "string") {
                delim = arguments[0];
              }

              if (typeof arguments[1] === "string") qualifier = arguments[1];

              if (arguments[1] === null) qualifier = null;

              if (this.orig instanceof Array) dataArray = this.orig;
              else {
                //object
                for (var key in this.orig)
                  if (this.orig.hasOwnProperty(key))
                    if (keys) dataArray.push(key);
                    else dataArray.push(this.orig[key]);
              }

              var rep = escape + qualifier;
              var buildString = [];
              for (var i = 0; i < dataArray.length; ++i) {
                var shouldQualify = hasVal(qualifier);
                if (typeof dataArray[i] == "number")
                  shouldQualify &= encloseNumbers;

                if (shouldQualify) buildString.push(qualifier);

                if (dataArray[i] !== null && dataArray[i] !== undefined) {
                  var d = new S(dataArray[i]).replaceAll(qualifier, rep).s;
                  buildString.push(d);
                } else buildString.push("");

                if (shouldQualify) buildString.push(qualifier);

                if (delim) buildString.push(delim);
              }

              //chop last delim
              //console.log(buildString.length)
              buildString.length = buildString.length - 1;
              return new this.constructor(buildString.join(""));
            },

            toString: function () {
              return this.s;
            },

            //#modified from https://github.com/epeli/underscore.string
            underscore: function () {
              var s = this.trim()
                .s.replace(/([a-z\d])([A-Z]+)/g, "$1_$2")
                .replace(/([A-Z\d]+)([A-Z][a-z])/g, "$1_$2")
                .replace(/[-\s]+/g, "_")
                .toLowerCase();
              return new this.constructor(s);
            },

            unescapeHTML: function () {
              //from underscore.string
              return new this.constructor(
                this.s.replace(/\&([^;]+);/g, function (entity, entityCode) {
                  var match;

                  if (entityCode in escapeChars) {
                    return escapeChars[entityCode];
                  } else if ((match = entityCode.match(/^#x([\da-fA-F]+)$/))) {
                    return String.fromCharCode(parseInt(match[1], 16));
                  } else if ((match = entityCode.match(/^#(\d+)$/))) {
                    return String.fromCharCode(~~match[1]);
                  } else {
                    return entity;
                  }
                })
              );
            },

            valueOf: function () {
              return this.s.valueOf();
            },

            //#Added a New Function called wrapHTML.
            wrapHTML: function (tagName, tagAttrs) {
              var s = this.s,
                el = tagName == null ? "span" : tagName,
                elAttr = "",
                wrapped = "";
              if (typeof tagAttrs == "object")
                for (var prop in tagAttrs)
                  elAttr +=
                    " " +
                    prop +
                    '="' +
                    new this.constructor(tagAttrs[prop]).escapeHTML() +
                    '"';
              s = wrapped.concat("<", el, elAttr, ">", this, "</", el, ">");
              return new this.constructor(s);
            },
          });

          var methodsAdded = [];
          function extendPrototype() {
            for (var name in __sp) {
              (function (name) {
                var func = __sp[name];
                if (!__nsp.hasOwnProperty(name)) {
                  methodsAdded.push(name);
                  __nsp[name] = function () {
                    String.prototype.s = this;
                    return func.apply(this, arguments);
                  };
                }
              })(name);
            }
          }

          function restorePrototype() {
            for (var i = 0; i < methodsAdded.length; ++i)
              delete String.prototype[methodsAdded[i]];
            methodsAdded.length = 0;
          }

          /*************************************
/* Attach Native JavaScript String Properties
/*************************************/

          var nativeProperties = getNativeStringProperties();
          for (var name in nativeProperties) {
            (function (name) {
              var stringProp = __nsp[name];
              if (typeof stringProp == "function") {
                //console.log(stringProp)
                if (!__sp[name]) {
                  if (nativeProperties[name] === "string") {
                    __sp[name] = function () {
                      //console.log(name)
                      return new this.constructor(
                        stringProp.apply(this, arguments)
                      );
                    };
                  } else {
                    __sp[name] = stringProp;
                  }
                }
              }
            })(name);
          }

          /*************************************
/* Function Aliases
/*************************************/

          __sp.repeat = __sp.times;
          __sp.include = __sp.contains;
          __sp.toInteger = __sp.toInt;
          __sp.toBool = __sp.toBoolean;
          __sp.decodeHTMLEntities = __sp.decodeHtmlEntities; //ensure consistent casing scheme of 'HTML'

          //******************************************************************************
          // Set the constructor.  Without this, string.js objects are instances of
          // Object instead of S.
          //******************************************************************************

          __sp.constructor = S;

          /*************************************
/* Private Functions
/*************************************/

          function getNativeStringProperties() {
            var names = getNativeStringPropertyNames();
            var retObj = {};

            for (var i = 0; i < names.length; ++i) {
              var name = names[i];
              if (name === "to" || name === "toEnd") continue; // get rid of the shelljs prototype messup
              var func = __nsp[name];
              try {
                var type = typeof func.apply("teststring");
                retObj[name] = type;
              } catch (e) {}
            }
            return retObj;
          }

          function getNativeStringPropertyNames() {
            var results = [];
            if (Object.getOwnPropertyNames) {
              results = Object.getOwnPropertyNames(__nsp);
              results.splice(results.indexOf("valueOf"), 1);
              results.splice(results.indexOf("toString"), 1);
              return results;
            } else {
              //meant for legacy cruft, this could probably be made more efficient
              var stringNames = {};
              var objectNames = [];
              for (var name in String.prototype) stringNames[name] = name;

              for (var name in Object.prototype) delete stringNames[name];

              //stringNames['toString'] = 'toString'; //this was deleted with the rest of the object names
              for (var name in stringNames) {
                results.push(name);
              }
              return results;
            }
          }

          function Export(str) {
            return new S(str);
          }

          //attach exports to StringJSWrapper
          Export.extendPrototype = extendPrototype;
          Export.restorePrototype = restorePrototype;
          Export.VERSION = VERSION;
          Export.TMPL_OPEN = "{{";
          Export.TMPL_CLOSE = "}}";
          Export.ENTITIES = ENTITIES;

          /*************************************
/* Exports
/*************************************/

          if (
            typeof module !== "undefined" &&
            typeof module.exports !== "undefined"
          ) {
            module.exports = Export;
          } else {
            if (typeof define === "function" && define.amd) {
              define([], function () {
                return Export;
              });
            } else {
              window.S = Export;
            }
          }

          /*************************************
/* 3rd Party Private Functions
/*************************************/

          //from sugar.js
          function multiArgs(args, fn) {
            var result = [],
              i;
            for (i = 0; i < args.length; i++) {
              result.push(args[i]);
              if (fn) fn.call(args, args[i], i);
            }
            return result;
          }

          //from underscore.string
          var escapeChars = {
            lt: "<",
            gt: ">",
            quot: '"',
            apos: "'",
            amp: "&",
          };

          function escapeRegExp(s) {
            // most part from https://github.com/skulpt/skulpt/blob/ecaf75e69c2e539eff124b2ab45df0b01eaf2295/src/str.js#L242
            var c;
            var i;
            var ret = [];
            var re = /^[A-Za-z0-9]+$/;
            s = ensureString(s);
            for (i = 0; i < s.length; ++i) {
              c = s.charAt(i);

              if (re.test(c)) {
                ret.push(c);
              } else {
                if (c === "\\000") {
                  ret.push("\\000");
                } else {
                  ret.push("\\" + c);
                }
              }
            }
            return ret.join("");
          }

          function ensureString(string) {
            return string == null ? "" : "" + string;
          }

          //from underscore.string
          var reversedEscapeChars = {};
          for (var key in escapeChars) {
            reversedEscapeChars[escapeChars[key]] = key;
          }

          ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'",
            AElig: 198,
            Aacute: 193,
            Acirc: 194,
            Agrave: 192,
            Aring: 197,
            Atilde: 195,
            Auml: 196,
            Ccedil: 199,
            ETH: 208,
            Eacute: 201,
            Ecirc: 202,
            Egrave: 200,
            Euml: 203,
            Iacute: 205,
            Icirc: 206,
            Igrave: 204,
            Iuml: 207,
            Ntilde: 209,
            Oacute: 211,
            Ocirc: 212,
            Ograve: 210,
            Oslash: 216,
            Otilde: 213,
            Ouml: 214,
            THORN: 222,
            Uacute: 218,
            Ucirc: 219,
            Ugrave: 217,
            Uuml: 220,
            Yacute: 221,
            aacute: 225,
            acirc: 226,
            aelig: 230,
            agrave: 224,
            aring: 229,
            atilde: 227,
            auml: 228,
            ccedil: 231,
            eacute: 233,
            ecirc: 234,
            egrave: 232,
            eth: 240,
            euml: 235,
            iacute: 237,
            icirc: 238,
            igrave: 236,
            iuml: 239,
            ntilde: 241,
            oacute: 243,
            ocirc: 244,
            ograve: 242,
            oslash: 248,
            otilde: 245,
            ouml: 246,
            szlig: 223,
            thorn: 254,
            uacute: 250,
            ucirc: 251,
            ugrave: 249,
            uuml: 252,
            yacute: 253,
            yuml: 255,
            copy: 169,
            reg: 174,
            nbsp: 160,
            iexcl: 161,
            cent: 162,
            pound: 163,
            curren: 164,
            yen: 165,
            brvbar: 166,
            sect: 167,
            uml: 168,
            ordf: 170,
            laquo: 171,
            not: 172,
            shy: 173,
            macr: 175,
            deg: 176,
            plusmn: 177,
            sup1: 185,
            sup2: 178,
            sup3: 179,
            acute: 180,
            micro: 181,
            para: 182,
            middot: 183,
            cedil: 184,
            ordm: 186,
            raquo: 187,
            frac14: 188,
            frac12: 189,
            frac34: 190,
            iquest: 191,
            times: 215,
            divide: 247,
            "OElig;": 338,
            "oelig;": 339,
            "Scaron;": 352,
            "scaron;": 353,
            "Yuml;": 376,
            "fnof;": 402,
            "circ;": 710,
            "tilde;": 732,
            "Alpha;": 913,
            "Beta;": 914,
            "Gamma;": 915,
            "Delta;": 916,
            "Epsilon;": 917,
            "Zeta;": 918,
            "Eta;": 919,
            "Theta;": 920,
            "Iota;": 921,
            "Kappa;": 922,
            "Lambda;": 923,
            "Mu;": 924,
            "Nu;": 925,
            "Xi;": 926,
            "Omicron;": 927,
            "Pi;": 928,
            "Rho;": 929,
            "Sigma;": 931,
            "Tau;": 932,
            "Upsilon;": 933,
            "Phi;": 934,
            "Chi;": 935,
            "Psi;": 936,
            "Omega;": 937,
            "alpha;": 945,
            "beta;": 946,
            "gamma;": 947,
            "delta;": 948,
            "epsilon;": 949,
            "zeta;": 950,
            "eta;": 951,
            "theta;": 952,
            "iota;": 953,
            "kappa;": 954,
            "lambda;": 955,
            "mu;": 956,
            "nu;": 957,
            "xi;": 958,
            "omicron;": 959,
            "pi;": 960,
            "rho;": 961,
            "sigmaf;": 962,
            "sigma;": 963,
            "tau;": 964,
            "upsilon;": 965,
            "phi;": 966,
            "chi;": 967,
            "psi;": 968,
            "omega;": 969,
            "thetasym;": 977,
            "upsih;": 978,
            "piv;": 982,
            "ensp;": 8194,
            "emsp;": 8195,
            "thinsp;": 8201,
            "zwnj;": 8204,
            "zwj;": 8205,
            "lrm;": 8206,
            "rlm;": 8207,
            "ndash;": 8211,
            "mdash;": 8212,
            "lsquo;": 8216,
            "rsquo;": 8217,
            "sbquo;": 8218,
            "ldquo;": 8220,
            "rdquo;": 8221,
            "bdquo;": 8222,
            "dagger;": 8224,
            "Dagger;": 8225,
            "bull;": 8226,
            "hellip;": 8230,
            "permil;": 8240,
            "prime;": 8242,
            "Prime;": 8243,
            "lsaquo;": 8249,
            "rsaquo;": 8250,
            "oline;": 8254,
            "frasl;": 8260,
            "euro;": 8364,
            "image;": 8465,
            "weierp;": 8472,
            "real;": 8476,
            "trade;": 8482,
            "alefsym;": 8501,
            "larr;": 8592,
            "uarr;": 8593,
            "rarr;": 8594,
            "darr;": 8595,
            "harr;": 8596,
            "crarr;": 8629,
            "lArr;": 8656,
            "uArr;": 8657,
            "rArr;": 8658,
            "dArr;": 8659,
            "hArr;": 8660,
            "forall;": 8704,
            "part;": 8706,
            "exist;": 8707,
            "empty;": 8709,
            "nabla;": 8711,
            "isin;": 8712,
            "notin;": 8713,
            "ni;": 8715,
            "prod;": 8719,
            "sum;": 8721,
            "minus;": 8722,
            "lowast;": 8727,
            "radic;": 8730,
            "prop;": 8733,
            "infin;": 8734,
            "ang;": 8736,
            "and;": 8743,
            "or;": 8744,
            "cap;": 8745,
            "cup;": 8746,
            "int;": 8747,
            "there4;": 8756,
            "sim;": 8764,
            "cong;": 8773,
            "asymp;": 8776,
            "ne;": 8800,
            "equiv;": 8801,
            "le;": 8804,
            "ge;": 8805,
            "sub;": 8834,
            "sup;": 8835,
            "nsub;": 8836,
            "sube;": 8838,
            "supe;": 8839,
            "oplus;": 8853,
            "otimes;": 8855,
            "perp;": 8869,
            "sdot;": 8901,
            "lceil;": 8968,
            "rceil;": 8969,
            "lfloor;": 8970,
            "rfloor;": 8971,
            "lang;": 9001,
            "rang;": 9002,
            "loz;": 9674,
            "spades;": 9824,
            "clubs;": 9827,
            "hearts;": 9829,
            "diams;": 9830,
          };
        }.call(this);
      },
      { "./_count": 557, "./_splitLeft": 558, "./_splitRight": 559 },
    ],
    561: [
      function (require, module, exports) {
        arguments[4][95][0].apply(exports, arguments);
      },
      { dup: 95, "safe-buffer": 562 },
    ],
    562: [
      function (require, module, exports) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
        /* eslint-disable node/no-deprecated-api */
        var buffer = require("buffer");
        var Buffer = buffer.Buffer;

        // alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (
          Buffer.from &&
          Buffer.alloc &&
          Buffer.allocUnsafe &&
          Buffer.allocUnsafeSlow
        ) {
          module.exports = buffer;
        } else {
          // Copy properties from require('buffer')
          copyProps(buffer, exports);
          exports.Buffer = SafeBuffer;
        }

        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }

        SafeBuffer.prototype = Object.create(Buffer.prototype);

        // Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer);

        SafeBuffer.from = function (arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };

        SafeBuffer.alloc = function (size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== undefined) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };

        SafeBuffer.allocUnsafe = function (size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };

        SafeBuffer.allocUnsafeSlow = function (size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      },
      { buffer: 50 },
    ],
    563: [
      function (require, module, exports) {
        (function (setImmediate, clearImmediate) {
          var nextTick = require("process/browser.js").nextTick;
          var apply = Function.prototype.apply;
          var slice = Array.prototype.slice;
          var immediateIds = {};
          var nextImmediateId = 0;

          // DOM APIs, for completeness

          exports.setTimeout = function () {
            return new Timeout(
              apply.call(setTimeout, window, arguments),
              clearTimeout
            );
          };
          exports.setInterval = function () {
            return new Timeout(
              apply.call(setInterval, window, arguments),
              clearInterval
            );
          };
          exports.clearTimeout = exports.clearInterval = function (timeout) {
            timeout.close();
          };

          function Timeout(id, clearFn) {
            this._id = id;
            this._clearFn = clearFn;
          }
          Timeout.prototype.unref = Timeout.prototype.ref = function () {};
          Timeout.prototype.close = function () {
            this._clearFn.call(window, this._id);
          };

          // Does not start the time, just sets up the members needed.
          exports.enroll = function (item, msecs) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = msecs;
          };

          exports.unenroll = function (item) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = -1;
          };

          exports._unrefActive = exports.active = function (item) {
            clearTimeout(item._idleTimeoutId);

            var msecs = item._idleTimeout;
            if (msecs >= 0) {
              item._idleTimeoutId = setTimeout(function onTimeout() {
                if (item._onTimeout) item._onTimeout();
              }, msecs);
            }
          };

          // That's not how node.js implements it but the exposed api is the same.
          exports.setImmediate =
            typeof setImmediate === "function"
              ? setImmediate
              : function (fn) {
                  var id = nextImmediateId++;
                  var args =
                    arguments.length < 2 ? false : slice.call(arguments, 1);

                  immediateIds[id] = true;

                  nextTick(function onNextTick() {
                    if (immediateIds[id]) {
                      // fn.call() is faster so we optimize for the common use-case
                      // @see http://jsperf.com/call-apply-segu
                      if (args) {
                        fn.apply(null, args);
                      } else {
                        fn.call(null);
                      }
                      // Prevent ids from leaking
                      exports.clearImmediate(id);
                    }
                  });

                  return id;
                };

          exports.clearImmediate =
            typeof clearImmediate === "function"
              ? clearImmediate
              : function (id) {
                  delete immediateIds[id];
                };
        }.call(
          this,
          require("timers").setImmediate,
          require("timers").clearImmediate
        ));
      },
      { "process/browser.js": 80, timers: 563 },
    ],
    564: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const injection_handler_1 = require("./injection-handler");
        const model_1 = require("../model");
        const get = require("lodash.get");
        const set = require("lodash.set");
        class IoCBindConfig {
          constructor(source, instanceFactory, valueFactory) {
            this.source = source;
            this.instanceFactory = instanceFactory;
            this.valueFactory = valueFactory;
          }
          to(target) {
            injection_handler_1.InjectorHandler.checkType(target);
            const targetSource = injection_handler_1.InjectorHandler.getConstructorFromType(
              target
            );
            this.targetSource = targetSource;
            if (this.source === targetSource) {
              this.factory((context) => {
                const params = this.getParameters(context);
                const constructor = this.decoratedConstructor || target;
                return params ? new constructor(...params) : new constructor();
              });
            } else {
              this.factory((context) => {
                return this.instanceFactory(target, context);
              });
            }
            return this;
          }
          factory(factory) {
            this.iocFactory = (context) => {
              const blocked = injection_handler_1.InjectorHandler.unblockInstantiation();
              const constructor =
                this.decoratedConstructor || this.targetSource || this.source;
              injection_handler_1.InjectorHandler.injectContext(
                constructor,
                context
              );
              const instance = factory(context);
              injection_handler_1.InjectorHandler.removeContext(constructor);
              injection_handler_1.InjectorHandler.injectContext(
                instance,
                context
              );
              injection_handler_1.InjectorHandler.blockInstantiation(blocked);
              return instance;
            };
            if (this.iocScope) {
              this.iocScope.reset(this.source);
            }
            return this;
          }
          scope(scope) {
            if (this.iocScope && this.iocScope !== scope) {
              this.iocScope.finish(this.source);
            }
            this.iocScope = scope;
            if (this.iocScope) {
              this.iocScope.init(this.source);
            }
            return this;
          }
          withParams(...paramTypes) {
            this.paramTypes = paramTypes;
            return this;
          }
          instrumentConstructor() {
            const newConstructor = injection_handler_1.InjectorHandler.instrumentConstructor(
              this.source
            );
            this.decoratedConstructor = newConstructor;
            this.source.constructor = newConstructor;
            return this;
          }
          getInstance(context) {
            if (!this.iocScope) {
              this.scope(model_1.Scope.Local);
            }
            return this.iocScope.resolve(this.iocFactory, this.source, context);
          }
          clone() {
            const result = new IoCBindConfig(
              this.source,
              this.instanceFactory,
              this.valueFactory
            );
            result.iocFactory = this.iocFactory;
            result.iocScope = this.iocScope;
            result.targetSource = this.targetSource;
            result.paramTypes = this.paramTypes;
            result.decoratedConstructor = this.decoratedConstructor;
            return result;
          }
          getParameters(context) {
            if (this.paramTypes) {
              return this.paramTypes.map((paramType) => {
                if (
                  typeof paramType === "string" ||
                  paramType instanceof String
                ) {
                  return this.valueFactory(paramType);
                }
                return this.instanceFactory(paramType, context);
              });
            }
            return null;
          }
        }
        exports.IoCBindConfig = IoCBindConfig;
        class IoCBindValueConfig {
          constructor(name) {
            this.name = name;
          }
          to(value) {
            if (this.path) {
              this.value = this.value || {};
              set(this.value, this.path, value);
            } else {
              this.value = value;
            }
            return this;
          }
          getValue() {
            if (this.path) {
              return get(this.value, this.path);
            }
            return this.value;
          }
          clone() {
            const result = new IoCBindValueConfig(this.name);
            result.path = this.path;
            result.value = this.value;
            return result;
          }
        }
        exports.IoCBindValueConfig = IoCBindValueConfig;
        class PropertyPath {
          constructor(name, path) {
            this.name = name;
            this.path = path;
          }
          static parse(value) {
            const index = value.indexOf(".");
            if (index < 0) {
              return new PropertyPath(value);
            } else if (index === 0) {
              throw new TypeError(
                `Invalid value [${value}] passed to Container.bindName`
              );
            } else if (index + 1 < value.length) {
              return new PropertyPath(
                value.substring(0, index),
                value.substring(index + 1)
              );
            }
            return new PropertyPath(value.substring(0, index));
          }
        }
        exports.PropertyPath = PropertyPath;
      },
      {
        "../model": 569,
        "./injection-handler": 567,
        "lodash.get": 69,
        "lodash.set": 70,
      },
    ],
    565: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        class ContainerNamespaces {
          constructor() {
            this.defaultNamespace = new NamespaceBindings(null);
            this.namespaces = new Map();
          }
          get(type) {
            let result;
            if (this.currentNamespace) {
              result = this.currentNamespace.get(type);
              if (result) {
                return result;
              }
            }
            return this.defaultNamespace.get(type);
          }
          set(type, bindConfig) {
            (this.currentNamespace || this.defaultNamespace).set(
              type,
              bindConfig
            );
          }
          getValue(name) {
            let result;
            if (this.currentNamespace) {
              result = this.currentNamespace.getValue(name);
              if (result) {
                return result;
              }
            }
            return this.defaultNamespace.getValue(name);
          }
          setValue(name, bindConfig) {
            (this.currentNamespace || this.defaultNamespace).setValue(
              name,
              bindConfig
            );
          }
          selectNamespace(name) {
            if (name) {
              let namespace = this.namespaces.get(name);
              if (!namespace) {
                namespace = new NamespaceBindings(name);
                this.namespaces.set(name, namespace);
              }
              this.currentNamespace = namespace;
            } else {
              this.currentNamespace = null;
            }
          }
          removeNamespace(name) {
            const namespace = this.namespaces.get(name);
            if (namespace) {
              if (
                this.currentNamespace &&
                namespace.name === this.currentNamespace.name
              ) {
                this.currentNamespace = null;
              }
              namespace.clear();
              this.namespaces.delete(name);
            }
          }
          selectedNamespace() {
            return this.currentNamespace ? this.currentNamespace.name : null;
          }
        }
        exports.ContainerNamespaces = ContainerNamespaces;
        class NamespaceBindings {
          constructor(name) {
            this.bindings = new Map();
            this.values = new Map();
            this.name = name;
          }
          get(type) {
            return this.bindings.get(type);
          }
          set(type, bindConfig) {
            bindConfig.namespace = this.name;
            this.bindings.set(type, bindConfig);
          }
          getValue(name) {
            return this.values.get(name);
          }
          setValue(name, bindConfig) {
            bindConfig.namespace = this.name;
            this.values.set(name, bindConfig);
          }
          clear() {
            this.bindings.clear();
            this.values.clear();
          }
        }
      },
      {},
    ],
    566: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const injection_handler_1 = require("./injection-handler");
        const container_binding_config_1 = require("./container-binding-config");
        const container_namespaces_1 = require("./container-namespaces");
        /**
         * Internal implementation of IoC Container.
         */
        class IoCContainer {
          static bind(source, readOnly = false) {
            injection_handler_1.InjectorHandler.checkType(source);
            const baseSource = injection_handler_1.InjectorHandler.getConstructorFromType(
              source
            );
            let config = IoCContainer.namespaces.get(baseSource);
            if (!config) {
              config = new container_binding_config_1.IoCBindConfig(
                baseSource,
                IoCContainer.get,
                IoCContainer.getValue
              );
              config.to(source);
              IoCContainer.namespaces.set(baseSource, config);
            } else if (
              !readOnly &&
              config.namespace !== IoCContainer.namespaces.selectedNamespace()
            ) {
              config = config.clone();
              IoCContainer.namespaces.set(baseSource, config);
            }
            return config;
          }
          static bindName(name, readOnly = false) {
            injection_handler_1.InjectorHandler.checkName(name);
            const property = container_binding_config_1.PropertyPath.parse(
              name
            );
            let config = IoCContainer.namespaces.getValue(property.name);
            if (!config) {
              config = new container_binding_config_1.IoCBindValueConfig(
                property.name
              );
              IoCContainer.namespaces.setValue(property.name, config);
            } else if (
              !readOnly &&
              config.namespace !== IoCContainer.namespaces.selectedNamespace()
            ) {
              config = config.clone();
              IoCContainer.namespaces.setValue(property.name, config);
            }
            config.path = property.path;
            return config;
          }
          static get(source, context) {
            const config = IoCContainer.bind(source, true);
            if (!config.iocFactory) {
              config.to(config.source);
            }
            return config.getInstance(context);
          }
          static getValue(name) {
            const config = IoCContainer.bindName(name, true);
            return config.getValue();
          }
          static getType(source) {
            injection_handler_1.InjectorHandler.checkType(source);
            const baseSource = injection_handler_1.InjectorHandler.getConstructorFromType(
              source
            );
            const config = IoCContainer.namespaces.get(baseSource);
            if (!config) {
              throw new TypeError(
                `The type ${source.name} hasn't been registered with the IOC Container`
              );
            }
            return config.targetSource || config.source;
          }
          static namespace(name) {
            IoCContainer.namespaces.selectNamespace(name);
            return {
              remove: () => {
                if (name) {
                  IoCContainer.namespaces.removeNamespace(name);
                }
              },
            };
          }
          static selectedNamespace() {
            return IoCContainer.namespaces.selectedNamespace();
          }
          static injectProperty(target, key, propertyType) {
            injection_handler_1.InjectorHandler.injectProperty(
              target,
              key,
              propertyType,
              IoCContainer.get
            );
          }
          static injectValueProperty(target, key, name) {
            injection_handler_1.InjectorHandler.injectValueProperty(
              target,
              key,
              name,
              IoCContainer.getValue
            );
          }
          /**
           * Create a temporary namespace. Useful for testing.
           */
          static snapshot() {
            const name = `_snapshot-${IoCContainer.snapshotsCount++}`;
            const namespace = IoCContainer.namespace(name);
            return {
              restore: () => namespace.remove(),
              select: () => IoCContainer.namespace(name),
            };
          }
        }
        exports.IoCContainer = IoCContainer;
        IoCContainer.namespaces = new container_namespaces_1.ContainerNamespaces();
        IoCContainer.snapshotsCount = 0;
      },
      {
        "./container-binding-config": 564,
        "./container-namespaces": 565,
        "./injection-handler": 567,
      },
    ],
    567: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const BUILD_CONTEXT_KEY = "__BuildContext";
        const IOC_WRAPPER_CLASS = "ioc_wrapper";
        /**
         * Utility class to handle injection behavior on class decorations.
         */
        class InjectorHandler {
          static instrumentConstructor(source) {
            let newConstructor;
            // tslint:disable-next-line:class-name
            newConstructor = class ioc_wrapper extends source {
              constructor(...args) {
                super(...args);
                InjectorHandler.assertInstantiable();
              }
            };
            newConstructor["__parent"] = source;
            return newConstructor;
          }
          static blockInstantiation(blocked) {
            InjectorHandler.instantiationsBlocked = blocked;
          }
          static unblockInstantiation() {
            const blocked = InjectorHandler.instantiationsBlocked;
            InjectorHandler.instantiationsBlocked = false;
            return blocked;
          }
          static getConstructorFromType(target) {
            let typeConstructor = target;
            if (this.hasNamedConstructor(typeConstructor)) {
              return typeConstructor;
            }
            typeConstructor = typeConstructor["__parent"];
            while (typeConstructor) {
              if (this.hasNamedConstructor(typeConstructor)) {
                return typeConstructor;
              }
              typeConstructor = typeConstructor["__parent"];
            }
            throw TypeError(
              "Can not identify the base Type for requested target " +
                target.toString()
            );
          }
          static checkType(source) {
            if (!source) {
              throw new TypeError(
                "Invalid type requested to IoC " +
                  "container. Type is not defined."
              );
            }
          }
          static checkName(source) {
            if (!source) {
              throw new TypeError(
                "Invalid name requested to IoC " +
                  "container. Name is not defined."
              );
            }
          }
          static injectContext(target, context) {
            target[BUILD_CONTEXT_KEY] = context;
          }
          static removeContext(target) {
            delete target[BUILD_CONTEXT_KEY];
          }
          static injectProperty(target, key, propertyType, instanceFactory) {
            const propKey = `__${key}`;
            Object.defineProperty(target.prototype, key, {
              enumerable: true,
              get: function () {
                const context =
                  this[BUILD_CONTEXT_KEY] || target[BUILD_CONTEXT_KEY];
                return this[propKey]
                  ? this[propKey]
                  : (this[propKey] = instanceFactory(propertyType, context));
              },
              set: function (newValue) {
                this[propKey] = newValue;
              },
            });
          }
          static injectValueProperty(target, key, name, valueFactory) {
            const propKey = `__${key}`;
            Object.defineProperty(target.prototype, key, {
              enumerable: true,
              get: function () {
                return this[propKey]
                  ? this[propKey]
                  : (this[propKey] = valueFactory(name));
              },
              set: function (newValue) {
                this[propKey] = newValue;
              },
            });
          }
          static hasNamedConstructor(source) {
            if (source["name"]) {
              return source["name"] !== "ioc_wrapper";
            } else {
              try {
                const constructorName = source.prototype.constructor
                  .toString()
                  .match(this.constructorNameRegEx)[1];
                return constructorName && constructorName !== IOC_WRAPPER_CLASS;
              } catch (_a) {
                // make linter happy
              }
              return false;
            }
          }
          static assertInstantiable() {
            if (InjectorHandler.instantiationsBlocked) {
              throw new TypeError(
                "Can not instantiate it. The instantiation is blocked for this class. " +
                  "Ask Container for it, using Container.get"
              );
            }
          }
        }
        exports.InjectorHandler = InjectorHandler;
        InjectorHandler.constructorNameRegEx = /function (\w*)/;
        InjectorHandler.instantiationsBlocked = true;
      },
      {},
    ],
    568: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        require("reflect-metadata");
        const container_1 = require("./container/container");
        const model_1 = require("./model");
        /**
         * A decorator to tell the container that this class should be handled by the Request [[Scope]].
         *
         * ```
         * @ RequestScope
         * class PersonDAO {
         *
         * }
         * ```
         *
         * Is the same that use:
         *
         * ```
         * Container.bind(PersonDAO).scope(Scope.Request)
         * ```
         */
        function InRequestScope(target) {
          container_1.IoCContainer.bind(target).scope(model_1.Scope.Request);
        }
        exports.InRequestScope = InRequestScope;
        /**
         * A decorator to tell the container that this class should be handled by the Singleton [[Scope]].
         *
         * ```
         * @ Singleton
         * class PersonDAO {
         *
         * }
         * ```
         *
         * Is the same that use:
         *
         * ```
         * Container.bind(PersonDAO).scope(Scope.Singleton)
         * ```
         */
        function Singleton(target) {
          container_1.IoCContainer.bind(target).scope(model_1.Scope.Singleton);
        }
        exports.Singleton = Singleton;
        /**
         * A decorator to tell the container that this class should has its instantiation always handled by the Container.
         *
         * The decorated class will have its constructor overriden to always delegate its instantiation to the IoC Container.
         * So, if you write:
         *
         * ```
         * @ OnlyInstantiableByContainer
         * class PersonService {
         *   @ Inject
         *   personDAO: PersonDAO;
         * }
         * ```
         *
         * You will only be able to create instances of PersonService through the Container.
         *
         * ```
         * let PersonService = new PersonService(); // will thrown a TypeError exception
         * ```
         */
        function OnlyInstantiableByContainer(target) {
          return container_1.IoCContainer.bind(target).instrumentConstructor()
            .decoratedConstructor;
        }
        exports.OnlyInstantiableByContainer = OnlyInstantiableByContainer;
        /**
         * A decorator to tell the container that this class should be handled by the provided [[Scope]].
         * For example:
         *
         * ```
         * class MyScope extends Scope {
         *   resolve(iocProvider:Provider, source:Function) {
         *     console.log('created by my custom scope.')
         *     return iocProvider.get();
         *   }
         * }
         * @ Scoped(new MyScope())
         * class PersonDAO {
         * }
         * ```
         *
         * Is the same that use:
         *
         * ```
         * Container.bind(PersonDAO).scope(new MyScope());
         * ```
         * @param scope The scope that will handle instantiations for this class.
         */
        function Scoped(scope) {
          return (target) => {
            container_1.IoCContainer.bind(target).scope(scope);
          };
        }
        exports.Scoped = Scoped;
        /**
         * A decorator to tell the container that this class should instantiated by the given [[ObjectFactory]].
         * For example:
         *
         * ```
         * @ Factory(() => new PersonDAO())
         * class PersonDAO {
         * }
         * ```
         *
         * Is the same that use:
         *
         * ```
         * Container.bind(PersonDAO).factory(() => new PersonDAO());
         * ```
         * @param factory The factory that will handle instantiations for this class.
         */
        function Factory(factory) {
          return (target) => {
            container_1.IoCContainer.bind(target).factory(factory);
          };
        }
        exports.Factory = Factory;
        /**
         * A decorator to request from Container that it resolve the annotated property dependency.
         * For example:
         *
         * ```
         * class PersonService {
         *    constructor (@ Inject creationTime: Date) {
         *       this.creationTime = creationTime;
         *    }
         *    @ Inject
         *    personDAO: PersonDAO;
         *
         *    creationTime: Date;
         * }
         *
         * ```
         *
         * When you call:
         *
         * ```
         * let personService: PersonService = Container.get(PersonService);
         * // The properties are all defined, retrieved from the IoC Container
         * console.log('PersonService.creationTime: ' + personService.creationTime);
         * console.log('PersonService.personDAO: ' + personService.personDAO);
         * ```
         */
        function Inject(...args) {
          if (
            args.length === 2 ||
            (args.length === 3 && typeof args[2] === "undefined")
          ) {
            return InjectPropertyDecorator.apply(this, args);
          } else if (args.length === 3 && typeof args[2] === "number") {
            return InjectParamDecorator.apply(this, args);
          }
          throw new TypeError("Invalid @Inject Decorator declaration.");
        }
        exports.Inject = Inject;
        /**
         * A decorator to request from Container that it resolve the annotated property dependency
         * with a constant value.
         * For example:
         *
         * ```
         * inteface Config {
         *   dependencyURL: string;
         *   port: number;
         * }
         * class PersonService {
         *    @ InjectValue('config')
         *    config: Config;
         * }
         * ```
         *
         * When you call:
         *
         * ```
         * let personService: PersonService = Container.get(PersonService);
         * // The properties are all defined, retrieved from the IoC Container
         * console.log('PersonService.config.port: ' + personService.config.port);
         * console.log('PersonService.config.dependencyURL: ' + personService.config.dependencyURL);
         * ```
         */
        function InjectValue(value) {
          return (...args) => {
            if (
              args.length === 2 ||
              (args.length === 3 && typeof args[2] === "undefined")
            ) {
              const params = [...args, value].filter((v) => (v ? true : false));
              return InjectValuePropertyDecorator.apply(this, params);
            } else if (args.length === 3 && typeof args[2] === "number") {
              return InjectValueParamDecorator.apply(this, [...args, value]);
            }
            throw new TypeError("Invalid @InjectValue Decorator declaration.");
          };
        }
        exports.InjectValue = InjectValue;
        /**
         * Decorator processor for [[Inject]] decorator on properties
         */
        function InjectPropertyDecorator(target, key) {
          let t = Reflect.getMetadata("design:type", target, key);
          if (!t) {
            // Needed to support react native inheritance
            t = Reflect.getMetadata("design:type", target.constructor, key);
          }
          container_1.IoCContainer.injectProperty(target.constructor, key, t);
        }
        /**
         * Decorator processor for [[Inject]] decorator on constructor parameters
         */
        function InjectParamDecorator(target, propertyKey, parameterIndex) {
          if (!propertyKey) {
            // only intercept constructor parameters
            const config = container_1.IoCContainer.bind(target);
            config.paramTypes = config.paramTypes || [];
            const paramTypes = Reflect.getMetadata("design:paramtypes", target);
            config.paramTypes.unshift(paramTypes[parameterIndex]);
          }
        }
        /**
         * Decorator processor for [[Inject]] decorator on properties
         */
        function InjectValuePropertyDecorator(target, key, value) {
          container_1.IoCContainer.injectValueProperty(
            target.constructor,
            key,
            value
          );
        }
        /**
         * Decorator processor for [[Inject]] decorator on constructor parameters
         */
        function InjectValueParamDecorator(
          target,
          propertyKey,
          _parameterIndex,
          value
        ) {
          if (!propertyKey) {
            // only intercept constructor parameters
            const config = container_1.IoCContainer.bind(target);
            config.paramTypes = config.paramTypes || [];
            config.paramTypes.unshift(value);
          }
        }
      },
      { "./container/container": 566, "./model": 569, "reflect-metadata": 100 },
    ],
    569: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        /**
         * Class responsible to handle the scope of the instances created by the Container
         */
        class Scope {
          /**
           * Called by the IoC Container when some configuration is changed on the Container binding.
           * @param _source The source type that has its configuration changed.
           */
          reset(_source) {
            // Do nothing
          }
          /**
           * Called by the IoC Container when the the target type is bound to this scope
           * @param _source The source type that is bound to that scope.
           */
          init(_source) {
            // Do nothing
          }
          /**
           * Called by the IoC Container when the the target type is unbound to this scope
           * @param _source The source type that is unbound to that scope.
           */
          finish(_source) {
            // Do nothing
          }
        }
        exports.Scope = Scope;
        /**
         * The context of the current Container resolution.
         */
        class BuildContext {}
        exports.BuildContext = BuildContext;
      },
      {},
    ],
    570: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const injection_handler_1 = require("./container/injection-handler");
        const model_1 = require("./model");
        /**
         * Default [[Scope]] that always create a new instace for any dependency resolution request
         */
        class LocalScope extends model_1.Scope {
          resolve(factory, _source, context) {
            return factory(context);
          }
        }
        exports.LocalScope = LocalScope;
        /**
         * Scope that create only a single instace to handle all dependency resolution requests.
         */
        class SingletonScope extends model_1.Scope {
          resolve(factory, source, context) {
            let instance = SingletonScope.instances.get(source);
            if (!instance) {
              instance = factory(context);
              SingletonScope.instances.set(source, instance);
            }
            return instance;
          }
          reset(source) {
            SingletonScope.instances.delete(
              injection_handler_1.InjectorHandler.getConstructorFromType(source)
            );
          }
          init(source) {
            this.reset(source);
          }
          finish(source) {
            this.reset(source);
          }
        }
        exports.SingletonScope = SingletonScope;
        SingletonScope.instances = new Map();
        class RequestScope extends model_1.Scope {
          resolve(factory, source, context) {
            this.ensureContext(context);
            return context.build(source, factory);
          }
          ensureContext(context) {
            if (!context) {
              throw new TypeError(
                "IoC Container can not handle this request. When using @InRequestScope " +
                  "in any dependent type, you should be askking to Container to create the instances through Container.get" +
                  " and not calling the type constructor directly."
              );
            }
          }
        }
        exports.RequestScope = RequestScope;
      },
      { "./container/injection-handler": 567, "./model": 569 },
    ],
    571: [
      function (require, module, exports) {
        "use strict";
        /**
         * This is a lightweight annotation-based dependency injection container for typescript.
         *
         * Visit the project page on [GitHub] (https://github.com/thiagobustamante/typescript-ioc).
         */
        Object.defineProperty(exports, "__esModule", { value: true });
        require("reflect-metadata");
        const model_1 = require("./model");
        exports.Scope = model_1.Scope;
        exports.BuildContext = model_1.BuildContext;
        const container_1 = require("./container/container");
        const scopes_1 = require("./scopes");
        var decorators_1 = require("./decorators");
        exports.Inject = decorators_1.Inject;
        exports.Factory = decorators_1.Factory;
        exports.Singleton = decorators_1.Singleton;
        exports.Scoped = decorators_1.Scoped;
        exports.OnlyInstantiableByContainer =
          decorators_1.OnlyInstantiableByContainer;
        exports.InRequestScope = decorators_1.InRequestScope;
        exports.InjectValue = decorators_1.InjectValue;
        model_1.Scope.Local = new scopes_1.LocalScope();
        model_1.Scope.Singleton = new scopes_1.SingletonScope();
        model_1.Scope.Request = new scopes_1.RequestScope();
        /**
         * The IoC Container class. Can be used to register and to retrieve your dependencies.
         * You can also use de decorators [[OnlyInstantiableByContainer]], [[Scoped]], [[Singleton]], [[Factory]]
         * to configure the dependency directly on the class.
         */
        class Container {
          /**
           * Add a dependency to the Container. If this type is already present, just return its associated
           * configuration object.
           * Example of usage:
           *
           * ```
           * Container.bind(PersonDAO).to(ProgrammerDAO).scope(Scope.Singleton);
           * ```
           * @param source The type that will be bound to the Container
           * @return a container configuration
           */
          static bind(source) {
            return container_1.IoCContainer.bind(source);
          }
          /**
           * Retrieve an object from the container. It will resolve all dependencies and apply any type replacement
           * before return the object.
           * If there is no declared dependency to the given source type, an implicity bind is performed to this type.
           * @param source The dependency type to resolve
           * @return an object resolved for the given source type;
           */
          static get(source) {
            return container_1.IoCContainer.get(
              source,
              new ContainerBuildContext()
            );
          }
          /**
           * Retrieve a type associated with the type provided from the container
           * @param source The dependency type to resolve
           * @return an object resolved for the given source type;
           */
          static getType(source) {
            return container_1.IoCContainer.getType(source);
          }
          /**
           *
           * @param name
           */
          static bindName(name) {
            return container_1.IoCContainer.bindName(name);
          }
          /**
           * Retrieve a constant from the container.
           * @param name The name of the constant used to identify these binding
           * @return the constant value
           */
          static getValue(name) {
            return container_1.IoCContainer.getValue(name);
          }
          /**
           * Select the current namespace to work.
           * @param name The namespace name, or null to select the default namespace
           */
          static namespace(name) {
            return container_1.IoCContainer.namespace(name);
          }
          /**
           * An alias to namespace method.
           * @param name The namespace name, or null to select the default namespace
           */
          static environment(name) {
            return Container.namespace(name);
          }
          /**
           * Store the state for a specified binding.  Can then be restored later.   Useful for testing.
           * @param source The dependency type
           */
          // _args is here to ensure backward compatibility
          static snapshot(_args) {
            return container_1.IoCContainer.snapshot();
          }
          /**
           * Import an array of configurations to the Container
           * @param configurations
           */
          static configure(...configurations) {
            configurations.forEach((config) => {
              if (config.bind) {
                Container.configureType(config);
              } else if (config.bindName) {
                Container.configureConstant(config);
              } else if (config.env || config.namespace) {
                Container.configureNamespace(config);
              }
            });
          }
          static configureNamespace(config) {
            const selectedNamespace = container_1.IoCContainer.selectedNamespace();
            const env = config.env || config.namespace;
            Object.keys(env).forEach((namespace) => {
              Container.namespace(namespace);
              const namespaceConfig = env[namespace];
              Container.configure(...namespaceConfig);
            });
            Container.namespace(selectedNamespace);
          }
          static configureConstant(config) {
            const bind = container_1.IoCContainer.bindName(config.bindName);
            if (bind) {
              if (config.to) {
                bind.to(config.to);
              }
            }
          }
          static configureType(config) {
            const bind = container_1.IoCContainer.bind(config.bind);
            if (bind) {
              if (config.to) {
                bind.to(config.to);
              } else if (config.factory) {
                bind.factory(config.factory);
              }
              if (config.scope) {
                bind.scope(config.scope);
              }
              if (config.withParams) {
                bind.withParams(config.withParams);
              }
            }
          }
        }
        exports.Container = Container;
        class ContainerBuildContext extends model_1.BuildContext {
          constructor() {
            super(...arguments);
            this.context = new Map();
          }
          build(source, factory) {
            let instance = this.context.get(source);
            if (!instance) {
              instance = factory(this);
              this.context.set(source, instance);
            }
            return instance;
          }
          resolve(source) {
            return container_1.IoCContainer.get(source, this);
          }
        }
      },
      {
        "./container/container": 566,
        "./decorators": 568,
        "./model": 569,
        "./scopes": 570,
        "reflect-metadata": 100,
      },
    ],
    572: [
      function (require, module, exports) {
        var trim = require("./trim");
        var decap = require("./decapitalize");

        module.exports = function camelize(str, decapitalize) {
          str = trim(str).replace(/[-_\s]+(.)?/g, function (match, c) {
            return c ? c.toUpperCase() : "";
          });

          if (decapitalize === true) {
            return decap(str);
          } else {
            return str;
          }
        };
      },
      { "./decapitalize": 581, "./trim": 634 },
    ],
    573: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function capitalize(str, lowercaseRest) {
          str = makeString(str);
          var remainingChars = !lowercaseRest
            ? str.slice(1)
            : str.slice(1).toLowerCase();

          return str.charAt(0).toUpperCase() + remainingChars;
        };
      },
      { "./helper/makeString": 591 },
    ],
    574: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function chars(str) {
          return makeString(str).split("");
        };
      },
      { "./helper/makeString": 591 },
    ],
    575: [
      function (require, module, exports) {
        module.exports = function chop(str, step) {
          if (str == null) return [];
          str = String(str);
          step = ~~step;
          return step > 0
            ? str.match(new RegExp(".{1," + step + "}", "g"))
            : [str];
        };
      },
      {},
    ],
    576: [
      function (require, module, exports) {
        var capitalize = require("./capitalize");
        var camelize = require("./camelize");
        var makeString = require("./helper/makeString");

        module.exports = function classify(str) {
          str = makeString(str);
          return capitalize(
            camelize(str.replace(/[\W_]/g, " ")).replace(/\s/g, "")
          );
        };
      },
      { "./camelize": 572, "./capitalize": 573, "./helper/makeString": 591 },
    ],
    577: [
      function (require, module, exports) {
        var trim = require("./trim");

        module.exports = function clean(str) {
          return trim(str).replace(/\s\s+/g, " ");
        };
      },
      { "./trim": 634 },
    ],
    578: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        var from = "",
          to = "aaaaaaaaaccceeeeeghiiiijllnnoooooooossssstttuuuuuunyyczzz";

        from += from.toUpperCase();
        to += to.toUpperCase();

        to = to.split("");

        // for tokens requireing multitoken output
        from += "";
        to.push("ss");

        module.exports = function cleanDiacritics(str) {
          return makeString(str).replace(/.{1}/g, function (c) {
            var index = from.indexOf(c);
            return index === -1 ? c : to[index];
          });
        };
      },
      { "./helper/makeString": 591 },
    ],
    579: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function (str, substr) {
          str = makeString(str);
          substr = makeString(substr);

          if (str.length === 0 || substr.length === 0) return 0;

          return str.split(substr).length - 1;
        };
      },
      { "./helper/makeString": 591 },
    ],
    580: [
      function (require, module, exports) {
        var trim = require("./trim");

        module.exports = function dasherize(str) {
          return trim(str)
            .replace(/([A-Z])/g, "-$1")
            .replace(/[-_\s]+/g, "-")
            .toLowerCase();
        };
      },
      { "./trim": 634 },
    ],
    581: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function decapitalize(str) {
          str = makeString(str);
          return str.charAt(0).toLowerCase() + str.slice(1);
        };
      },
      { "./helper/makeString": 591 },
    ],
    582: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        function getIndent(str) {
          var matches = str.match(/^[\s\\t]*/gm);
          var indent = matches[0].length;

          for (var i = 1; i < matches.length; i++) {
            indent = Math.min(matches[i].length, indent);
          }

          return indent;
        }

        module.exports = function dedent(str, pattern) {
          str = makeString(str);
          var indent = getIndent(str);
          var reg;

          if (indent === 0) return str;

          if (typeof pattern === "string") {
            reg = new RegExp("^" + pattern, "gm");
          } else {
            reg = new RegExp("^[ \\t]{" + indent + "}", "gm");
          }

          return str.replace(reg, "");
        };
      },
      { "./helper/makeString": 591 },
    ],
    583: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var toPositive = require("./helper/toPositive");

        module.exports = function endsWith(str, ends, position) {
          str = makeString(str);
          ends = "" + ends;
          if (typeof position == "undefined") {
            position = str.length - ends.length;
          } else {
            position = Math.min(toPositive(position), str.length) - ends.length;
          }
          return position >= 0 && str.indexOf(ends, position) === position;
        };
      },
      { "./helper/makeString": 591, "./helper/toPositive": 593 },
    ],
    584: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var escapeChars = require("./helper/escapeChars");

        var regexString = "[";
        for (var key in escapeChars) {
          regexString += key;
        }
        regexString += "]";

        var regex = new RegExp(regexString, "g");

        module.exports = function escapeHTML(str) {
          return makeString(str).replace(regex, function (m) {
            return "&" + escapeChars[m] + ";";
          });
        };
      },
      { "./helper/escapeChars": 588, "./helper/makeString": 591 },
    ],
    585: [
      function (require, module, exports) {
        module.exports = function () {
          var result = {};

          for (var prop in this) {
            if (
              !this.hasOwnProperty(prop) ||
              prop.match(/^(?:include|contains|reverse|join|map|wrap)$/)
            )
              continue;
            result[prop] = this[prop];
          }

          return result;
        };
      },
      {},
    ],
    586: [
      function (require, module, exports) {
        var makeString = require("./makeString");

        module.exports = function adjacent(str, direction) {
          str = makeString(str);
          if (str.length === 0) {
            return "";
          }
          return (
            str.slice(0, -1) +
            String.fromCharCode(str.charCodeAt(str.length - 1) + direction)
          );
        };
      },
      { "./makeString": 591 },
    ],
    587: [
      function (require, module, exports) {
        var escapeRegExp = require("./escapeRegExp");

        module.exports = function defaultToWhiteSpace(characters) {
          if (characters == null) return "\\s";
          else if (characters.source) return characters.source;
          else return "[" + escapeRegExp(characters) + "]";
        };
      },
      { "./escapeRegExp": 589 },
    ],
    588: [
      function (require, module, exports) {
        /* We're explicitly defining the list of entities we want to escape.
nbsp is an HTML entity, but we don't want to escape all space characters in a string, hence its omission in this map.

*/
        var escapeChars = {
          "": "cent",
          "": "pound",
          "": "yen",
          "": "euro",
          "": "copy",
          "": "reg",
          "<": "lt",
          ">": "gt",
          '"': "quot",
          "&": "amp",
          "'": "#39",
        };

        module.exports = escapeChars;
      },
      {},
    ],
    589: [
      function (require, module, exports) {
        var makeString = require("./makeString");

        module.exports = function escapeRegExp(str) {
          return makeString(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
        };
      },
      { "./makeString": 591 },
    ],
    590: [
      function (require, module, exports) {
        /*
We're explicitly defining the list of entities that might see in escape HTML strings
*/
        var htmlEntities = {
          nbsp: " ",
          cent: "",
          pound: "",
          yen: "",
          euro: "",
          copy: "",
          reg: "",
          lt: "<",
          gt: ">",
          quot: '"',
          amp: "&",
          apos: "'",
        };

        module.exports = htmlEntities;
      },
      {},
    ],
    591: [
      function (require, module, exports) {
        /**
         * Ensure some object is a coerced to a string
         **/
        module.exports = function makeString(object) {
          if (object == null) return "";
          return "" + object;
        };
      },
      {},
    ],
    592: [
      function (require, module, exports) {
        module.exports = function strRepeat(str, qty) {
          if (qty < 1) return "";
          var result = "";
          while (qty > 0) {
            if (qty & 1) result += str;
            (qty >>= 1), (str += str);
          }
          return result;
        };
      },
      {},
    ],
    593: [
      function (require, module, exports) {
        module.exports = function toPositive(number) {
          return number < 0 ? 0 : +number || 0;
        };
      },
      {},
    ],
    594: [
      function (require, module, exports) {
        var capitalize = require("./capitalize");
        var underscored = require("./underscored");
        var trim = require("./trim");

        module.exports = function humanize(str) {
          return capitalize(
            trim(underscored(str).replace(/_id$/, "").replace(/_/g, " "))
          );
        };
      },
      { "./capitalize": 573, "./trim": 634, "./underscored": 636 },
    ],
    595: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function include(str, needle) {
          if (needle === "") return true;
          return makeString(str).indexOf(needle) !== -1;
        };
      },
      { "./helper/makeString": 591 },
    ],
    596: [
      function (require, module, exports) {
        /*
         * Underscore.string
         * (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
         * Underscore.string is freely distributable under the terms of the MIT license.
         * Documentation: https://github.com/epeli/underscore.string
         * Some code is borrowed from MooTools and Alexandru Marasteanu.
         * Version '3.3.4'
         * @preserve
         */

        "use strict";

        function s(value) {
          /* jshint validthis: true */
          if (!(this instanceof s)) return new s(value);
          this._wrapped = value;
        }

        s.VERSION = "3.3.4";

        s.isBlank = require("./isBlank");
        s.stripTags = require("./stripTags");
        s.capitalize = require("./capitalize");
        s.decapitalize = require("./decapitalize");
        s.chop = require("./chop");
        s.trim = require("./trim");
        s.clean = require("./clean");
        s.cleanDiacritics = require("./cleanDiacritics");
        s.count = require("./count");
        s.chars = require("./chars");
        s.swapCase = require("./swapCase");
        s.escapeHTML = require("./escapeHTML");
        s.unescapeHTML = require("./unescapeHTML");
        s.splice = require("./splice");
        s.insert = require("./insert");
        s.replaceAll = require("./replaceAll");
        s.include = require("./include");
        s.join = require("./join");
        s.lines = require("./lines");
        s.dedent = require("./dedent");
        s.reverse = require("./reverse");
        s.startsWith = require("./startsWith");
        s.endsWith = require("./endsWith");
        s.pred = require("./pred");
        s.succ = require("./succ");
        s.titleize = require("./titleize");
        s.camelize = require("./camelize");
        s.underscored = require("./underscored");
        s.dasherize = require("./dasherize");
        s.classify = require("./classify");
        s.humanize = require("./humanize");
        s.ltrim = require("./ltrim");
        s.rtrim = require("./rtrim");
        s.truncate = require("./truncate");
        s.prune = require("./prune");
        s.words = require("./words");
        s.pad = require("./pad");
        s.lpad = require("./lpad");
        s.rpad = require("./rpad");
        s.lrpad = require("./lrpad");
        s.sprintf = require("./sprintf");
        s.vsprintf = require("./vsprintf");
        s.toNumber = require("./toNumber");
        s.numberFormat = require("./numberFormat");
        s.strRight = require("./strRight");
        s.strRightBack = require("./strRightBack");
        s.strLeft = require("./strLeft");
        s.strLeftBack = require("./strLeftBack");
        s.toSentence = require("./toSentence");
        s.toSentenceSerial = require("./toSentenceSerial");
        s.slugify = require("./slugify");
        s.surround = require("./surround");
        s.quote = require("./quote");
        s.unquote = require("./unquote");
        s.repeat = require("./repeat");
        s.naturalCmp = require("./naturalCmp");
        s.levenshtein = require("./levenshtein");
        s.toBoolean = require("./toBoolean");
        s.exports = require("./exports");
        s.escapeRegExp = require("./helper/escapeRegExp");
        s.wrap = require("./wrap");
        s.map = require("./map");

        // Aliases
        s.strip = s.trim;
        s.lstrip = s.ltrim;
        s.rstrip = s.rtrim;
        s.center = s.lrpad;
        s.rjust = s.lpad;
        s.ljust = s.rpad;
        s.contains = s.include;
        s.q = s.quote;
        s.toBool = s.toBoolean;
        s.camelcase = s.camelize;
        s.mapChars = s.map;

        // Implement chaining
        s.prototype = {
          value: function value() {
            return this._wrapped;
          },
        };

        function fn2method(key, fn) {
          if (typeof fn !== "function") return;
          s.prototype[key] = function () {
            var args = [this._wrapped].concat(
              Array.prototype.slice.call(arguments)
            );
            var res = fn.apply(null, args);
            // if the result is non-string stop the chain and return the value
            return typeof res === "string" ? new s(res) : res;
          };
        }

        // Copy functions to instance methods for chaining
        for (var key in s) fn2method(key, s[key]);

        fn2method("tap", function tap(string, fn) {
          return fn(string);
        });

        function prototype2method(methodName) {
          fn2method(methodName, function (context) {
            var args = Array.prototype.slice.call(arguments, 1);
            return String.prototype[methodName].apply(context, args);
          });
        }

        var prototypeMethods = [
          "toUpperCase",
          "toLowerCase",
          "split",
          "replace",
          "slice",
          "substring",
          "substr",
          "concat",
        ];

        for (var method in prototypeMethods)
          prototype2method(prototypeMethods[method]);

        module.exports = s;
      },
      {
        "./camelize": 572,
        "./capitalize": 573,
        "./chars": 574,
        "./chop": 575,
        "./classify": 576,
        "./clean": 577,
        "./cleanDiacritics": 578,
        "./count": 579,
        "./dasherize": 580,
        "./decapitalize": 581,
        "./dedent": 582,
        "./endsWith": 583,
        "./escapeHTML": 584,
        "./exports": 585,
        "./helper/escapeRegExp": 589,
        "./humanize": 594,
        "./include": 595,
        "./insert": 597,
        "./isBlank": 598,
        "./join": 599,
        "./levenshtein": 600,
        "./lines": 601,
        "./lpad": 602,
        "./lrpad": 603,
        "./ltrim": 604,
        "./map": 605,
        "./naturalCmp": 606,
        "./numberFormat": 607,
        "./pad": 608,
        "./pred": 609,
        "./prune": 610,
        "./quote": 611,
        "./repeat": 612,
        "./replaceAll": 613,
        "./reverse": 614,
        "./rpad": 615,
        "./rtrim": 616,
        "./slugify": 617,
        "./splice": 618,
        "./sprintf": 619,
        "./startsWith": 620,
        "./strLeft": 621,
        "./strLeftBack": 622,
        "./strRight": 623,
        "./strRightBack": 624,
        "./stripTags": 625,
        "./succ": 626,
        "./surround": 627,
        "./swapCase": 628,
        "./titleize": 629,
        "./toBoolean": 630,
        "./toNumber": 631,
        "./toSentence": 632,
        "./toSentenceSerial": 633,
        "./trim": 634,
        "./truncate": 635,
        "./underscored": 636,
        "./unescapeHTML": 637,
        "./unquote": 638,
        "./vsprintf": 639,
        "./words": 640,
        "./wrap": 641,
      },
    ],
    597: [
      function (require, module, exports) {
        var splice = require("./splice");

        module.exports = function insert(str, i, substr) {
          return splice(str, i, 0, substr);
        };
      },
      { "./splice": 618 },
    ],
    598: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function isBlank(str) {
          return /^\s*$/.test(makeString(str));
        };
      },
      { "./helper/makeString": 591 },
    ],
    599: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var slice = [].slice;

        module.exports = function join() {
          var args = slice.call(arguments),
            separator = args.shift();

          return args.join(makeString(separator));
        };
      },
      { "./helper/makeString": 591 },
    ],
    600: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        /**
         * Based on the implementation here: https://github.com/hiddentao/fast-levenshtein
         */
        module.exports = function levenshtein(str1, str2) {
          "use strict";
          str1 = makeString(str1);
          str2 = makeString(str2);

          // Short cut cases
          if (str1 === str2) return 0;
          if (!str1 || !str2) return Math.max(str1.length, str2.length);

          // two rows
          var prevRow = new Array(str2.length + 1);

          // initialise previous row
          for (var i = 0; i < prevRow.length; ++i) {
            prevRow[i] = i;
          }

          // calculate current row distance from previous row
          for (i = 0; i < str1.length; ++i) {
            var nextCol = i + 1;

            for (var j = 0; j < str2.length; ++j) {
              var curCol = nextCol;

              // substution
              nextCol =
                prevRow[j] + (str1.charAt(i) === str2.charAt(j) ? 0 : 1);
              // insertion
              var tmp = curCol + 1;
              if (nextCol > tmp) {
                nextCol = tmp;
              }
              // deletion
              tmp = prevRow[j + 1] + 1;
              if (nextCol > tmp) {
                nextCol = tmp;
              }

              // copy current col value into previous (in preparation for next iteration)
              prevRow[j] = curCol;
            }

            // copy last col value into previous (in preparation for next iteration)
            prevRow[j] = nextCol;
          }

          return nextCol;
        };
      },
      { "./helper/makeString": 591 },
    ],
    601: [
      function (require, module, exports) {
        module.exports = function lines(str) {
          if (str == null) return [];
          return String(str).split(/\r\n?|\n/);
        };
      },
      {},
    ],
    602: [
      function (require, module, exports) {
        var pad = require("./pad");

        module.exports = function lpad(str, length, padStr) {
          return pad(str, length, padStr);
        };
      },
      { "./pad": 608 },
    ],
    603: [
      function (require, module, exports) {
        var pad = require("./pad");

        module.exports = function lrpad(str, length, padStr) {
          return pad(str, length, padStr, "both");
        };
      },
      { "./pad": 608 },
    ],
    604: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var defaultToWhiteSpace = require("./helper/defaultToWhiteSpace");
        var nativeTrimLeft = String.prototype.trimLeft;

        module.exports = function ltrim(str, characters) {
          str = makeString(str);
          if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
          characters = defaultToWhiteSpace(characters);
          return str.replace(new RegExp("^" + characters + "+"), "");
        };
      },
      { "./helper/defaultToWhiteSpace": 587, "./helper/makeString": 591 },
    ],
    605: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function (str, callback) {
          str = makeString(str);

          if (str.length === 0 || typeof callback !== "function") return str;

          return str.replace(/./g, callback);
        };
      },
      { "./helper/makeString": 591 },
    ],
    606: [
      function (require, module, exports) {
        module.exports = function naturalCmp(str1, str2) {
          if (str1 == str2) return 0;
          if (!str1) return -1;
          if (!str2) return 1;

          var cmpRegex = /(\.\d+|\d+|\D+)/g,
            tokens1 = String(str1).match(cmpRegex),
            tokens2 = String(str2).match(cmpRegex),
            count = Math.min(tokens1.length, tokens2.length);

          for (var i = 0; i < count; i++) {
            var a = tokens1[i],
              b = tokens2[i];

            if (a !== b) {
              var num1 = +a;
              var num2 = +b;
              if (num1 === num1 && num2 === num2) {
                return num1 > num2 ? 1 : -1;
              }
              return a < b ? -1 : 1;
            }
          }

          if (tokens1.length != tokens2.length)
            return tokens1.length - tokens2.length;

          return str1 < str2 ? -1 : 1;
        };
      },
      {},
    ],
    607: [
      function (require, module, exports) {
        module.exports = function numberFormat(number, dec, dsep, tsep) {
          if (isNaN(number) || number == null) return "";

          number = number.toFixed(~~dec);
          tsep = typeof tsep == "string" ? tsep : ",";

          var parts = number.split("."),
            fnums = parts[0],
            decimals = parts[1] ? (dsep || ".") + parts[1] : "";

          return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, "$1" + tsep) + decimals;
        };
      },
      {},
    ],
    608: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var strRepeat = require("./helper/strRepeat");

        module.exports = function pad(str, length, padStr, type) {
          str = makeString(str);
          length = ~~length;

          var padlen = 0;

          if (!padStr) padStr = " ";
          else if (padStr.length > 1) padStr = padStr.charAt(0);

          switch (type) {
            case "right":
              padlen = length - str.length;
              return str + strRepeat(padStr, padlen);
            case "both":
              padlen = length - str.length;
              return (
                strRepeat(padStr, Math.ceil(padlen / 2)) +
                str +
                strRepeat(padStr, Math.floor(padlen / 2))
              );
            default:
              // 'left'
              padlen = length - str.length;
              return strRepeat(padStr, padlen) + str;
          }
        };
      },
      { "./helper/makeString": 591, "./helper/strRepeat": 592 },
    ],
    609: [
      function (require, module, exports) {
        var adjacent = require("./helper/adjacent");

        module.exports = function succ(str) {
          return adjacent(str, -1);
        };
      },
      { "./helper/adjacent": 586 },
    ],
    610: [
      function (require, module, exports) {
        /**
         * _s.prune: a more elegant version of truncate
         * prune extra chars, never leaving a half-chopped word.
         * @author github.com/rwz
         */
        var makeString = require("./helper/makeString");
        var rtrim = require("./rtrim");

        module.exports = function prune(str, length, pruneStr) {
          str = makeString(str);
          length = ~~length;
          pruneStr = pruneStr != null ? String(pruneStr) : "...";

          if (str.length <= length) return str;

          var tmpl = function (c) {
              return c.toUpperCase() !== c.toLowerCase() ? "A" : " ";
            },
            template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

          if (template.slice(template.length - 2).match(/\w\w/))
            template = template.replace(/\s*\S+$/, "");
          else template = rtrim(template.slice(0, template.length - 1));

          return (template + pruneStr).length > str.length
            ? str
            : str.slice(0, template.length) + pruneStr;
        };
      },
      { "./helper/makeString": 591, "./rtrim": 616 },
    ],
    611: [
      function (require, module, exports) {
        var surround = require("./surround");

        module.exports = function quote(str, quoteChar) {
          return surround(str, quoteChar || '"');
        };
      },
      { "./surround": 627 },
    ],
    612: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var strRepeat = require("./helper/strRepeat");

        module.exports = function repeat(str, qty, separator) {
          str = makeString(str);

          qty = ~~qty;

          // using faster implementation if separator is not needed;
          if (separator == null) return strRepeat(str, qty);

          // this one is about 300x slower in Google Chrome
          /*eslint no-empty: 0*/
          for (var repeat = []; qty > 0; repeat[--qty] = str) {}
          return repeat.join(separator);
        };
      },
      { "./helper/makeString": 591, "./helper/strRepeat": 592 },
    ],
    613: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function replaceAll(str, find, replace, ignorecase) {
          var flags = ignorecase === true ? "gi" : "g";
          var reg = new RegExp(find, flags);

          return makeString(str).replace(reg, replace);
        };
      },
      { "./helper/makeString": 591 },
    ],
    614: [
      function (require, module, exports) {
        var chars = require("./chars");

        module.exports = function reverse(str) {
          return chars(str).reverse().join("");
        };
      },
      { "./chars": 574 },
    ],
    615: [
      function (require, module, exports) {
        var pad = require("./pad");

        module.exports = function rpad(str, length, padStr) {
          return pad(str, length, padStr, "right");
        };
      },
      { "./pad": 608 },
    ],
    616: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var defaultToWhiteSpace = require("./helper/defaultToWhiteSpace");
        var nativeTrimRight = String.prototype.trimRight;

        module.exports = function rtrim(str, characters) {
          str = makeString(str);
          if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
          characters = defaultToWhiteSpace(characters);
          return str.replace(new RegExp(characters + "+$"), "");
        };
      },
      { "./helper/defaultToWhiteSpace": 587, "./helper/makeString": 591 },
    ],
    617: [
      function (require, module, exports) {
        var trim = require("./trim");
        var dasherize = require("./dasherize");
        var cleanDiacritics = require("./cleanDiacritics");

        module.exports = function slugify(str) {
          return trim(
            dasherize(
              cleanDiacritics(str)
                .replace(/[^\w\s-]/g, "-")
                .toLowerCase()
            ),
            "-"
          );
        };
      },
      { "./cleanDiacritics": 578, "./dasherize": 580, "./trim": 634 },
    ],
    618: [
      function (require, module, exports) {
        var chars = require("./chars");

        module.exports = function splice(str, i, howmany, substr) {
          var arr = chars(str);
          arr.splice(~~i, ~~howmany, substr);
          return arr.join("");
        };
      },
      { "./chars": 574 },
    ],
    619: [
      function (require, module, exports) {
        var deprecate = require("util-deprecate");

        module.exports = deprecate(
          require("sprintf-js").sprintf,
          "sprintf() will be removed in the next major release, use the sprintf-js package instead."
        );
      },
      { "sprintf-js": 554, "util-deprecate": 644 },
    ],
    620: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var toPositive = require("./helper/toPositive");

        module.exports = function startsWith(str, starts, position) {
          str = makeString(str);
          starts = "" + starts;
          position =
            position == null ? 0 : Math.min(toPositive(position), str.length);
          return str.lastIndexOf(starts, position) === position;
        };
      },
      { "./helper/makeString": 591, "./helper/toPositive": 593 },
    ],
    621: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function strLeft(str, sep) {
          str = makeString(str);
          sep = makeString(sep);
          var pos = !sep ? -1 : str.indexOf(sep);
          return ~pos ? str.slice(0, pos) : str;
        };
      },
      { "./helper/makeString": 591 },
    ],
    622: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function strLeftBack(str, sep) {
          str = makeString(str);
          sep = makeString(sep);
          var pos = str.lastIndexOf(sep);
          return ~pos ? str.slice(0, pos) : str;
        };
      },
      { "./helper/makeString": 591 },
    ],
    623: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function strRight(str, sep) {
          str = makeString(str);
          sep = makeString(sep);
          var pos = !sep ? -1 : str.indexOf(sep);
          return ~pos ? str.slice(pos + sep.length, str.length) : str;
        };
      },
      { "./helper/makeString": 591 },
    ],
    624: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function strRightBack(str, sep) {
          str = makeString(str);
          sep = makeString(sep);
          var pos = !sep ? -1 : str.lastIndexOf(sep);
          return ~pos ? str.slice(pos + sep.length, str.length) : str;
        };
      },
      { "./helper/makeString": 591 },
    ],
    625: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function stripTags(str) {
          return makeString(str).replace(/<\/?[^>]+>/g, "");
        };
      },
      { "./helper/makeString": 591 },
    ],
    626: [
      function (require, module, exports) {
        var adjacent = require("./helper/adjacent");

        module.exports = function succ(str) {
          return adjacent(str, 1);
        };
      },
      { "./helper/adjacent": 586 },
    ],
    627: [
      function (require, module, exports) {
        module.exports = function surround(str, wrapper) {
          return [wrapper, str, wrapper].join("");
        };
      },
      {},
    ],
    628: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function swapCase(str) {
          return makeString(str).replace(/\S/g, function (c) {
            return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
          });
        };
      },
      { "./helper/makeString": 591 },
    ],
    629: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function titleize(str) {
          return makeString(str)
            .toLowerCase()
            .replace(/(?:^|\s|-)\S/g, function (c) {
              return c.toUpperCase();
            });
        };
      },
      { "./helper/makeString": 591 },
    ],
    630: [
      function (require, module, exports) {
        var trim = require("./trim");

        function boolMatch(s, matchers) {
          var i,
            matcher,
            down = s.toLowerCase();
          matchers = [].concat(matchers);
          for (i = 0; i < matchers.length; i += 1) {
            matcher = matchers[i];
            if (!matcher) continue;
            if (matcher.test && matcher.test(s)) return true;
            if (matcher.toLowerCase() === down) return true;
          }
        }

        module.exports = function toBoolean(str, trueValues, falseValues) {
          if (typeof str === "number") str = "" + str;
          if (typeof str !== "string") return !!str;
          str = trim(str);
          if (boolMatch(str, trueValues || ["true", "1"])) return true;
          if (boolMatch(str, falseValues || ["false", "0"])) return false;
        };
      },
      { "./trim": 634 },
    ],
    631: [
      function (require, module, exports) {
        module.exports = function toNumber(num, precision) {
          if (num == null) return 0;
          var factor = Math.pow(10, isFinite(precision) ? precision : 0);
          return Math.round(num * factor) / factor;
        };
      },
      {},
    ],
    632: [
      function (require, module, exports) {
        var rtrim = require("./rtrim");

        module.exports = function toSentence(
          array,
          separator,
          lastSeparator,
          serial
        ) {
          separator = separator || ", ";
          lastSeparator = lastSeparator || " and ";
          var a = array.slice(),
            lastMember = a.pop();

          if (array.length > 2 && serial)
            lastSeparator = rtrim(separator) + lastSeparator;

          return a.length
            ? a.join(separator) + lastSeparator + lastMember
            : lastMember;
        };
      },
      { "./rtrim": 616 },
    ],
    633: [
      function (require, module, exports) {
        var toSentence = require("./toSentence");

        module.exports = function toSentenceSerial(array, sep, lastSep) {
          return toSentence(array, sep, lastSep, true);
        };
      },
      { "./toSentence": 632 },
    ],
    634: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var defaultToWhiteSpace = require("./helper/defaultToWhiteSpace");
        var nativeTrim = String.prototype.trim;

        module.exports = function trim(str, characters) {
          str = makeString(str);
          if (!characters && nativeTrim) return nativeTrim.call(str);
          characters = defaultToWhiteSpace(characters);
          return str.replace(
            new RegExp("^" + characters + "+|" + characters + "+$", "g"),
            ""
          );
        };
      },
      { "./helper/defaultToWhiteSpace": 587, "./helper/makeString": 591 },
    ],
    635: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");

        module.exports = function truncate(str, length, truncateStr) {
          str = makeString(str);
          truncateStr = truncateStr || "...";
          length = ~~length;
          return str.length > length ? str.slice(0, length) + truncateStr : str;
        };
      },
      { "./helper/makeString": 591 },
    ],
    636: [
      function (require, module, exports) {
        var trim = require("./trim");

        module.exports = function underscored(str) {
          return trim(str)
            .replace(/([a-z\d])([A-Z]+)/g, "$1_$2")
            .replace(/[-\s]+/g, "_")
            .toLowerCase();
        };
      },
      { "./trim": 634 },
    ],
    637: [
      function (require, module, exports) {
        var makeString = require("./helper/makeString");
        var htmlEntities = require("./helper/htmlEntities");

        module.exports = function unescapeHTML(str) {
          return makeString(str).replace(/\&([^;]{1,10});/g, function (
            entity,
            entityCode
          ) {
            var match;

            if (entityCode in htmlEntities) {
              return htmlEntities[entityCode];
              /*eslint no-cond-assign: 0*/
            } else if ((match = entityCode.match(/^#x([\da-fA-F]+)$/))) {
              return String.fromCharCode(parseInt(match[1], 16));
              /*eslint no-cond-assign: 0*/
            } else if ((match = entityCode.match(/^#(\d+)$/))) {
              return String.fromCharCode(~~match[1]);
            } else {
              return entity;
            }
          });
        };
      },
      { "./helper/htmlEntities": 590, "./helper/makeString": 591 },
    ],
    638: [
      function (require, module, exports) {
        module.exports = function unquote(str, quoteChar) {
          quoteChar = quoteChar || '"';
          if (str[0] === quoteChar && str[str.length - 1] === quoteChar)
            return str.slice(1, str.length - 1);
          else return str;
        };
      },
      {},
    ],
    639: [
      function (require, module, exports) {
        var deprecate = require("util-deprecate");

        module.exports = deprecate(
          require("sprintf-js").vsprintf,
          "vsprintf() will be removed in the next major release, use the sprintf-js package instead."
        );
      },
      { "sprintf-js": 554, "util-deprecate": 644 },
    ],
    640: [
      function (require, module, exports) {
        var isBlank = require("./isBlank");
        var trim = require("./trim");

        module.exports = function words(str, delimiter) {
          if (isBlank(str)) return [];
          return trim(str, delimiter).split(delimiter || /\s+/);
        };
      },
      { "./isBlank": 598, "./trim": 634 },
    ],
    641: [
      function (require, module, exports) {
        // Wrap
        // wraps a string by a certain width

        var makeString = require("./helper/makeString");

        module.exports = function wrap(str, options) {
          str = makeString(str);

          options = options || {};

          var width = options.width || 75;
          var seperator = options.seperator || "\n";
          var cut = options.cut || false;
          var preserveSpaces = options.preserveSpaces || false;
          var trailingSpaces = options.trailingSpaces || false;

          var result;

          if (width <= 0) {
            return str;
          } else if (!cut) {
            var words = str.split(" ");
            var current_column = 0;
            result = "";

            while (words.length > 0) {
              // if adding a space and the next word would cause this line to be longer than width...
              if (1 + words[0].length + current_column > width) {
                //start a new line if this line is not already empty
                if (current_column > 0) {
                  // add a space at the end of the line is preserveSpaces is true
                  if (preserveSpaces) {
                    result += " ";
                    current_column++;
                  }
                  // fill the rest of the line with spaces if trailingSpaces option is true
                  else if (trailingSpaces) {
                    while (current_column < width) {
                      result += " ";
                      current_column++;
                    }
                  }
                  //start new line
                  result += seperator;
                  current_column = 0;
                }
              }

              // if not at the begining of the line, add a space in front of the word
              if (current_column > 0) {
                result += " ";
                current_column++;
              }

              // tack on the next word, update current column, a pop words array
              result += words[0];
              current_column += words[0].length;
              words.shift();
            }

            // fill the rest of the line with spaces if trailingSpaces option is true
            if (trailingSpaces) {
              while (current_column < width) {
                result += " ";
                current_column++;
              }
            }

            return result;
          } else {
            var index = 0;
            result = "";

            // walk through each character and add seperators where appropriate
            while (index < str.length) {
              if (index % width == 0 && index > 0) {
                result += seperator;
              }
              result += str.charAt(index);
              index++;
            }

            // fill the rest of the line with spaces if trailingSpaces option is true
            if (trailingSpaces) {
              while (index % width > 0) {
                result += " ";
                index++;
              }
            }

            return result;
          }
        };
      },
      { "./helper/makeString": 591 },
    ],
    642: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        var punycode = require("punycode");
        var util = require("./util");

        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;

        exports.Url = Url;

        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }

        // Reference: RFC 3986, RFC 1808, RFC 2396

        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i,
          portPattern = /:[0-9]*$/,
          // Special case for a simple path URL
          simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
          // RFC 2396: characters reserved for delimiting URLs.
          // We actually just auto-escape these.
          delims = ["<", ">", '"', "`", " ", "\r", "\n", "\t"],
          // RFC 2396: characters not allowed for various reasons.
          unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims),
          // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
          autoEscape = ["'"].concat(unwise),
          // Characters that are never ever allowed in a hostname.
          // Note that any invalid chars are also handled, but these
          // are the ones that are *expected* to be seen, so we fast-path
          // them.
          nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape),
          hostEndingChars = ["/", "?", "#"],
          hostnameMaxLen = 255,
          hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
          hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
          // protocols that can allow "unsafe" and "unwise" chars.
          unsafeProtocol = {
            javascript: true,
            "javascript:": true,
          },
          // protocols that never have a hostname.
          hostlessProtocol = {
            javascript: true,
            "javascript:": true,
          },
          // protocols that always contain a // bit.
          slashedProtocol = {
            http: true,
            https: true,
            ftp: true,
            gopher: true,
            file: true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true,
          },
          querystring = require("querystring");

        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util.isObject(url) && url instanceof Url) return url;

          var u = new Url();
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }

        Url.prototype.parse = function (
          url,
          parseQueryString,
          slashesDenoteHost
        ) {
          if (!util.isString(url)) {
            throw new TypeError(
              "Parameter 'url' must be a string, not " + typeof url
            );
          }

          // Copy chrome, IE, opera backslash-handling behavior.
          // Back slashes before the query string get converted to forward slashes
          // See: https://code.google.com/p/chromium/issues/detail?id=25916
          var queryIndex = url.indexOf("?"),
            splitter =
              queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#",
            uSplit = url.split(splitter),
            slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, "/");
          url = uSplit.join(splitter);

          var rest = url;

          // trim before proceeding.
          // This is to support parse stuff like "  http://foo.com  \n"
          rest = rest.trim();

          if (!slashesDenoteHost && url.split("#").length === 1) {
            // Try fast path regexp
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              return this;
            }
          }

          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }

          // figure out if it's got a host
          // user@server is *always* interpreted as a hostname, and url
          // resolution will treat //foo/bar as host=foo,path=bar because that's
          // how the browser resolves relative URLs.
          if (
            slashesDenoteHost ||
            proto ||
            rest.match(/^\/\/[^@\/]+@[^@\/]+/)
          ) {
            var slashes = rest.substr(0, 2) === "//";
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }

          if (
            !hostlessProtocol[proto] &&
            (slashes || (proto && !slashedProtocol[proto]))
          ) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c

            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.

            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }

            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
              // atSign can be anywhere.
              atSign = rest.lastIndexOf("@");
            } else {
              // atSign must be in auth portion.
              // http://a@b/c@d => host:b auth:a path:/c@d
              atSign = rest.lastIndexOf("@", hostEnd);
            }

            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }

            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) hostEnd = rest.length;

            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);

            // pull out port.
            this.parseHost();

            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || "";

            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname =
              this.hostname[0] === "[" &&
              this.hostname[this.hostname.length - 1] === "]";

            // validate a little.
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part) continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = "";
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      // we replace non-ASCII char with a temporary placeholder
                      // we need this to make sure size of hostname is not
                      // broken by replacing non-ASCII by nothing
                      newpart += "x";
                    } else {
                      newpart += part[j];
                    }
                  }
                  // we test again with ASCII char only
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = "/" + notHost.join(".") + rest;
                    }
                    this.hostname = validParts.join(".");
                    break;
                  }
                }
              }
            }

            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = "";
            } else {
              // hostnames are always lower case.
              this.hostname = this.hostname.toLowerCase();
            }

            if (!ipv6Hostname) {
              // IDNA Support: Returns a punycoded representation of "domain".
              // It only converts parts of the domain name that
              // have non-ASCII characters, i.e. it doesn't matter if
              // you call it with a domain that already is ASCII-only.
              this.hostname = punycode.toASCII(this.hostname);
            }

            var p = this.port ? ":" + this.port : "";
            var h = this.hostname || "";
            this.host = h + p;
            this.href += this.host;

            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== "/") {
                rest = "/" + rest;
              }
            }
          }

          // now rest is set to the post-host stuff.
          // chop off any delim chars.
          if (!unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              if (rest.indexOf(ae) === -1) continue;
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }

          // chop off from the tail first.
          var hash = rest.indexOf("#");
          if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf("?");
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = "";
            this.query = {};
          }
          if (rest) this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = "/";
          }

          //to support http.request
          if (this.pathname || this.search) {
            var p = this.pathname || "";
            var s = this.search || "";
            this.path = p + s;
          }

          // finally, reconstruct the href based on what has been validated.
          this.href = this.format();
          return this;
        };

        // format a parsed object into a url string
        function urlFormat(obj) {
          // ensure it's an object, and not a string url.
          // If it's an obj, this is a no-op.
          // this way, you can call url_format() on strings
          // to clean up potentially wonky urls.
          if (util.isString(obj)) obj = urlParse(obj);
          if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
          return obj.format();
        }

        Url.prototype.format = function () {
          var auth = this.auth || "";
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ":");
            auth += "@";
          }

          var protocol = this.protocol || "",
            pathname = this.pathname || "",
            hash = this.hash || "",
            host = false,
            query = "";

          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host =
              auth +
              (this.hostname.indexOf(":") === -1
                ? this.hostname
                : "[" + this.hostname + "]");
            if (this.port) {
              host += ":" + this.port;
            }
          }

          if (
            this.query &&
            util.isObject(this.query) &&
            Object.keys(this.query).length
          ) {
            query = querystring.stringify(this.query);
          }

          var search = this.search || (query && "?" + query) || "";

          if (protocol && protocol.substr(-1) !== ":") protocol += ":";

          // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
          // unless they had them to begin with.
          if (
            this.slashes ||
            ((!protocol || slashedProtocol[protocol]) && host !== false)
          ) {
            host = "//" + (host || "");
            if (pathname && pathname.charAt(0) !== "/")
              pathname = "/" + pathname;
          } else if (!host) {
            host = "";
          }

          if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
          if (search && search.charAt(0) !== "?") search = "?" + search;

          pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
          });
          search = search.replace("#", "%23");

          return protocol + host + pathname + search + hash;
        };

        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }

        Url.prototype.resolve = function (relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };

        function urlResolveObject(source, relative) {
          if (!source) return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }

        Url.prototype.resolveObject = function (relative) {
          if (util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }

          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }

          // hash is always overridden, no matter what.
          // even href="" will remove it.
          result.hash = relative.hash;

          // if the relative url is empty, then there's nothing left to do here.
          if (relative.href === "") {
            result.href = result.format();
            return result;
          }

          // hrefs like //foo/bar always cut to the protocol.
          if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== "protocol") result[rkey] = relative[rkey];
            }

            //urlParse appends trailing / to urls like http://www.example.com
            if (
              slashedProtocol[result.protocol] &&
              result.hostname &&
              !result.pathname
            ) {
              result.path = result.pathname = "/";
            }

            result.href = result.format();
            return result;
          }

          if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
              }
              result.href = result.format();
              return result;
            }

            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || "").split("/");
              while (relPath.length && !(relative.host = relPath.shift()));
              if (!relative.host) relative.host = "";
              if (!relative.hostname) relative.hostname = "";
              if (relPath[0] !== "") relPath.unshift("");
              if (relPath.length < 2) relPath.unshift("");
              result.pathname = relPath.join("/");
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
              var p = result.pathname || "";
              var s = result.search || "";
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }

          var isSourceAbs =
              result.pathname && result.pathname.charAt(0) === "/",
            isRelAbs =
              relative.host ||
              (relative.pathname && relative.pathname.charAt(0) === "/"),
            mustEndAbs =
              isRelAbs || isSourceAbs || (result.host && relative.pathname),
            removeAllDots = mustEndAbs,
            srcPath = (result.pathname && result.pathname.split("/")) || [],
            relPath = (relative.pathname && relative.pathname.split("/")) || [],
            psychotic = result.protocol && !slashedProtocol[result.protocol];

          // if the url is a non-slashed url, then relative
          // links like ../.. should be able
          // to crawl up to the hostname, as well.  This is strange.
          // result.protocol has already been set by now.
          // Later on, put the first path part into the host field.
          if (psychotic) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
              if (srcPath[0] === "") srcPath[0] = result.host;
              else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
          }

          if (isRelAbs) {
            // it's absolute.
            result.host =
              relative.host || relative.host === ""
                ? relative.host
                : result.host;
            result.hostname =
              relative.hostname || relative.hostname === ""
                ? relative.hostname
                : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
            // fall through to the dot-handling below.
          } else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              //occationaly the auth can get stuck only in host
              //this especially happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost =
                result.host && result.host.indexOf("@") > 0
                  ? result.host.split("@")
                  : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path =
                (result.pathname ? result.pathname : "") +
                (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
          }

          if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
              result.path = "/" + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }

          // if a url ENDs in . or .., then it must get a trailing slash.
          // however, if it ends in anything else non-slashy,
          // then it must NOT get a trailing slash.
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash =
            ((result.host || relative.host || srcPath.length > 1) &&
              (last === "." || last === "..")) ||
            last === "";

          // strip single dots, resolve double dots to parent dir
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === ".") {
              srcPath.splice(i, 1);
            } else if (last === "..") {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }

          // if the path is allowed to go above the root, restore leading ..s
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift("..");
            }
          }

          if (
            mustEndAbs &&
            srcPath[0] !== "" &&
            (!srcPath[0] || srcPath[0].charAt(0) !== "/")
          ) {
            srcPath.unshift("");
          }

          if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
          }

          var isAbsolute =
            srcPath[0] === "" || (srcPath[0] && srcPath[0].charAt(0) === "/");

          // put the host back
          if (psychotic) {
            result.hostname = result.host = isAbsolute
              ? ""
              : srcPath.length
              ? srcPath.shift()
              : "";
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost =
              result.host && result.host.indexOf("@") > 0
                ? result.host.split("@")
                : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }

          mustEndAbs = mustEndAbs || (result.host && srcPath.length);

          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
          }

          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join("/");
          }

          //to support request.http
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path =
              (result.pathname ? result.pathname : "") +
              (result.search ? result.search : "");
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };

        Url.prototype.parseHost = function () {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ":") {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host) this.hostname = host;
        };
      },
      { "./util": 643, punycode: 81, querystring: 85 },
    ],
    643: [
      function (require, module, exports) {
        "use strict";

        module.exports = {
          isString: function (arg) {
            return typeof arg === "string";
          },
          isObject: function (arg) {
            return typeof arg === "object" && arg !== null;
          },
          isNull: function (arg) {
            return arg === null;
          },
          isNullOrUndefined: function (arg) {
            return arg == null;
          },
        };
      },
      {},
    ],
    644: [
      function (require, module, exports) {
        (function (global) {
          /**
           * Module exports.
           */

          module.exports = deprecate;

          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config("noDeprecation")) {
              return fn;
            }

            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config("throwDeprecation")) {
                  throw new Error(msg);
                } else if (config("traceDeprecation")) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }

            return deprecated;
          }

          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */

          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false;
            } catch (_) {
              return false;
            }
            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === "true";
          }
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {},
    ],
    645: [
      function (require, module, exports) {
        // A cache that expires.
        module.exports = class Cache extends Map {
          constructor() {
            super();
            this.timeout = 1000;
          }
          set(key, value) {
            super.set(key, {
              tid: setTimeout(this.delete.bind(this, key), this.timeout),
              value,
            });
          }
          get(key) {
            let entry = super.get(key);
            if (entry) {
              return entry.value;
            }
          }
          delete(key) {
            let entry = super.get(key);
            if (entry) {
              clearTimeout(entry.tid);
              super.delete(key);
            }
          }
          clear() {
            for (let entry of this.values()) {
              clearTimeout(entry.tid);
            }
            super.clear();
          }
        };
      },
      {},
    ],
    646: [
      function (require, module, exports) {
        /**
         * http://en.wikipedia.org/wiki/YouTube#Quality_and_formats
         */
        module.exports = {
          "5": {
            mimeType: 'video/flv; codecs="Sorenson H.283, mp3"',
            qualityLabel: "240p",
            bitrate: 250000,
            audioBitrate: 64,
          },

          "6": {
            mimeType: 'video/flv; codecs="Sorenson H.263, mp3"',
            qualityLabel: "270p",
            bitrate: 800000,
            audioBitrate: 64,
          },

          "13": {
            mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
            qualityLabel: null,
            bitrate: 500000,
            audioBitrate: null,
          },

          "17": {
            mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
            qualityLabel: "144p",
            bitrate: 50000,
            audioBitrate: 24,
          },

          "18": {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "360p",
            bitrate: 500000,
            audioBitrate: 96,
          },

          "22": {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 2000000,
            audioBitrate: 192,
          },

          "34": {
            mimeType: 'video/flv; codecs="H.264, aac"',
            qualityLabel: "360p",
            bitrate: 500000,
            audioBitrate: 128,
          },

          "35": {
            mimeType: 'video/flv; codecs="H.264, aac"',
            qualityLabel: "480p",
            bitrate: 800000,
            audioBitrate: 128,
          },

          "36": {
            mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
            qualityLabel: "240p",
            bitrate: 175000,
            audioBitrate: 32,
          },

          "37": {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "1080p",
            bitrate: 3000000,
            audioBitrate: 192,
          },

          "38": {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "3072p",
            bitrate: 3500000,
            audioBitrate: 192,
          },

          "43": {
            mimeType: 'video/webm; codecs="VP8, vorbis"',
            qualityLabel: "360p",
            bitrate: 500000,
            audioBitrate: 128,
          },

          "44": {
            mimeType: 'video/webm; codecs="VP8, vorbis"',
            qualityLabel: "480p",
            bitrate: 1000000,
            audioBitrate: 128,
          },

          "45": {
            mimeType: 'video/webm; codecs="VP8, vorbis"',
            qualityLabel: "720p",
            bitrate: 2000000,
            audioBitrate: 192,
          },

          "46": {
            mimeType: 'audio/webm; codecs="vp8, vorbis"',
            qualityLabel: "1080p",
            bitrate: null,
            audioBitrate: 192,
          },

          "82": {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "360p",
            bitrate: 500000,
            audioBitrate: 96,
          },

          "83": {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "240p",
            bitrate: 500000,
            audioBitrate: 96,
          },

          "84": {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 2000000,
            audioBitrate: 192,
          },

          "85": {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "1080p",
            bitrate: 3000000,
            audioBitrate: 192,
          },

          "91": {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "144p",
            bitrate: 100000,
            audioBitrate: 48,
          },

          "92": {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "240p",
            bitrate: 150000,
            audioBitrate: 48,
          },

          "93": {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "360p",
            bitrate: 500000,
            audioBitrate: 128,
          },

          "94": {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "480p",
            bitrate: 800000,
            audioBitrate: 128,
          },

          "95": {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 1500000,
            audioBitrate: 256,
          },

          "96": {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "1080p",
            bitrate: 2500000,
            audioBitrate: 256,
          },

          "100": {
            mimeType: 'audio/webm; codecs="VP8, vorbis"',
            qualityLabel: "360p",
            bitrate: null,
            audioBitrate: 128,
          },

          "101": {
            mimeType: 'audio/webm; codecs="VP8, vorbis"',
            qualityLabel: "360p",
            bitrate: null,
            audioBitrate: 192,
          },

          "102": {
            mimeType: 'audio/webm; codecs="VP8, vorbis"',
            qualityLabel: "720p",
            bitrate: null,
            audioBitrate: 192,
          },

          "120": {
            mimeType: 'video/flv; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 2000000,
            audioBitrate: 128,
          },

          "127": {
            mimeType: 'audio/ts; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 96,
          },

          "128": {
            mimeType: 'audio/ts; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 96,
          },

          "132": {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "240p",
            bitrate: 150000,
            audioBitrate: 48,
          },

          "133": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "240p",
            bitrate: 200000,
            audioBitrate: null,
          },

          "134": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "360p",
            bitrate: 300000,
            audioBitrate: null,
          },

          "135": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "480p",
            bitrate: 500000,
            audioBitrate: null,
          },

          "136": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "720p",
            bitrate: 1000000,
            audioBitrate: null,
          },

          "137": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "1080p",
            bitrate: 2500000,
            audioBitrate: null,
          },

          "138": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "4320p",
            bitrate: 13500000,
            audioBitrate: null,
          },

          "139": {
            mimeType: 'audio/mp4; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 48,
          },

          "140": {
            mimeType: 'audio/m4a; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 128,
          },

          "141": {
            mimeType: 'audio/mp4; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 256,
          },

          "151": {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 50000,
            audioBitrate: 24,
          },

          "160": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "144p",
            bitrate: 100000,
            audioBitrate: null,
          },

          "171": {
            mimeType: 'audio/webm; codecs="vorbis"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 128,
          },

          "172": {
            mimeType: 'audio/webm; codecs="vorbis"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 192,
          },

          "242": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "240p",
            bitrate: 100000,
            audioBitrate: null,
          },

          "243": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "360p",
            bitrate: 250000,
            audioBitrate: null,
          },

          "244": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "480p",
            bitrate: 500000,
            audioBitrate: null,
          },

          "247": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "720p",
            bitrate: 700000,
            audioBitrate: null,
          },

          "248": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1080p",
            bitrate: 1500000,
            audioBitrate: null,
          },

          "249": {
            mimeType: 'audio/webm; codecs="opus"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 48,
          },

          "250": {
            mimeType: 'audio/webm; codecs="opus"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 64,
          },

          "251": {
            mimeType: 'audio/webm; codecs="opus"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 160,
          },

          "264": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "1440p",
            bitrate: 4000000,
            audioBitrate: null,
          },

          "266": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "2160p",
            bitrate: 12500000,
            audioBitrate: null,
          },

          "271": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1440p",
            bitrate: 9000000,
            audioBitrate: null,
          },

          "272": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "4320p",
            bitrate: 20000000,
            audioBitrate: null,
          },

          "278": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "144p 15fps",
            bitrate: 80000,
            audioBitrate: null,
          },

          "298": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "720p",
            bitrate: 3000000,
            audioBitrate: null,
          },

          "299": {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "1080p",
            bitrate: 5500000,
            audioBitrate: null,
          },

          "302": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "720p HFR",
            bitrate: 2500000,
            audioBitrate: null,
          },

          "303": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1080p HFR",
            bitrate: 5000000,
            audioBitrate: null,
          },

          "308": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1440p HFR",
            bitrate: 10000000,
            audioBitrate: null,
          },

          "313": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "2160p",
            bitrate: 13000000,
            audioBitrate: null,
          },

          "315": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "2160p HFR",
            bitrate: 20000000,
            audioBitrate: null,
          },

          "330": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "144p HDR, HFR",
            bitrate: 80000,
            audioBitrate: null,
          },

          "331": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "240p HDR, HFR",
            bitrate: 100000,
            audioBitrate: null,
          },

          "332": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "360p HDR, HFR",
            bitrate: 250000,
            audioBitrate: null,
          },

          "333": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "240p HDR, HFR",
            bitrate: 500000,
            audioBitrate: null,
          },

          "334": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "720p HDR, HFR",
            bitrate: 1000000,
            audioBitrate: null,
          },

          "335": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1080p HDR, HFR",
            bitrate: 1500000,
            audioBitrate: null,
          },

          "336": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1440p HDR, HFR",
            bitrate: 5000000,
            audioBitrate: null,
          },

          "337": {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "2160p HDR, HFR",
            bitrate: 12000000,
            audioBitrate: null,
          },
        };
      },
      {},
    ],
    647: [
      function (require, module, exports) {
        (function (setImmediate) {
          const PassThrough = require("stream").PassThrough;
          const getInfo = require("./info");
          const util = require("./util");
          const sig = require("./sig");
          const miniget = require("miniget");
          const m3u8stream = require("m3u8stream");
          const parseTime = require("m3u8stream/dist/parse-time");

          /**
           * @param {string} link
           * @param {!Object} options
           * @return {ReadableStream}
           */
          const ytdl = (link, options) => {
            const stream = createStream(options);
            ytdl.getInfo(link, options, (err, info) => {
              if (err) {
                stream.emit("error", err);
                return;
              }

              downloadFromInfoCallback(stream, info, options);
            });

            return stream;
          };
          module.exports = ytdl;

          ytdl.getBasicInfo = getInfo.getBasicInfo;
          ytdl.getInfo = getInfo.getFullInfo;
          ytdl.chooseFormat = util.chooseFormat;
          ytdl.filterFormats = util.filterFormats;
          ytdl.validateID = util.validateID;
          ytdl.validateURL = util.validateURL;
          ytdl.getURLVideoID = util.getURLVideoID;
          ytdl.getVideoID = util.getVideoID;
          ytdl.cache = {
            sig: sig.cache,
            info: getInfo.cache,
          };

          const createStream = (options) => {
            const stream = new PassThrough({
              highWaterMark: (options && options.highWaterMark) || null,
            });
            stream.destroy = () => {
              stream._isDestroyed = true;
            };
            return stream;
          };

          /**
           * Chooses a format to download.
           *
           * @param {stream.Readable} stream
           * @param {Object} info
           * @param {Object} options
           */
          const downloadFromInfoCallback = (stream, info, options) => {
            options = options || {};
            let format;
            try {
              format = util.chooseFormat(info.formats, options);
            } catch (e) {
              setImmediate(() => {
                stream.emit("error", e);
              });
              return;
            }
            stream.emit("info", info, format);
            if (stream._isDestroyed) {
              return;
            }

            let contentLength,
              downloaded = 0;
            const ondata = (chunk) => {
              downloaded += chunk.length;
              stream.emit("progress", chunk.length, downloaded, contentLength);
            };

            let req;
            if (format.isHLS || format.isDashMPD) {
              req = m3u8stream(format.url, {
                chunkReadahead: +info.live_chunk_readahead,
                begin: options.begin || (format.live && Date.now()),
                liveBuffer: options.liveBuffer,
                requestOptions: options.requestOptions,
                parser: format.isDashMPD ? "dash-mpd" : "m3u8",
                id: format.itag,
              });

              req.on("progress", (segment, totalSegments) => {
                stream.emit(
                  "progress",
                  segment.size,
                  segment.num,
                  totalSegments
                );
              });
            } else {
              if (options.begin) {
                format.url += "&begin=" + parseTime.humanStr(options.begin);
              }
              let requestOptions = Object.assign({}, options.requestOptions, {
                maxReconnects: 6,
                maxRetries: 3,
                backoff: { inc: 500, max: 10000 },
              });
              if (options.range && (options.range.start || options.range.end)) {
                requestOptions.headers = Object.assign(
                  {},
                  requestOptions.headers,
                  {
                    Range: `bytes=${options.range.start || "0"}-${
                      options.range.end || ""
                    }`,
                  }
                );
              }

              req = miniget(format.url, requestOptions);

              req.on("response", (res) => {
                if (stream._isDestroyed) {
                  return;
                }
                if (!contentLength) {
                  contentLength = parseInt(res.headers["content-length"], 10);
                }
              });
              req.on("data", ondata);
            }

            stream.destroy = () => {
              stream._isDestroyed = true;
              if (req.abort) req.abort();
              req.end();
              req.removeListener("data", ondata);
              req.unpipe();
            };

            // Forward events from the request to the stream.
            [
              "abort",
              "request",
              "response",
              "error",
              "retry",
              "reconnect",
            ].forEach((event) => {
              req.prependListener(event, (arg) => {
                stream.emit(event, arg);
              });
            });

            req.pipe(stream);
          };

          /**
           * Can be used to download video after its `info` is gotten through
           * `ytdl.getInfo()`. In case the user might want to look at the
           * `info` object before deciding to download.
           *
           * @param {Object} info
           * @param {!Object} options
           */
          ytdl.downloadFromInfo = (info, options) => {
            const stream = createStream(options);
            if (!info.full) {
              throw Error(
                "Cannot use `ytdl.downloadFromInfo()` when called " +
                  "with info from `ytdl.getBasicInfo()`"
              );
            }
            setImmediate(() => {
              downloadFromInfoCallback(stream, info, options);
            });
            return stream;
          };
        }.call(this, require("timers").setImmediate));
      },
      {
        "./info": 649,
        "./sig": 650,
        "./util": 651,
        m3u8stream: 72,
        "m3u8stream/dist/parse-time": 74,
        miniget: 76,
        stream: 555,
        timers: 563,
      },
    ],
    648: [
      function (require, module, exports) {
        const qs = require("querystring");
        const url = require("url");
        const Entities = require("html-entities").AllHtmlEntities;
        const util = require("./util");
        const parseTime = require("m3u8stream/dist/parse-time");

        const VIDEO_URL = "https://www.youtube.com/watch?v=";
        const getMetaItem = (body, name) => {
          return util.between(body, `<meta itemprop="${name}" content="`, '">');
        };

        /**
         * Get video description from html
         *
         * @param {string} html
         * @return {string}
         */
        exports.getVideoDescription = (html) => {
          const regex = /<p.*?id="eow-description".*?>(.+?)<\/p>[\n\r\s]*?<\/div>/im;
          const description = html.match(regex);
          return description
            ? Entities.decode(util.stripHTML(description[1]))
            : "";
        };

        /**
         * Get video media (extra information) from html
         *
         * @param {string} body
         * @return {Object}
         */
        exports.getVideoMedia = (body) => {
          let mediainfo = util.between(
            body,
            '<div id="watch-description-extras">',
            '<div id="watch-discussion" class="branded-page-box yt-card">'
          );
          if (mediainfo === "") {
            return {};
          }

          const regexp = /<h4 class="title">([\s\S]*?)<\/h4>[\s\S]*?<ul .*?class=".*?watch-info-tag-list">[\s\S]*?<li>([\s\S]*?)<\/li>(?:\s*?<li>([\s\S]*?)<\/li>)?/g;
          const contentRegexp = /(?: - (\d{4}) \()?<a .*?(?:href="([^"]+)")?.*?>(.*?)<\/a>/;
          const imgRegexp = /<img src="([^"]+)".*?>/;
          const media = {};

          const image = imgRegexp.exec(mediainfo);
          if (image) {
            media.image = url.resolve(VIDEO_URL, image[1]);
          }

          let match;
          while ((match = regexp.exec(mediainfo)) != null) {
            let [, key, value, detail] = match;
            key = Entities.decode(key).trim().replace(/\s/g, "_").toLowerCase();
            const content = contentRegexp.exec(value);
            if (content) {
              let [, year, mediaUrl, value2] = content;
              if (year) {
                media.year = parseInt(year);
              } else if (detail) {
                media.year = parseInt(detail);
              }
              value = value.slice(0, content.index);
              if (key !== "game" || value2 !== "YouTube Gaming") {
                value += value2;
              }
              media[key + "_url"] = url.resolve(VIDEO_URL, mediaUrl);
            }
            media[key] = Entities.decode(value);
          }
          return media;
        };

        /**
         * Get video Owner from html.
         *
         * @param {string} body
         * @return {Object}
         */
        const userRegexp = /<a href="\/user\/([^"]+)/;
        const verifiedRegexp = /<span .*?(aria-label="Verified")(.*?(?=<\/span>))/;
        exports.getAuthor = (body) => {
          let ownerinfo = util.between(
            body,
            '<div id="watch7-user-header" class=" spf-link ">',
            '<div id="watch8-action-buttons" class="watch-action-buttons clearfix">'
          );
          if (ownerinfo === "") {
            return {};
          }
          const channelName = Entities.decode(
            util.between(
              util.between(ownerinfo, '<div class="yt-user-info">', "</div>"),
              ">",
              "</a>"
            )
          );
          const userMatch = ownerinfo.match(userRegexp);
          const verifiedMatch = ownerinfo.match(verifiedRegexp);
          const channelID = getMetaItem(body, "channelId");
          const username = userMatch
            ? userMatch[1]
            : util.between(
                util.between(body, '<span itemprop="author"', "</span>"),
                "/user/",
                '">'
              );
          return {
            id: channelID,
            name: channelName,
            avatar: url.resolve(
              VIDEO_URL,
              util.between(ownerinfo, 'data-thumb="', '"')
            ),
            verified: !!verifiedMatch,
            user: username,
            channel_url: "https://www.youtube.com/channel/" + channelID,
            user_url: "https://www.youtube.com/user/" + username,
          };
        };

        /**
         * Get video published at from html.
         *
         * @param {string} body
         * @return {string}
         */
        exports.getPublished = (body) => {
          return Date.parse(getMetaItem(body, "datePublished"));
        };

        /**
         * Get video published at from html.
         * Credits to https://github.com/paixaop.
         *
         * @param {string} body
         * @return {Array.<Object>}
         */
        exports.getRelatedVideos = (body) => {
          let jsonStr = util.between(
            body,
            "'RELATED_PLAYER_ARGS': ",
            /,[\n\r]/
          );
          let watchNextJson, rvsParams, secondaryResults;
          try {
            jsonStr = JSON.parse(jsonStr);
            watchNextJson = JSON.parse(jsonStr.watch_next_response);
            rvsParams = jsonStr.rvs.split(",").map((e) => qs.parse(e));
            secondaryResults =
              watchNextJson.contents.twoColumnWatchNextResults.secondaryResults
                .secondaryResults.results;
          } catch (err) {
            return [];
          }
          let videos = [];
          for (let result of secondaryResults) {
            let details = result.compactVideoRenderer;
            if (details) {
              try {
                let viewCount = details.viewCountText.simpleText;
                let shortViewCount = details.shortViewCountText.simpleText;
                let rvsDetails = rvsParams.find(
                  (elem) => elem.id === details.videoId
                );
                if (!/^\d/.test(shortViewCount)) {
                  shortViewCount =
                    (rvsDetails && rvsDetails.short_view_count_text) || "";
                }
                viewCount = (/^\d/.test(viewCount)
                  ? viewCount
                  : shortViewCount
                ).split(" ")[0];
                videos.push({
                  id: details.videoId,
                  title: details.title.simpleText,
                  author: details.shortBylineText.runs[0].text,
                  ucid:
                    details.shortBylineText.runs[0].navigationEndpoint
                      .browseEndpoint.browseId,
                  author_thumbnail: details.channelThumbnail.thumbnails[0].url,
                  short_view_count_text: shortViewCount.split(" ")[0],
                  view_count: viewCount.replace(",", ""),
                  length_seconds: details.lengthText
                    ? Math.floor(
                        parseTime.humanStr(details.lengthText.simpleText) / 1000
                      )
                    : rvsParams && rvsParams.length_seconds + "",
                  video_thumbnail: details.thumbnail.thumbnails[0].url,
                });
              } catch (err) {
                continue;
              }
            }
          }
          return videos;
        };

        /**
         * Get like count from html.
         *
         * @param {string} body
         * @return {number}
         */
        const getLikesRegex = /\\"likeCount\\":(\d+?),\\"likeCountText\\"/;
        exports.getLikes = (body) => {
          const likes = body.match(getLikesRegex);
          return likes ? parseInt(likes[1]) : null;
        };

        /**
         * Get dislike count from html.
         *
         * @param {string} body
         * @return {number}
         */
        const getDislikesRegex = /\\"dislikeCount\\":(\d+?),\\"dislikeCountText\\"/;
        exports.getDislikes = (body) => {
          const dislikes = body.match(getDislikesRegex);
          return dislikes ? parseInt(dislikes[1]) : null;
        };
      },
      {
        "./util": 651,
        "html-entities": 59,
        "m3u8stream/dist/parse-time": 74,
        querystring: 85,
        url: 642,
      },
    ],
    649: [
      function (require, module, exports) {
        (function (process) {
          const urllib = require("url");
          const querystring = require("querystring");
          const sax = require("sax");
          const miniget = require("miniget");
          const util = require("./util");
          const extras = require("./info-extras");
          const sig = require("./sig");
          const Cache = require("./cache");

          const VIDEO_URL = "https://www.youtube.com/watch?v=";
          const EMBED_URL = "https://www.youtube.com/embed/";
          const VIDEO_EURL = "https://youtube.googleapis.com/v/";
          const INFO_HOST = "www.youtube.com";
          const INFO_PATH = "/get_video_info";

          /**
           * Gets info from a video without getting additional formats.
           *
           * @param {string} id
           * @param {Object} options
           * @param {Function(Error, Object)} callback
           */
          exports.getBasicInfo = (id, options, callback) => {
            // Try getting config from the video page first.
            const params = "hl=" + (options.lang || "en");
            let url =
              VIDEO_URL +
              id +
              "&" +
              params +
              "&bpctr=" +
              Math.ceil(Date.now() / 1000);

            // Remove header from watch page request.
            // Otherwise, it'll use a different framework for rendering content.
            const reqOptions = Object.assign({}, options.requestOptions);
            reqOptions.headers = Object.assign({}, reqOptions.headers, {
              "User-Agent": "",
            });

            miniget(url, reqOptions, (err, res, body) => {
              if (err) return callback(err);

              // Check if there are any errors with this video page.
              const unavailableMsg = util.between(
                body,
                '<div id="player-unavailable"',
                ">"
              );
              if (
                unavailableMsg &&
                !/\bhid\b/.test(util.between(unavailableMsg, 'class="', '"'))
              ) {
                // Ignore error about age restriction.
                if (
                  !body.includes('<div id="watch7-player-age-gate-content"')
                ) {
                  return callback(
                    Error(
                      util
                        .between(
                          body,
                          '<h1 id="unavailable-message" class="message">',
                          "</h1>"
                        )
                        .trim()
                    )
                  );
                }
              }

              // Parse out additional metadata from this page.
              const additional = {
                // Get the author/uploader.
                author: extras.getAuthor(body),

                // Get the day the vid was published.
                published: extras.getPublished(body),

                // Get description.
                description: extras.getVideoDescription(body),

                // Get media info.
                media: extras.getVideoMedia(body),

                // Get related videos.
                related_videos: extras.getRelatedVideos(body),

                // Get likes.
                likes: extras.getLikes(body),

                // Get dislikes.
                dislikes: extras.getDislikes(body),
              };

              const jsonStr = util.between(
                body,
                "ytplayer.config = ",
                "</script>"
              );
              let config;
              if (jsonStr) {
                config = jsonStr.slice(
                  0,
                  jsonStr.lastIndexOf(";ytplayer.load")
                );
                gotConfig(id, options, additional, config, false, callback);
              } else {
                // If the video page doesn't work, maybe because it has mature content.
                // and requires an account logged in to view, try the embed page.
                url = EMBED_URL + id + "?" + params;
                miniget(url, options.requestOptions, (err, res, body) => {
                  if (err) return callback(err);
                  config = util.between(
                    body,
                    "t.setConfig({'PLAYER_CONFIG': ",
                    /\}(,'|\}\);)/
                  );
                  gotConfig(id, options, additional, config, true, callback);
                });
              }
            });
          };

          /**
           * @param {Object} info
           * @return {Array.<Object>}
           */
          const parseFormats = (info) => {
            let formats = [];
            if (info.player_response.streamingData) {
              if (info.player_response.streamingData.formats) {
                formats = formats.concat(
                  info.player_response.streamingData.formats
                );
              }
              if (info.player_response.streamingData.adaptiveFormats) {
                formats = formats.concat(
                  info.player_response.streamingData.adaptiveFormats
                );
              }
            }
            return formats;
          };

          /**
           * @param {Object} id
           * @param {Object} options
           * @param {Object} additional
           * @param {Object} config
           * @param {boolean} fromEmbed
           * @param {Function(Error, Object)} callback
           */
          const gotConfig = (
            id,
            options,
            additional,
            config,
            fromEmbed,
            callback
          ) => {
            if (!config) {
              return callback(Error("Could not find player config"));
            }
            try {
              config = JSON.parse(config + (fromEmbed ? "}" : ""));
            } catch (err) {
              return callback(Error("Error parsing config: " + err.message));
            }
            const url = urllib.format({
              protocol: "https",
              host: INFO_HOST,
              pathname: INFO_PATH,
              query: {
                video_id: id,
                eurl: VIDEO_EURL + id,
                ps: "default",
                gl: "US",
                hl: options.lang || "en",
                sts: config.sts,
              },
            });
            miniget(url, options.requestOptions, (err, res, body) => {
              if (err) return callback(err);
              let info = querystring.parse(body);
              const player_response =
                config.args.player_response || info.player_response;

              if (info.status === "fail") {
                return callback(
                  Error(
                    `Code ${info.errorcode}: ${util.stripHTML(info.reason)}`
                  )
                );
              } else
                try {
                  info.player_response = JSON.parse(player_response);
                } catch (err) {
                  return callback(
                    Error("Error parsing `player_response`: " + err.message)
                  );
                }

              let playability = info.player_response.playabilityStatus;
              if (playability && playability.status === "UNPLAYABLE") {
                return callback(Error(util.stripHTML(playability.reason)));
              }

              info.formats = parseFormats(info);

              // Add additional properties to info.
              Object.assign(info, additional, {
                video_id: id,

                // Give the standard link to the video.
                video_url: VIDEO_URL + id,

                // Copy over a few props from `player_response.videoDetails`
                // for backwards compatibility.
                title:
                  info.player_response.videoDetails &&
                  info.player_response.videoDetails.title,
                length_seconds:
                  info.player_response.videoDetails &&
                  info.player_response.videoDetails.lengthSeconds,
              });

              info.age_restricted = fromEmbed;
              info.html5player = config.assets.js;

              callback(null, info);
            });
          };

          /**
           * Gets info from a video additional formats and deciphered URLs.
           *
           * @param {string} id
           * @param {Object} options
           * @param {Function(Error, Object)} callback
           */
          exports.getFullInfo = (id, options, callback) => {
            return exports.getBasicInfo(id, options, (err, info) => {
              if (err) return callback(err);
              const hasManifest =
                info.player_response &&
                info.player_response.streamingData &&
                (info.player_response.streamingData.dashManifestUrl ||
                  info.player_response.streamingData.hlsManifestUrl);
              if (info.formats.length || hasManifest) {
                const html5playerfile = urllib.resolve(
                  VIDEO_URL,
                  info.html5player
                );
                sig.getTokens(html5playerfile, options, (err, tokens) => {
                  if (err) return callback(err);

                  sig.decipherFormats(info.formats, tokens, options.debug);
                  let funcs = [];
                  if (
                    hasManifest &&
                    info.player_response.streamingData.dashManifestUrl
                  ) {
                    let url =
                      info.player_response.streamingData.dashManifestUrl;
                    funcs.push(getDashManifest.bind(null, url, options));
                  }
                  if (
                    hasManifest &&
                    info.player_response.streamingData.hlsManifestUrl
                  ) {
                    let url = info.player_response.streamingData.hlsManifestUrl;
                    funcs.push(getM3U8.bind(null, url, options));
                  }

                  util.parallel(funcs, (err, results) => {
                    if (err) return callback(err);
                    if (results[0]) {
                      mergeFormats(info, results[0]);
                    }
                    if (results[1]) {
                      mergeFormats(info, results[1]);
                    }

                    info.formats = info.formats.map(util.addFormatMeta);
                    info.formats.sort(util.sortFormats);
                    info.full = true;
                    callback(null, info);
                  });
                });
              } else {
                callback(Error("This video is unavailable"));
              }
            });
          };

          /**
           * Merges formats from DASH or M3U8 with formats from video info page.
           *
           * @param {Object} info
           * @param {Object} formatsMap
           */
          const mergeFormats = (info, formatsMap) => {
            info.formats.forEach((f) => {
              formatsMap[f.itag] = formatsMap[f.itag] || f;
            });
            info.formats = Object.values(formatsMap);
          };

          /**
           * Gets additional DASH formats.
           *
           * @param {string} url
           * @param {Object} options
           * @param {Function(!Error, Array.<Object>)} callback
           */
          const getDashManifest = (url, options, callback) => {
            let formats = {};

            const parser = sax.parser(false);
            parser.onerror = callback;
            parser.onopentag = (node) => {
              if (node.name === "REPRESENTATION") {
                const itag = node.attributes.ID;
                formats[itag] = { itag, url };
              }
            };
            parser.onend = () => {
              callback(null, formats);
            };

            const req = miniget(
              urllib.resolve(VIDEO_URL, url),
              options.requestOptions
            );
            req.setEncoding("utf8");
            req.on("error", callback);
            req.on("data", (chunk) => {
              parser.write(chunk);
            });
            req.on("end", parser.close.bind(parser));
          };

          /**
           * Gets additional formats.
           *
           * @param {string} url
           * @param {Object} options
           * @param {Function(!Error, Array.<Object>)} callback
           */
          const getM3U8 = (url, options, callback) => {
            url = urllib.resolve(VIDEO_URL, url);
            miniget(url, options.requestOptions, (err, res, body) => {
              if (err) return callback(err);

              let formats = {};
              body
                .split("\n")
                .filter((line) => /https?:\/\//.test(line))
                .forEach((line) => {
                  const itag = line.match(/\/itag\/(\d+)\//)[1];
                  formats[itag] = { itag: itag, url: line };
                });
              callback(null, formats);
            });
          };

          // Cached for getting basic/full info.
          exports.cache = new Cache();

          // Cache get info functions.
          // In case a user wants to get a video's info before downloading.
          for (let fnName of ["getBasicInfo", "getFullInfo"]) {
            /**
             * @param {string} link
             * @param {Object} options
             * @param {Function(Error, Object)} callback
             */
            const fn = exports[fnName];
            exports[fnName] = (link, options, callback) => {
              if (typeof options === "function") {
                callback = options;
                options = {};
              } else if (!options) {
                options = {};
              }

              if (!callback) {
                return new Promise((resolve, reject) => {
                  exports[fnName](link, options, (err, info) => {
                    if (err) return reject(err);
                    resolve(info);
                  });
                });
              }

              let id;
              try {
                id = util.getVideoID(link);
              } catch (e) {
                return callback(e);
              }

              const key = [fnName, id, options.lang].join("-");
              if (exports.cache.get(key)) {
                process.nextTick(() => callback(null, exports.cache.get(key)));
              } else {
                fn(id, options, (err, info) => {
                  if (err) return callback(err);
                  exports.cache.set(key, info);
                  callback(null, info);
                });
              }
            };
          }

          // Export a few helpers.
          exports.validateID = util.validateID;
          exports.validateURL = util.validateURL;
          exports.getURLVideoID = util.getURLVideoID;
          exports.getVideoID = util.getVideoID;
        }.call(this, require("_process")));
      },
      {
        "./cache": 645,
        "./info-extras": 648,
        "./sig": 650,
        "./util": 651,
        _process: 80,
        miniget: 76,
        querystring: 85,
        sax: 551,
        url: 642,
      },
    ],
    650: [
      function (require, module, exports) {
        const url = require("url");
        const miniget = require("miniget");
        const querystring = require("querystring");

        // A shared cache to keep track of html5player.js tokens.
        exports.cache = new Map();

        /**
         * Extract signature deciphering tokens from html5player file.
         *
         * @param {string} html5playerfile
         * @param {Object} options
         * @param {Function(!Error, Array.<string>)} callback
         */
        exports.getTokens = (html5playerfile, options, callback) => {
          let key, cachedTokens;
          const rs = /(?:html5)?player[-_]([a-zA-Z0-9\-_]+)(?:\.js|\/)/.exec(
            html5playerfile
          );
          if (rs) {
            key = rs[1];
            cachedTokens = exports.cache.get(key);
          } else {
            console.warn("Could not extract html5player key:", html5playerfile);
          }
          if (cachedTokens) {
            callback(null, cachedTokens);
          } else {
            miniget(
              html5playerfile,
              options.requestOptions,
              (err, res, body) => {
                if (err) return callback(err);

                const tokens = exports.extractActions(body);
                if (key && (!tokens || !tokens.length)) {
                  callback(
                    Error("Could not extract signature deciphering actions")
                  );
                  return;
                }

                exports.cache.set(key, tokens);
                callback(null, tokens);
              }
            );
          }
        };

        /**
         * Decipher a signature based on action tokens.
         *
         * @param {Array.<string>} tokens
         * @param {string} sig
         * @return {string}
         */
        exports.decipher = (tokens, sig) => {
          sig = sig.split("");
          for (let i = 0, len = tokens.length; i < len; i++) {
            let token = tokens[i],
              pos;
            switch (token[0]) {
              case "r":
                sig = sig.reverse();
                break;
              case "w":
                pos = ~~token.slice(1);
                sig = swapHeadAndPosition(sig, pos);
                break;
              case "s":
                pos = ~~token.slice(1);
                sig = sig.slice(pos);
                break;
              case "p":
                pos = ~~token.slice(1);
                sig.splice(0, pos);
                break;
            }
          }
          return sig.join("");
        };

        /**
         * Swaps the first element of an array with one of given position.
         *
         * @param {Array.<Object>} arr
         * @param {number} position
         * @return {Array.<Object>}
         */
        const swapHeadAndPosition = (arr, position) => {
          const first = arr[0];
          arr[0] = arr[position % arr.length];
          arr[position] = first;
          return arr;
        };

        const jsVarStr = "[a-zA-Z_\\$][a-zA-Z_0-9]*";
        const jsSingleQuoteStr = `'[^'\\\\]*(:?\\\\[\\s\\S][^'\\\\]*)*'`;
        const jsDoubleQuoteStr = `"[^"\\\\]*(:?\\\\[\\s\\S][^"\\\\]*)*"`;
        const jsQuoteStr = `(?:${jsSingleQuoteStr}|${jsDoubleQuoteStr})`;
        const jsKeyStr = `(?:${jsVarStr}|${jsQuoteStr})`;
        const jsPropStr = `(?:\\.${jsVarStr}|\\[${jsQuoteStr}\\])`;
        const jsEmptyStr = `(?:''|"")`;
        const reverseStr =
          ":function\\(a\\)\\{" + "(?:return )?a\\.reverse\\(\\)" + "\\}";
        const sliceStr =
          ":function\\(a,b\\)\\{" + "return a\\.slice\\(b\\)" + "\\}";
        const spliceStr =
          ":function\\(a,b\\)\\{" + "a\\.splice\\(0,b\\)" + "\\}";
        const swapStr =
          ":function\\(a,b\\)\\{" +
          "var c=a\\[0\\];a\\[0\\]=a\\[b(?:%a\\.length)?\\];a\\[b(?:%a\\.length)?\\]=c(?:;return a)?" +
          "\\}";
        const actionsObjRegexp = new RegExp(
          `var (${jsVarStr})=\\{((?:(?:` +
            jsKeyStr +
            reverseStr +
            "|" +
            jsKeyStr +
            sliceStr +
            "|" +
            jsKeyStr +
            spliceStr +
            "|" +
            jsKeyStr +
            swapStr +
            "),?\\r?\\n?)+)\\};"
        );
        const actionsFuncRegexp = new RegExp(
          `function(?: ${jsVarStr})?\\(a\\)\\{` +
            `a=a\\.split\\(${jsEmptyStr}\\);\\s*` +
            `((?:(?:a=)?${jsVarStr}` +
            jsPropStr +
            "\\(a,\\d+\\);)+)" +
            `return a\\.join\\(${jsEmptyStr}\\)` +
            "\\}"
        );
        const reverseRegexp = new RegExp(
          `(?:^|,)(${jsKeyStr})${reverseStr}`,
          "m"
        );
        const sliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${sliceStr}`, "m");
        const spliceRegexp = new RegExp(
          `(?:^|,)(${jsKeyStr})${spliceStr}`,
          "m"
        );
        const swapRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${swapStr}`, "m");

        /**
         * Extracts the actions that should be taken to decipher a signature.
         *
         * This searches for a function that performs string manipulations on
         * the signature. We already know what the 3 possible changes to a signature
         * are in order to decipher it. There is
         *
         * * Reversing the string.
         * * Removing a number of characters from the beginning.
         * * Swapping the first character with another position.
         *
         * Note, `Array#slice()` used to be used instead of `Array#splice()`,
         * it's kept in case we encounter any older html5player files.
         *
         * After retrieving the function that does this, we can see what actions
         * it takes on a signature.
         *
         * @param {string} body
         * @return {Array.<string>}
         */
        exports.extractActions = (body) => {
          const objResult = actionsObjRegexp.exec(body);
          const funcResult = actionsFuncRegexp.exec(body);
          if (!objResult || !funcResult) {
            return null;
          }

          const obj = objResult[1].replace(/\$/g, "\\$");
          const objBody = objResult[2].replace(/\$/g, "\\$");
          const funcBody = funcResult[1].replace(/\$/g, "\\$");

          let result = reverseRegexp.exec(objBody);
          const reverseKey =
            result &&
            result[1].replace(/\$/g, "\\$").replace(/\$|^'|^"|'$|"$/g, "");
          result = sliceRegexp.exec(objBody);
          const sliceKey =
            result &&
            result[1].replace(/\$/g, "\\$").replace(/\$|^'|^"|'$|"$/g, "");
          result = spliceRegexp.exec(objBody);
          const spliceKey =
            result &&
            result[1].replace(/\$/g, "\\$").replace(/\$|^'|^"|'$|"$/g, "");
          result = swapRegexp.exec(objBody);
          const swapKey =
            result &&
            result[1].replace(/\$/g, "\\$").replace(/\$|^'|^"|'$|"$/g, "");

          const keys = `(${[reverseKey, sliceKey, spliceKey, swapKey].join(
            "|"
          )})`;
          const myreg =
            "(?:a=)?" +
            obj +
            `(?:\\.${keys}|\\['${keys}'\\]|\\["${keys}"\\])` +
            "\\(a,(\\d+)\\)";
          const tokenizeRegexp = new RegExp(myreg, "g");
          const tokens = [];
          while ((result = tokenizeRegexp.exec(funcBody)) !== null) {
            let key = result[1] || result[2] || result[3];
            switch (key) {
              case swapKey:
                tokens.push("w" + result[4]);
                break;
              case reverseKey:
                tokens.push("r");
                break;
              case sliceKey:
                tokens.push("s" + result[4]);
                break;
              case spliceKey:
                tokens.push("p" + result[4]);
                break;
            }
          }
          return tokens;
        };

        /**
         * @param {Object} format
         * @param {string} sig
         * @param {boolean} debug
         */
        exports.setDownloadURL = (format, sig, debug) => {
          let decodedUrl;
          if (format.url) {
            decodedUrl = format.url;
          } else {
            if (debug) {
              console.warn("Download url not found for itag " + format.itag);
            }
            return;
          }

          try {
            decodedUrl = decodeURIComponent(decodedUrl);
          } catch (err) {
            if (debug) {
              console.warn("Could not decode url: " + err.message);
            }
            return;
          }

          // Make some adjustments to the final url.
          const parsedUrl = url.parse(decodedUrl, true);

          // Deleting the `search` part is necessary otherwise changes to
          // `query` won't reflect when running `url.format()`
          delete parsedUrl.search;

          let query = parsedUrl.query;

          // This is needed for a speedier download.
          // See https://github.com/fent/node-ytdl-core/issues/127
          query.ratebypass = "yes";
          if (sig) {
            // When YouTube provides a `sp` parameter the signature `sig` must go
            // into the parameter it specifies.
            // See https://github.com/fent/node-ytdl-core/issues/417
            if (format.sp) {
              query[format.sp] = sig;
            } else {
              query.signature = sig;
            }
          }

          format.url = url.format(parsedUrl);
        };

        /**
         * Applies `sig.decipher()` to all format URL's.
         *
         * @param {Array.<Object>} formats
         * @param {Array.<string>} tokens
         * @param {boolean} debug
         */
        exports.decipherFormats = (formats, tokens, debug) => {
          formats.forEach((format) => {
            if (format.cipher) {
              Object.assign(format, querystring.parse(format.cipher));
              delete format.cipher;
            }
            const sig =
              tokens && format.s ? exports.decipher(tokens, format.s) : null;
            exports.setDownloadURL(format, sig, debug);
          });
        };
      },
      { miniget: 76, querystring: 85, url: 642 },
    ],
    651: [
      function (require, module, exports) {
        const url = require("url");
        const FORMATS = require("./formats");

        // Use these to help sort formats, higher is better.
        const audioEncodingRanks = [
          "mp4a",
          "mp3",
          "vorbis",
          "aac",
          "opus",
          "flac",
        ];
        const videoEncodingRanks = [
          "mp4v",
          "avc1",
          "Sorenson H.283",
          "MPEG-4 Visual",
          "VP8",
          "VP9",
          "H.264",
        ];

        const getBitrate = (format) => parseInt(format.bitrate) || 0;
        const audioScore = (format) => {
          const abitrate = format.audioBitrate || 0;
          const aenc = audioEncodingRanks.findIndex(
            (enc) => format.codecs && format.codecs.includes(enc)
          );
          return abitrate + aenc / 10;
        };

        /**
         * Sort formats from highest quality to lowest.
         * By resolution, then video bitrate, then audio bitrate.
         *
         * @param {Object} a
         * @param {Object} b
         */
        exports.sortFormats = (a, b) => {
          const ares = a.qualityLabel
            ? parseInt(a.qualityLabel.slice(0, -1))
            : 0;
          const bres = b.qualityLabel
            ? parseInt(b.qualityLabel.slice(0, -1))
            : 0;
          const afeats = ~~!!ares * 2 + ~~!!a.audioBitrate;
          const bfeats = ~~!!bres * 2 + ~~!!b.audioBitrate;

          if (afeats === bfeats) {
            if (ares === bres) {
              let avbitrate = getBitrate(a);
              let bvbitrate = getBitrate(b);
              if (avbitrate === bvbitrate) {
                let aascore = audioScore(a);
                let bascore = audioScore(b);
                if (aascore === bascore) {
                  const avenc = videoEncodingRanks.findIndex(
                    (enc) => a.codecs && a.codecs.includes(enc)
                  );
                  const bvenc = videoEncodingRanks.findIndex(
                    (enc) => b.codecs && b.codecs.includes(enc)
                  );
                  return bvenc - avenc;
                } else {
                  return bascore - aascore;
                }
              } else {
                return bvbitrate - avbitrate;
              }
            } else {
              return bres - ares;
            }
          } else {
            return bfeats - afeats;
          }
        };

        /**
         * Choose a format depending on the given options.
         *
         * @param {Array.<Object>} formats
         * @param {Object} options
         * @return {Object}
         * @throws {Error} when no format matches the filter/format rules
         */
        exports.chooseFormat = (formats, options) => {
          if (typeof options.format === "object") {
            return options.format;
          }

          if (options.filter) {
            formats = exports.filterFormats(formats, options.filter);
            if (formats.length === 0) {
              throw Error("No formats found with custom filter");
            }
          }

          let format;
          const quality = options.quality || "highest";
          switch (quality) {
            case "highest":
              format = formats[0];
              break;

            case "lowest":
              format = formats[formats.length - 1];
              break;

            case "highestaudio":
              formats = exports.filterFormats(formats, "audio");
              format = null;
              for (let f of formats) {
                if (!format || audioScore(f) > audioScore(format)) format = f;
              }
              break;

            case "lowestaudio":
              formats = exports.filterFormats(formats, "audio");
              format = null;
              for (let f of formats) {
                if (!format || audioScore(f) < audioScore(format)) format = f;
              }
              break;

            case "highestvideo":
              formats = exports.filterFormats(formats, "video");
              format = null;
              for (let f of formats) {
                if (!format || getBitrate(f) > getBitrate(format)) format = f;
              }
              break;

            case "lowestvideo":
              formats = exports.filterFormats(formats, "video");
              format = null;
              for (let f of formats) {
                if (!format || getBitrate(f) < getBitrate(format)) format = f;
              }
              break;

            default: {
              let getFormat = (itag) => {
                return formats.find((format) => "" + format.itag === "" + itag);
              };
              if (Array.isArray(quality)) {
                quality.find((q) => (format = getFormat(q)));
              } else {
                format = getFormat(quality);
              }
            }
          }

          if (!format) {
            throw Error("No such format found: " + quality);
          }
          return format;
        };

        /**
         * @param {Array.<Object>} formats
         * @param {Function} filter
         * @return {Array.<Object>}
         */
        exports.filterFormats = (formats, filter) => {
          let fn;
          const hasVideo = (format) => !!format.qualityLabel;
          const hasAudio = (format) => !!format.audioBitrate;
          switch (filter) {
            case "audioandvideo":
              fn = (format) => hasVideo(format) && hasAudio(format);
              break;

            case "video":
              fn = hasVideo;
              break;

            case "videoonly":
              fn = (format) => hasVideo(format) && !hasAudio(format);
              break;

            case "audio":
              fn = hasAudio;
              break;

            case "audioonly":
              fn = (format) => !hasVideo(format) && hasAudio(format);
              break;

            default:
              if (typeof filter === "function") {
                fn = filter;
              } else {
                throw TypeError(`Given filter (${filter}) is not supported`);
              }
          }
          return formats.filter(fn);
        };

        /**
         * String#indexOf() that supports regex too.
         *
         * @param {string} haystack
         * @param {string|RegExp} needle
         * @return {number}
         */
        const indexOf = (haystack, needle) => {
          return needle instanceof RegExp
            ? haystack.search(needle)
            : haystack.indexOf(needle);
        };

        /**
         * Extract string inbetween another.
         *
         * @param {string} haystack
         * @param {string} left
         * @param {string} right
         * @return {string}
         */
        exports.between = (haystack, left, right) => {
          let pos = indexOf(haystack, left);
          if (pos === -1) {
            return "";
          }
          haystack = haystack.slice(pos + left.length);
          pos = indexOf(haystack, right);
          if (pos === -1) {
            return "";
          }
          haystack = haystack.slice(0, pos);
          return haystack;
        };

        /**
         * Get video ID.
         *
         * There are a few type of video URL formats.
         *  - https://www.youtube.com/watch?v=VIDEO_ID
         *  - https://m.youtube.com/watch?v=VIDEO_ID
         *  - https://youtu.be/VIDEO_ID
         *  - https://www.youtube.com/v/VIDEO_ID
         *  - https://www.youtube.com/embed/VIDEO_ID
         *  - https://music.youtube.com/watch?v=VIDEO_ID
         *  - https://gaming.youtube.com/watch?v=VIDEO_ID
         *
         * @param {string} link
         * @return {string}
         * @throws {Error} If unable to find a id
         * @throws {TypeError} If videoid doesn't match specs
         */
        const validQueryDomains = new Set([
          "youtube.com",
          "www.youtube.com",
          "m.youtube.com",
          "music.youtube.com",
          "gaming.youtube.com",
        ]);
        const validPathDomains = new Set([
          "youtu.be",
          "youtube.com",
          "www.youtube.com",
        ]);
        exports.getURLVideoID = (link) => {
          const parsed = url.parse(link, true);
          let id = parsed.query.v;
          if (validPathDomains.has(parsed.hostname) && !id) {
            const paths = parsed.pathname.split("/");
            id = paths[paths.length - 1];
          } else if (
            parsed.hostname &&
            !validQueryDomains.has(parsed.hostname)
          ) {
            throw Error("Not a YouTube domain");
          }
          if (!id) {
            throw Error("No video id found: " + link);
          }
          id = id.substring(0, 11);
          if (!exports.validateID(id)) {
            throw TypeError(
              `Video id (${id}) does not match expected ` +
                `format (${idRegex.toString()})`
            );
          }
          return id;
        };

        /**
         * Gets video ID either from a url or by checking if the given string
         * matches the video ID format.
         *
         * @param {string} str
         * @return {string}
         * @throws {Error} If unable to find a id
         * @throws {TypeError} If videoid doesn't match specs
         */
        exports.getVideoID = (str) => {
          if (exports.validateID(str)) {
            return str;
          } else {
            return exports.getURLVideoID(str);
          }
        };

        /**
         * Returns true if given id satifies YouTube's id format.
         *
         * @param {string} id
         * @return {boolean}
         */
        const idRegex = /^[a-zA-Z0-9-_]{11}$/;
        exports.validateID = (id) => {
          return idRegex.test(id);
        };

        /**
         * Checks wether the input string includes a valid id.
         *
         * @param {string} string
         * @return {boolean}
         */
        exports.validateURL = (string) => {
          try {
            exports.getURLVideoID(string);
            return true;
          } catch (e) {
            return false;
          }
        };

        /**
         * @param {Object} format
         * @return {Object}
         */
        exports.addFormatMeta = (format) => {
          format = Object.assign({}, FORMATS[format.itag], format);
          format.container = format.mimeType
            ? format.mimeType.split(";")[0].split("/")[1]
            : null;
          format.codecs = format.mimeType
            ? exports.between(format.mimeType, 'codecs="', '"')
            : null;
          format.live = /\/source\/yt_live_broadcast\//.test(format.url);
          format.isHLS = /\/manifest\/hls_(variant|playlist)\//.test(
            format.url
          );
          format.isDashMPD = /\/manifest\/dash\//.test(format.url);
          return format;
        };

        /**
         * Get only the string from an HTML string.
         *
         * @param {string} html
         * @return {string}
         */
        exports.stripHTML = (html) => {
          return html
            .replace(/[\n\r]/g, " ")
            .replace(/\s*<\s*br\s*\/?\s*>\s*/gi, "\n")
            .replace(/<\s*\/\s*p\s*>\s*<\s*p[^>]*>/gi, "\n")
            .replace(/<.*?>/gi, "")
            .trim();
        };

        /**
         * @param {Array.<Function>} funcs
         * @param {Function(!Error, Array.<Object>)} callback
         */
        exports.parallel = (funcs, callback) => {
          let funcsDone = 0;
          let errGiven = false;
          let results = [];
          const len = funcs.length;

          const checkDone = (index, err, result) => {
            if (errGiven) {
              return;
            }
            if (err) {
              errGiven = true;
              callback(err);
              return;
            }
            results[index] = result;
            if (++funcsDone === len) {
              callback(null, results);
            }
          };

          if (len > 0) {
            funcs.forEach((f, i) => {
              f(checkDone.bind(null, i));
            });
          } else {
            callback(null, results);
          }
        };
      },
      { "./formats": 646, url: 642 },
    ],
  },
  {},
  [1]
);
